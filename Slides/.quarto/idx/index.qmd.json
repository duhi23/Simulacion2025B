{"title":"An√°lisis y visualizaci√≥n de datos con R","markdown":{"yaml":{"title":"An√°lisis y visualizaci√≥n de datos con R","subtitle":"Simulaci√≥n (IMAD743)","title-slide-attributes":{"data-background-image":"img/highcharts.jpg","data-background-size":"contain","data-background-opacity":"0.40"},"author":"Escuela Polit√©cnica Nacional","affiliation":"Escuela Polit√©cnica Nacional","lang":"es","language":"custom_lang.yml","format":{"revealjs":{"theme":["default","style.scss"],"chalkboard":true,"multiplex":false,"menu":{"side":"left","width":"normal"},"footer":"[<strong>Diego Pa√∫l Huaraca S.</strong>](...) ‚Ä¢ Semestre 2025-B","slide-number":"c/t"}},"execute":{"echo":true}},"headingText":"¬°Bienvenidos al curso de Simulaci√≥n!","containsRefs":false,"markdown":"\n\n\n[**Dejad Excel a un lado**]{style=\"color:#444442;\"}  \n![](img/hateExcel.png){width=10%}\n\n---\n\n## ¬°Hola a todos!\n\n::: columns\n::: {.column width=\"30%\"}\n![](img/me.jpeg)\n:::\n\n::: {.column width=\"70%\"}\n::: incremental\n-   [**Diego Pa√∫l Huaraca Shag√±ay**]{.hl-purple}\n\n-   Ingeniero Matem√°tico. [**Escuela Polit√©cnica Nacional**]{.hl-yellow} (2013).\n\n-   M√°ster en Ciencias Actuariales y Financieras. [**Universidad de Alcal√°**]{.hl-yellow} (2018).\n\n-   Consultor Anal√≠tico de Riesgo Financiero. [**BI-SCIENCES**]{.hl-green} (desde 2018).\n\n-   Docente del Departamento de Matem√°tica. [**Escuela Polit√©cnica Nacional**]{.hl-green} (desde 2018).\n\n-   Consultor Actuarial. [**Superintendencia de Bancos**]{.hl-green} (desde 2022).\n\n-   Socio Fundador de [**Tactary Consultor√≠a Actuarial**]{.hl-green} (desde 2022).\n:::\n:::\n:::\n\n---\n\n## Contenido del curso \n<!-- Primera parte -->\n::: columns\n::: {.column width=\"20%\"}\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTPKIAIbhuhpU6GMjL2jBdHycULZOCEVt-XWs9Z_b0elEikNTefOLW3yk2ajknsTLsMDo4&usqp=CAU)\n:::\n\n::: {.column width=\"80%\"}\n::: incremental\n-   [**Introducci√≥n al Lenguaje R**]{.hl-red} ‚Üí `{a programar se aprende programando}`.\n\n-   [**An√°lisis de datos**]{.hl-red} ‚Üí `{tibble, dplyr}`.\n\n-   [**Visualizaci√≥n de datos**]{.hl-red} ‚Üí `{gr√°ficos est√°ticos y din√°micos}`.\n\n-   [**Desarrollo de aplicativos web**]{.hl-red} ‚Üí `{shiny, shinydashboard}`.\n\n-   [**Reporter√≠a din√°mica**]{.hl-red} ‚Üí `{LaTeX, rmarkdown, Quarto}`.\n\n-   [**Simuladores de n√∫meros aleatorios**]{.hl-yellow}  ‚Üí `{base}`.\n\n:::\n:::\n:::\n\n\n## Contenido del curso\n<!-- Segunda Parte -->\n::: columns\n::: {.column width=\"20%\"}\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTPKIAIbhuhpU6GMjL2jBdHycULZOCEVt-XWs9Z_b0elEikNTefOLW3yk2ajknsTLsMDo4&usqp=CAU)\n:::\n\n::: {.column width=\"80%\"}\n::: incremental\n-   [**Simulaci√≥n de variables aleatorias**]{.hl-yellow} ‚Üí `{discretas y continuas}`.\n\n-   [**Simulaci√≥n de vectores aleatorias**]{.hl-yellow}.\n\n-   [**Simulaci√≥n de procesos estoc√°sticos**]{.hl-yellow} ‚Üí `{Markov, Weiner, etc.}`.\n\n-   [**M√©todos de MonteCarlo**]{.hl-red} ‚Üí `{secuenciales, inferencia estad√≠stica}`.\n\n-   [**T√©cnicas de Remuestreo**]{.hl-red}.\n\n-   [**M√©todos de MoteCarlo en Cadenas de Markov**]{.hl-red}\n\n-   [**Aplicaciones avanzadas**]{.hl-red} ‚Üí `{simulaci√≥n por eventos}`.\n:::\n:::\n:::\n\n\n# Instalaci√≥n del Lenguaje R\n\n[**Instalando R y RStudio**]{style=\"color:#444442;\"}\n\n---\n\n## Requisitos\n\nPara el desarrollo del curso se requiere:\n\n1.  [**Conexi√≥n a internet**]{.hl-yellow} (para la descarga de paquetes y bases de datos).\n\n2.  [**Descargar R**]{.hl-yellow}: La descarga se realiza (gratuitamente) desde el enlace: <https://cran.r-project.org/>\n\n3.  [**Descargar RStudio**]{.hl-yellow}: La descarga se realiza (gratuitamente) desde el enlace: <https://posit.co/download/rstudio-desktop/>\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/cranR.jpg){width=\"440\" fig-align=\"center\"}\n:::\n\n::: {.column width=\"50%\"}\n![](img/rstudio.jpg){width=\"440\" fig-align=\"center\"}\n:::\n:::\n\n---\n\n## Instalaci√≥n de R\n\n-   [**Paso 1**]{.hl-yellow}: Ingrese al repositorio CRAN en [**https://cran.r-project.org/**](https://cran.r-project.org/){.uri} y seleccione su sistema operativo.\n\n-   [**Paso 2**]{.hl-yellow}: Para el sistema MacOs basta con hacer click en **R-4.X.Y.pkg**, y abrirlo una vez descargado. Para el sistema Windows, basta con hacer click en **install R for the first time** y despu√©s en **Download R-X.Y.Z for Windows**, una vez descargado, abrirlo como cualquier archivo de instalaci√≥n.\n\n-   [**Paso 3**]{.hl-yellow}: Abrir el ejecutable e instalar el programa con todas las opciones por defecto.\n\n. . .\n\n::: callout-important\nSiempre que tengas que descargar algo del repositorio CRAN (ya sea el propio R o un paquete), [**aseg√∫rate de tener conexi√≥n a internet**]{.hl-red}.\n:::\n\n---\n\n## CRAN\n\n- El lenguaje R se distribuye gratuitamente a trav√©s del repositorio [**Comprehensive R Archive Network (CRAN)**]{.hl-purple}  propiedad de la R Foundation for Statistical Computing.\n\n- El mantenimiento se encuentra a cargo del [**grupo R Core Team**]{.hl-purple} asistido por una gran cantidad de colaboradores internacionales.\n\n- Con la finalidad de evitar el colapso del mundo estad√≠stico, el repositorio CRAN se refleja en [**diferentes lugares**]{.hl-purple} de todo el mundo\n\n\n![](img/CRAN.png){width=\"380\" fig-align=\"center\"}\n\n---\n\n## Funcionamiento\n\n- R es un lenguaje [**orientado a objetos**]{.hl-purple} dise√±ado en un entorno aut√©ntico bajo el cual esconde su simplicidad y flexibilidad, lo cual permite a sus usuarios a√±adir funcionalidad mediante la definici√≥n de nuevas funciones y operadores.\n\n- R almacena sus variables, datos, funciones y resultados en la [**memoria activa (RAM)**]{.hl-purple} del computador en forma de objetos con un nombre espec√≠fico y pueden ser [**modificados o manipulados**]{.hl-purple} por el usuario.\n\n::: {.column width=\"100%\"}\n![](img/FunR.png){width=\"630\" fig-align=\"center\"}\n:::\n\n\n---\n\n## Primera operaci√≥n\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.\n\nEsa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una simple **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\" fig-align=\"center\"}\n:::\n:::\n\n. . .\n\n[**Idea**]{.hl-yellow}: a una variable llamada `a` le asignaremos el valor de `3` (escribiremos el c√≥digo de abajo en la consola y daremos ¬´enter¬ª)\n\n```{r}\n#| code-line-numbers: \"1\"\na <- 3\n```\n\n---\n\n## Primera operaci√≥n\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.\n\nEsa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\" fig-align=\"center\"}\n:::\n:::\n\n[**Idea**]{.hl-yellow}: definiremos otra variable llamada `b` y le asignaremos el valor `5`\n\n```{r}\n#| code-line-numbers: \"2\"\na <- 3\nb <- 5\n```\n\n. . .\n\n::: callout-note\n## F√≠jate que...\n\nEn `R` usaremos `<-` como una **flecha**: la variable a la izquierda de dicha flecha recibe el valor que hay a la derecha (por ejemplo, `a <- 3`)\n:::\n\n---\n\n## Primera operaci√≥n\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.\n\nEsa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\"}\n:::\n:::\n\n[**Idea**]{.hl-yellow}: haremos la suma `a + b` y nos devolver√° su resultado\n\n```{r}\n#| code-line-numbers: \"3\"\na <- 3\nb <- 5\na + b\n```\n\n---\n\n## Instalaci√≥n de RStudio\n\n`RStudio` ser√° el [**Bloc de Notas**]{.hl-purple} que usaremos para escribir los c√≥digos (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).\n\n-   [**Paso 1**]{.hl-yellow}: Ingrese a la p√°gina de Posit en [**https://posit.co/download/rstudio-desktop/**](https://posit.co/download/rstudio-desktop/){.uri} y seleccione la descarga gratuita.\n\n-   [**Paso 2**]{.hl-yellow}: Selecciona el ejecutable en funci√≥n al sistema operativo que use.\n\n-   [**Paso 3**]{.hl-yellow}: Luego de la descarga, se apertura el ejecutable como cualquier otro programa y se instala todo por defecto.\n\n---\n\n## Organizaci√≥n de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes (la suma de las variables) en ella. La consola ser√° donde [**ejecutaremos √≥rdenes y mostraremos resultados**]{.hl-purple}.\n\n![](img/consola_rstudio.jpg){width=\"420\" fig-align=\"center\"}\n\n---\n\n## Organizaci√≥n de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Environment**]{.hl-yellow}: la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n a tu gusto) que tenemos en la parte superior derecha. Nos mostrar√° las [**variables que tenemos definidas**]{.hl-purple}.\n\n![](img/environment.jpg){width=\"380\" fig-align=\"center\"}\n\n---\n\n## Organizaci√≥n de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha servir√° para buscar [**ayuda de funciones**]{.hl-purple}, para [**visualizar gr√°ficos**]{.hl-purple}, as√≠ como para la [**carga de librer√≠as**]{.hl-purple} y [**navegaci√≥n**]{.hl-purple} por las carpetas del CPU.\n\n![](img/multiusos.jpg){width=\"420\" fig-align=\"center\"}\n\n# ¬øQu√© es R? Primeros usos\n\n[**¬øCu√°les son las ventajas? Primer uso**]{style=\"color:#444442;\"}\n\n---\n\n## ¬øQu√© es R? ¬øPor qu√© R?\n\n![](img/meme_barco.jpg){fig-align=\"center\"}\n\n---\n\n## ¬øQu√© es R? ¬øPor qu√© R?\n\n`R` es el [**lenguaje estad√≠stico por excelencia**]{.hl-yellow}, creado por y para estad√≠sticos/as, con 5 ventajas fundamentales [**frente a Excel**]{.hl-red}:\n\n\n::: incremental\n-   [**Lenguaje de programaci√≥n**]{.hl-yellow}: la obviedad [‚Üí an√°lisis [**replicables**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Gratuito**]{.hl-yellow}: la filosof√≠a de la comunidad de `R` es el compartir c√≥digo bajo **copyleft** [‚Üí [**uso √©tico de dinero p√∫blico**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a c√≥digo ajeno, incluso al **propio c√≥digo fuente** [‚Üí [**flexibilidad y transparencia**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo m√≠nimo, pero existen c√≥digos de otras personas que podemos reusar (19430 [**paquetes**]{.hl-yellow} al 28/04/2023) [‚Üí [**ahorro de tiempo**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programaci√≥n (como Python) [‚Üí [**menor curva de aprendizaje**]{.hl-purple}]{.fragment .fade-in}\n:::\n\n\n## ¬øPor qu√© programar?\n\n-   [**Automatizar**]{.hl-yellow} ‚Üí te permitir√° automatizar tareas recurrentes (ejemplo: actualizar pron√≥sticos del tiempo, actualizar informes estad√≠sticos) de forma que solo tendr√°s que programarlo uno vez.\n\n-   [**Replicabilidad**]{.hl-yellow} ‚Üí podr√°s replicar tu an√°lisis siempre de la misma manera.\n\n-   [**Flexibilidad**]{.hl-yellow} ‚Üí podr√°s adaptar el software a tus necesidades.\n\n-   [**Transparencia**]{.hl-yellow} ‚Üí ser auditado por la comunidad.\n\n![](img/the_general_problem.png){fig-align=\"center\"}\n\n---\n\n## Idea fundamental: paquetes\n\nUna de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: c√≥digos que otras personas han implementado para **resolver un problema**\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/paquetes.png)\n:::\n\n::: {.column width=\"65%\"}\n::: {.fragment fragment-index=\"1\"}\n-   [**Instalaci√≥n**]{.hl-yellow}: descargamos los c√≥digos de la web (necesitamos internet) ‚Üí [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)\n\n```{r}\n#| eval: false\ninstall.packages(\"dplyr\")\n```\n:::\n\n::: {.fragment fragment-index=\"2\"}\n-   [**Carga**]{.hl-yellow}: indicamos qu√© paquetes queremos usar cada vez que iniciamos `RStudio` ‚Üí [**traer el libro de la estanter√≠a**]{.hl-purple}\n\n```{r}\n#| eval: false\nlibrary(dplyr)\n```\n:::\n:::\n:::\n\n---\n\n## Idea fundamental: paquetes\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/paquetes.png)\n:::\n\n::: {.column width=\"65%\"}\nUna vez instalado, hay dos manera de usar un paquete (traerlo de la estanter√≠a)\n\n::: {.fragment fragment-index=\"1\"}\n-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesi√≥n [**todo el libro**]{.hl-purple}\n\n```{r}\n#| eval: false\nlibrary(dplyr)\n```\n:::\n\n::: {.fragment fragment-index=\"2\"}\n-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le √≠ndicamos que solo queremos una [**p√°gina concreta de ese libro**]{.hl-purple}\n\n```{r}\n#| eval: false\ndplyr::rename_if()\n```\n:::\n:::\n:::\n\n---\n\n## Paquetes: Acceso a funciones\n\n::: columns\n::: {.column width=\"22%\"}\n![](img/stringr.png)\n:::\n\n::: {.column width=\"78%\"}\nUna vez instalado y cargado el paquete, es posible indagar sobre las funciones que contiene a partir del comando `ls(\"package:_____\")`.\n\n```{r}\nlibrary(stringr)\nls(\"package:stringr\")\n```\n:::\n\n:::\n\n---\n\n## Carga de m√∫ltiples paquetes\n\nEn el caso que se requieran cargar varias librer√≠as se puede evitar la ejecuci√≥n de varias l√≠neas de c√≥digo a partir de la siguiente opci√≥n:\n```{r}\n#| eval: false\n# Listado de paquetes a cargar\npaquetes <- c(\"pckg_1\",\"pckg_2\", ... , \"pckg_n\")\n\n# Sentencia de carga\nlapply(paquetes, FUN=library, character.only=TRUE)\n```\n\n¬†\n\n. . .\n\nCon el fin de evitar cargar las librer√≠as m√°s utilizadas al arranque de cada sesi√≥n, se puede automatizar esta tarea a partir del archivo `.RProfile`\n```{r}\n#| eval: false\n# Crea el archivo .RProfile en el caso que no exista\nif(!file.exists(\"~/.Rprofile\")){\n  file.create(\"~/.Rprofile\")\n} \n\n# edita el archivo .RProfile y coloca las instrucciones a ejecutar autom√°ticamente\nfile.edit(\"~/.Rprofile\") \n```\n\n---\n\n## Respaldando informaci√≥n\n\nUna tarea importante dentro del an√°lisis de datos es el respaldo de informaci√≥n que se pueda dar sobre ciertos resultados obtenidos, en este punto R consta de dos comandos muy √∫tiles: `save` y `load`.\n\n¬†\n\n. . .\n\nEl primero de ellos permite almacenar en disco los objetos que desee el usuario (almacenamiento parcial), dicho comando tambi√©n puede ser configurado de tal manera que almacenen todos los objetos que se encuentra v√°lidos en el √°rea de trabajo.\n\n```{r}\n#| eval: false\nvector <- c(1,2,3,4,5)\nmatriz <- matrix(c(1,2,3,4,5,6), ncol = 2)\n\n# Si deseas guardar el objeto \"vector\" con el nombre \"Respaldos\"\nsave(vector, file = \"Respaldos.RData\")\n\n# para el caso que se desee almacenar todos los objetos con el nombre \"TotalRespaldos\" \nsave(list = ls(all = TRUE), file = \"TotalRespaldos.RData\")\n```\n\n---\n\n\n## Mensajes de error o advertencia\n\nDurante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera ‚Üí [**te vas equivocar**]{.hl-yellow}. No solo ser√° importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.\n\n. . .\n\n-   [**Mensajes de error**]{.hl-red}: precedidos de **¬´Error in...¬ª** y ser√°n aquellos fallos que [**impidan la ejecuci√≥n**]{.hl-yellow}\n\n```{r}\n#| error: true\n\"a\" + 1 \n```\n\n. . .\n\n-   [**Mensajes de warning**]{.hl-orange}: precedidos de **¬´Warning in...¬ª** son los (posibles) fallos m√°s delicados ya que son incoherencias que [**no impiden la ejecuci√≥n**]{.hl-yellow}\n\n```{r}\n#| warning: true\n# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe\nsqrt(-1)\n```\n\n---\n\n## Antes de arrancar: scripts\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/abrir_script.jpg){width=\"350\"}\n:::\n\n::: {.column width=\"65%\"}\nUn [**script**]{.hl-yellow} ser√° el documento en el que programamos, nuestro `blog de notas` (aqu√≠ con extensi√≥n `.R`) donde escribiremos las √≥rdenes. Para **abrir nuestro primero script**, haz click en el men√∫ en `File < New File < R Script`.\n:::\n:::\n\n::: callout-warning\n## Cuidado\n\nEs importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habr√°s perdido**]{.hl-red}.\n:::\n\n---\n\n## Ejecutando el primer script\n\nAhora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros c√≥digos**]{.hl-yellow}. ¬øC√≥mo ejecutarlo?\n\n. . .\n\n1.  **Escribimos** el c√≥digo a ejecutar.\n\n. . .\n\n2.  **Guardamos** el archivo .R haciendo click en `Save current document`.\n\n. . .\n\n3.  El c√≥digo no se ejecuta salvo que se lo indiquemos. Tenemos tres opciones:\n\n-   [**Copiar y pegar**]{.hl-yellow} en consola.\n-   [**Seleccionar l√≠neas**]{.hl-yellow} y `Ctrl+Enter`\n-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el c√≥digo **completo**.\n\n---\n\n## üíª Tu turno\n\n[**Ejecuta tu primer script**: crea un script de cero, programa lo indicado debajo y ejec√∫talo (de las 3 maneras posibles)]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Define una variable de nombre `a` y cuyo valor sea -1\n\n```{r}\n#| code-fold: true\na <- -1\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù A√±ade debajo otra l√≠nea para definir una variable `b` con el valor 5. Tras ello m√∫ltiplica ambas variables\n\n```{r}\n#| code-fold: true\n#| eval: false\nb <- 5\na * b # sin guardar\nmultiplicacion <- a * b # guardado\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Modifica el c√≥digo inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables.\n\n```{r}\n#| eval: false\nc <- # deber√≠as asignarle el valor 3\nd <- # deber√≠as asignarle el valor -1\n```\n\n```{r}\n#| code-fold: true\n#| eval: false\nc <- 3\nd <- -1\nc / d # sin guardar\ndivision <- c / d # guardado\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Asigna un valor positivo a `x` y calcula su ra√≠z cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la funci√≥n `abs()`.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx <- 5\nsqrt(x)\n\ny <- -2\nabs(y)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Usando la variable `x` ya definida, completa/modifica el c√≥digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.\n\n```{r}\n#| eval: false\nz <- ? - ? # completa el c√≥digo\nz\n```\n\n```{r}\n#| code-fold: true\n#| eval: false\nz <- x - 5\nz\n```\n:::\n\n::: callout-note\n## Toma nota\n\nComandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: l√≠neas de c√≥digo que hemos ¬´encapsulado¬ª bajo un nombre, y dado unos argumentos de entrada, ejecuta las √≥rdenes (una especie de atajo).\n:::\n\n\n# Primeros datos: variables\n\n[**¬øQu√© tipos de datos existen?**]{style=\"color:#444442;\"}\n\n---\n\n## De la CELDA a la TABLA\n\n¬øQu√© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?\n\n![](img/celdas.jpg){fig-align=\"center\"}\n\n::: incremental\n-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.\n-   [**Variable**]{.hl-yellow}: **concatenaci√≥n** de valores del mismo tipo ([**vectores**]{.hl-purple}).\n-   [**Matriz**]{.hl-yellow}: concatenaci√≥n de variables del **mismo tipo y longitud**.\n-   [**Tabla**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}\n-   [**Lista**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}\n:::\n\n---\n\n## Celdas: tipos de datos\n\n¬øExisten [**variables m√°s all√° de los n√∫meros**]{.hl-yellow}?\n\n. . .\n\nPiensa por ejemplo en los datos guardados de una persona:\n\n::: {.fragment .fade-up}\n-   La edad o el peso ser√° un [**n√∫mero**]{.hl-yellow}.\n\n```{r}\nedad <- 33\n```\n:::\n\n::: {.fragment .fade-up}\n-   Su nombre ser√° una cadena de [**texto (string o char)**]{.hl-yellow}.\n\n```{r}\nnombre <- \"Diego\"\n```\n:::\n\n::: {.fragment .fade-up}\n-   A la pregunta ¬´¬øest√° usted soltero/a?¬ª la respuesta ser√° lo que llamamos una [**variable l√≥gica**]{.hl-yellow} (`TRUE` si est√° soltero/a o `FALSE` en otro caso).\n\n```{r}\nsoltero <- FALSE\n```\n:::\n\n::: {.fragment .fade-up}\n-   Su fecha de nacimiento ser√° precisamente eso, una [**fecha**]{.hl-yellow}.\n:::\n\n---\n\n## Variables num√©ricas\n\nEl dato m√°s sencillo (ya lo hemos usado) ser√°n las [**variables num√©ricas**]{.hl-yellow}\n\n```{r}\n#| eval: false\na <- 5\nb <- 2\na + b\n```\n\n```{r}\n#| echo: false\n#| include: false\na <- 5\nb <- 2\na + b\n```\n\n¬†\n\n. . .\n\nPara saber el tipo de una variable tenemos la funci√≥n `class()`\n\n```{r}\nclass(a)\n```\n\n¬†\n\n. . .\n\nCon las variables num√©ricas podemos realizar las [**operaciones aritm√©ticas**]{.hl-yellow} de una calculadora: sumar (`+`), ra√≠z cuadrada (`sqrt()`), cuadrado (`^2`), etc.\n\n```{r}\na^2\n```\n\n---\n\n## Variables de texto\n\nImagina que adem√°s de la edad de una persona queremos guardar su nombre\n\n```{r}\nnombre <- \"Diego\"\nclass(nombre)\n```\n\n¬†\n\n. . .\n\nLas [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones**]{.hl-red} aritm√©ticas (s√≠ otras operaciones como pegar o localizar patrones).\n\n```{r}\n#| error: true\nnombre + 1 # error al sumar n√∫mero a texto\n```\n\n¬†\n\n. . .\n\n::: callout-warning\n## Recuerda que...\n\nLas variables de tipo texto (character o stringr) van siempre [**entre comillas**]{.hl-orange}.\n:::\n\n---\n\n## Primera funci√≥n: paste\n\nComo hemos comentado, una [**funci√≥n**]{.hl-yellow} es un trozo de **c√≥digo encapsulado** bajo un nombre que depende de unos argumentos de entrada. Nuestra primera funci√≥n ser√° `paste()`: dadas dos cadenas de texto nos permite pegarlas.\n\n```{r}\npaste(\"Diego\", \"Huaraca\")\n```\n\n¬†\n\n. . .\n\nF√≠jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos a√±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador\n\n```{r}\npaste(\"Diego\", \"Huaraca\", sep = \"*\")\n```\n\n¬†\n\n. . .\n\n```{r}\npaste(\"Diego\", \"Huaraca\", sep = \" - \")\n```\n\n---\n\n## Primera funci√≥n: paste\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/paste_help.jpg)\n:::\n\n::: {.column width=\"50%\"}\n¬øC√≥mo saber que argumentos tiene una funci√≥n? Escribiendo en consola `? paste` o alternativamente `help(\"paste\")` te aparecer√° una [**ayuda**]{.hl-yellow} en el panel multiusos.\n\nEn dicha ayuda podr√°s ver en su cabecera que argumentos ya tiene asignados por defecto la funci√≥n\n:::\n:::\n\n. . .\n\nExiste una funci√≥n similar llamada `paste0()` que pega por defecto con `sep = \"\"` (sin nada).\n\n```{r}\npaste0(\"Diego\", \"Huaraca\")\n```\n\n---\n\n## Primer paquete: glue\n\nUna forma m√°s intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos ser√° ¬´comprar el libro¬ª (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}\n\n```{r}\n#| eval: false\ninstall.packages(\"glue\") # solo la primera vez\nlibrary(glue)\n```\n\n```{r}\n#| echo: false\nlibrary(glue)\n```\n\n. . .\n\nCon dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, ¬´la edad es de ... a√±os¬ª, donde la edad est√° guardada en una variable.\n\n```{r}\nedad <- 33\nglue(\"La edad es de {edad} a√±os\")\n```\n\n. . .\n\nDentro de las llaves tambi√©n podemos ejecutar operaciones\n\n```{r}\nunidades <- \"d√≠as\"\nglue(\"La edad es de {edad * 365} {unidades}\")\n```\n\n---\n\n## Variables l√≥gicas\n\nUna [**variable l√≥gica o binaria**]{.hl-yellow} es aquella que toma **dos valores**:\n\n-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.\n-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.\n-   `NA`: [**dato ausente**]{.hl-yellow} son las siglas de *not available*.\n\n```{r}\nsoltero <- TRUE # ¬øEs soltero? --> S√ç\nclass(soltero)\n```\n\n. . .\n\n::: callout-important\n## Importante\n\nLas variables l√≥gicas [**NO son variables de texto**]{.hl-red}: `\"TRUE\"` es un texto, `TRUE` es un valor l√≥gico.\n\n```{r}\n#| error: true\nTRUE + 1\n\"TRUE\" + 1\n```\n:::\n\n---\n\n## Condiciones l√≥gicas\n\nLos valores l√≥gicos suelen ser resultado de [**evaluar condiciones l√≥gicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos comprobar si una persona se llama Julia.\n\n```{r}\nnombre <- \"Mar√≠a\"\n```\n\n¬†\n\n. . .\n\nCon el [**operador l√≥gico**]{.hl-yellow} `==` preguntamos s√≠ a la izquierda es igual a la derecha\n\n```{r}\nnombre == \"Julia\"\n```\n\n. . .\n\nCon su opuesto `!=` preguntamos si es distinto.\n\n```{r}\nnombre != \"Julia\"\n```\n\n. . .\n\n::: callout-note\n## F√≠jate que...\n\nNo es lo mismo `<-` (asignaci√≥n) que una [**comparaci√≥n l√≥gica**]{.hl-yellow} con `==` (estamos preguntando).\n:::\n\n---\n\n## Condiciones l√≥gicas\n\nAdem√°s de las comparaciones ¬´igual a¬ª frente ¬´distinto¬ª, tambi√©n comparaciones de orden como `<, <=, > o >=`.\n\n¬†\n\n**¬øTiene la persona menos de 32 a√±os?**\n\n```{r}\nedad <- 38\nedad < 32 # ¬øEs la edad menor de 32 a√±os?\n```\n\n¬†\n\n**¬øLa edad es mayor o igual que 38 a√±os?**\n\n```{r}\nedad >= 38\n```\n\n---\n\n## Variables de fecha\n\nUn tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.\n\n```{r}\nfecha_char <- \"2021-04-21\"\n```\n\n. . .\n\nParece una simple cadena de texto pero [**representa un instante en el tiempo**]{.hl-yellow}. ¬øQu√© deber√≠a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?\n\n```{r}\n#| error: true\nfecha_char + 1\n```\n\n. . .\n\nLas fechas [**no pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha con `as_date()` del paquete `{lubridate}`\n\n```{r}\nlibrary(lubridate) # instala si no lo has hecho\nfecha <- as_date(\"2023-03-28\")\nfecha + 1\nclass(fecha)\n```\n\n---\n\n## Variables de fecha\n\nEn dicho paquete tenemos funciones muy √∫tiles para [**manejar fechas**]{.hl-yellow}:\n\n-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.\n\n```{r}\ntoday()\n```\n\n. . .\n\n-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}\n\n```{r}\nnow()\n```\n\n. . .\n\n-   Con `year()`, `month()` o `day()` podemos [**extraer el a√±o, mes y d√≠a**]{.hl-purple}\n\n```{r}\nfecha <- today()\nyear(fecha)\nmonth(fecha)\n```\n\n---\n\n## Res√∫menes de paquetes\n\n![](img/lubridate.png)\n\n::: callout-note\n## Amplia contenido\n\nTienes un resumen en pdf de los paquetes m√°s importantes en la [**carpeta ¬´fichas paquetes¬ª**]{.hl-green}\n:::\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Define una variable que guarde tu edad y otra con tu nombre\n\n```{r}\n#| code-fold: true\nedad <- 33\nnombre <- \"Javi\"\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Define otra variable que responda la pregunta ¬´¬øtengo hermanos?¬ª y otra con la fecha de tu nacimiento.\n\n```{r}\n#| code-fold: true\nhermanos <- TRUE\n\nlibrary(lubridate)\nfecha_nacimiento <- as_date(\"1989-09-10\")\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Define otra variable con tus apellidos y junta con `glue()` las variables `nombre` y `apellidos` (una coma entre ellos) en una sola variable `nombre_completo`.\n\n```{r}\n#| code-fold: true\n#| eval: false\napellidos <- \"√Ålvarez Li√©bana\"\nglue(\"{nombre}, {apellidos}\")\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Calcula los d√≠as que han pasado desde la fecha de tu nacimiento, haciendo la resta entre la fecha de hoy y la fecha de nacimiento definida en el ejercicio 2.\n\n```{r}\n#| code-fold: true\n#| eval: false\ntoday() - fecha_nacimiento\n```\n:::\n\n\n# Primeros datos: vectores\n\n[**¬øC√≥mo concatenamos valores? ¬øC√≥mo creamos una columna?**]{style=\"color:#444442;\"}\n\n---\n\n## Vectores: concatenar\n\nCuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaci√≥n**]{.hl-purple} de variables del [**mismo tipo**]{.hl-purple}\n\n¬†\n\n. . .\n\nLa forma m√°s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus elementos entre par√©ntesis y separados por comas\n\n```{r}\nedades <- c(33, 27, 60, 61)\nedades\n```\n\n¬†\n\n. . .\n\n::: callout-tip\nUn n√∫mero individual `x <- 1` es en realidad un vector de longitud uno.\n:::\n\n---\n\n## Vectores: concatenar\n\n::: columns\n::: {.column width=\"40%\"}\n![](img/edades_environment.jpg)\n:::\n\n::: {.column width=\"60%\"}\nComo ves ahora en el `environment` tenemos una **colecci√≥n de elementos** guardada\n\n```{r}\nedades\n```\n:::\n:::\n\n. . .\n\n¬†\n\nLa [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`\n\n```{r}\nlength(edades)\n```\n\n. . .\n\nTambi√©n podemos [**concatenar vectores**]{.hl-yellow}\n\n```{r}\nc(edades, edades, 8)\n```\n\n---\n\n## Secuencias num√©ricas\n\nEn muchas ocasiones querremos crear [**secuencias num√©ricas**]{.hl-yellow} (por ejemplo, los d√≠as del mes). El comando `seq(inicio, fin)` nos permite crear una **secuencia** desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.\n\n```{r}\nseq(1, 31)\n```\n\n¬†\n\n. . .\n\nEl comando `1:n` nos devuelve lo mismo que `seq(1, n)` (si el elemento inicial es mayor que el final, entender√° que la secuencia es **decreciente**)\n\n```{r}\n1:5\n7:-3\n```\n\n---\n\n## Secuencias num√©ricas\n\nTambi√©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos\n\n```{r}\nseq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5\n```\n\n. . .\n\n¬†\n\nOtras veces nos interesar√° definir una [**secuencia con una longitud concreta**]{.hl-yellow}\n\n```{r}\nseq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7\n```\n\n. . .\n\n¬†\n\nIncluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}\n\n```{r}\nrep(0, 7) # vector de 7 ceros\n```\n\n---\n\n## Vectores de caracteres\n\nUn vector es una **concatenaci√≥n** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo.\n\n```{r}\nfrase <- \"Me llamo Diego\"\nfrase\nlength(frase)\n```\n\n¬†\n\n. . .\n\nEn el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas\n\n```{r}\nvector <- c(\"Me\", \"llamo\", \"Diego\")\nvector\nlength(vector)\n```\n\n---\n\n## Vectores de caracteres\n\n¬øQu√© suceder√° si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?\n\n¬†\n\n. . .\n\n```{r}\nc(1, 2, \"Diego\", \"3\", TRUE)\n```\n\nF√≠jate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}\n\n¬†\n\n. . .\n\n```{r}\nc(3, 4, TRUE, FALSE)\n```\n\nEs importante entender que los valores l√≥gicos en realidad est√°n [**almacenados internamente como 0/1**]{.hl-yellow}\n\n---\n\n## Operaciones con vectores\n\nCon los vectores num√©ricos podemos hacer las mismas [**operaciones aritm√©ticas**]{.hl-yellow} que con los n√∫meros [‚Üí un [**n√∫mero es un vector**]{.hl-purple} (de longitud uno)]{.fragment .fade-in}\n\n\n. . .\n\n¬øQu√© suceder√° si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?\n\n. . .\n\n```{r}\nx <- c(1, 3, 5, 7)\nx + 1\nx * 2\n3 * x - 5\nx/2\n```\n\n::: callout-warning\n## Cuidado\n\nSalvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}\n:::\n\n---\n\n## Operaciones con vectores\n\nLos vectores tambi√©n pueden interactuar entre ellos, as√≠ que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)\n\n```{r}\nx <- c(2, 4, 6)\ny <- c(1, 3, 5)\nx + y\n```\n\n¬†\n\n. . .\n\nDado que la operaci√≥n (por ejemplo, una suma) se realiza elemento a elemento, ¬øqu√© suceder√° si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?\n\n. . .\n\n```{r}\nz <- c(1, 3, 5, 7)\nx + z\n```\n\nLo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que har√° ser√° reciclar del vector con menor longitud.\n\n---\n\n## Operaciones con vectores\n\nUna operaci√≥n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones l√≥gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...\n\n[**¬øQu√© d√≠as hizo menos de 22 grados?**]{.hl-yellow}\n\n```{r}\nx <- c(15, 20, 31, 27, 15, 29)\n```\n\n. . .\n\n```{r}\nx < 22\n```\n\nNos devolver√° un [**vector l√≥gico**]{.hl-yellow}, en funci√≥n de si **cada elemento** cumple o no la condici√≥n pedida.\n\n. . .\n\nSi tuvi√©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese d√≠a), la condici√≥n evaluada tambi√©n ser√≠a `NA`\n\n```{r}\ny <- c(15, 20, NA, 31, 27, 7, 29, 10)\ny < 22\n```\n\n---\n\n## Operaciones con vectores\n\nLas [**condiciones l√≥gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:\n\n-   [**Intersecci√≥n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunci√≥n y**]{.hl-purple} con `&`) para devolver un `TRUE`\n\n```{r}\nx < 30 & x > 15\n```\n\n-   [**Uni√≥n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunci√≥n o**]{.hl-purple} con `|`)\n\n```{r}\nx < 30 | x > 15\n```\n\n. . .\n\nCon `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen\n\n```{r}\nany(x < 30)\nall(x < 30)\n```\n\n---\n\n## Operaciones con vectores\n\nTambi√©n podemos hacer uso de [**operaciones estad√≠sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.\n\n```{r}\nx <- c(4, -2, 3, -7)\nsum(x)\n```\n\n¬†\n\n[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}\n\n. . .\n\n```{r}\nx <- c(4, -2, 3, NA, -7)\nsum(x)\n```\n\nPor defecto, si tenemos un dato ausente, la [**operaci√≥n tambi√©n ser√° ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`\n\n```{r}\nsum(x, na.rm = TRUE)\n```\n\n---\n\n## Operaciones con vectores\n\nComo hemos comentado que los valores l√≥gicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritm√©ticas.\n\n¬†\n\nPor ejemplo, si queremos [**averiguar el n√∫mero o el promedio de elementos que cumplen una condici√≥n**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendr√°n asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar o promediar dicho vector l√≥gico para obtener el n√∫mero de elementos que cumplen\n\n```{r}\nx <- c(-5, 7, 2, 4, 6, 9, -1)\n\n# N√∫mero de elementos que cumplen la condici√≥n\nsum(x < 3)\n\n# Promedio de elementos que cumplen la condici√≥n\nmean(x<3)\n```\n\n---\n\n## Operaciones con vectores\n\nOtras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.\n\n¬†\n\n-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La m√°s conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores at√≠picos o outliers (valores muy grandes o muy peque√±os), la media se perturba con mucha facilidad.\n\n```{r}\nx <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)\nmean(x, na.rm = TRUE)\n```\n\n---\n\n## Operaciones con vectores\n\nOtras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.\n\n¬†\n\n-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.\n\n```{r}\nx <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)\nmedian(x)\n```\n\n. . .\n\n-   [**Percentiles**]{.hl-yellow}: medidas de posici√≥n (nos dividen en partes iguales los datos).\n\n```{r}\nquantile(x) # por defecto percentiles 0-25-50-75-100\nquantile(x, probs = seq(0.1, 0.9, by = 0.1)) # deciles\n```\n\n---\n\n## Operaciones con vectores\n\nOtra operaci√≥n muy habitual es la de [**acceder a elementos**]{.hl-yellow} de un vector. La forma m√°s sencilla es usar el operador `[i]` (acceder al elemento i-√©simo)\n\n```{r}\nedades <- c(20, 30, 33, NA, 61) \nedades[3] # accedemos a la edad de la tercera persona \n```\n\n. . .\n\n¬†\n\nDado que un n√∫mero no es m√°s que un vector de longitud uno, esta operaci√≥n tambi√©n la podemos aplicar usando un [**vector de √≠ndices a seleccionar**]{.hl-yellow}\n\n```{r}\ny <- c(\"hola\", \"qu√©\", \"tal\", \"est√°s\", \"?\")\ny[c(1:2, 4)] # primer, segundo y cuarto elemento\n```\n\n::: callout-tip\nPara acceder al √∫ltimo sin preocuparnos, podemos pasarle como √≠ndice la longitud `x[length(x)]`\n:::\n\n---\n\n## Operaciones con vectores\n\nOtras veces queremos [**eliminar algunos elementos**]{.hl-yellow}, para ello, se repite la misma operaci√≥n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-√©simo del vector sino que lo ¬´des-selecciona¬ª\n\n```{r}\ny\ny[-2]\n```\n\n¬†\n\n. . .\n\nEn muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones l√≥gicas**]{.hl-yellow}, en funci√≥n de los valores, as√≠ que pasaremos como √≠ndice la propia condici√≥n (recuerda, `x < 2` nos devuelve un vector l√≥gico)\n\n```{r}\nedades <- c(15, 21, 30, 17, 45)\nnombres <- c(\"Javier\", \"Mar√≠a\", \"Laura\", \"Julia\", \"Luis\")\nnombres[edades < 18] # nombres de los menores de edad\n```\n\n---\n\n## Operaciones con vectores\n\nPor √∫ltimo, una acci√≥n habitual es saber [**ordenar valores**]{.hl-yellow}:\n\n-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo\n\n```{r}\nedades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)\nsort(edades)\nsort(edades, decreasing = TRUE)\n```\n\n. . .\n\n-   `order()`: devuelve el [**vector de √≠ndices**]{.hl-yellow} que tendr√≠amos que usar para tener el vector ordenado\n\n```{r}\norder(x)\nx[order(x)]\n```\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares, y calcula su suma.\n\n```{r}\n#| code-fold: true\n#| eval: false\n# Dos formas\nx <- c(1, 3, 5, 7, 9)\nx <- seq(1, 9, by = 2)\n\nsum(x)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Obt√©n los elementos de `x` mayores que 4. Calcula el n√∫mero de elementos de `x` mayores que 4.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx[x > 4]\nsum(x > 4)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor).\n\n```{r}\n#| code-fold: true\n#| eval: false\nz <- 1/x\nsort(z)\nz[order(z)]\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Encuentra el m√°ximo y el m√≠nimo del vector `x`\n\n```{r}\n#| code-fold: true\n#| eval: false\nmin(x)\nmax(x)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx[x > 1 & x < 7]\nall(x > 0)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\nüìù Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. Elimina del vector el segundo elemento. Tras eliminarlo determina su suma y su media\n\n```{r}\n#| code-fold: true\n#| eval: false\nx <- c(1, -5, 8, NA, 10, -3, 9)\nx[c(1, 2, 5, 6)]\ny <- x[-2]\nsum(y, na.rm = TRUE)\nmean(y, na.rm = TRUE)\n```\n:::\n\n# Primera base de datos\n\n[**¬øC√≥mo construimos una tabla? Matrices, data.frame y tibble**]{style=\"color:#444442;\"}\n\n---\n\n## Primer intento: matrices\n\nCuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una ¬´tabla¬ª que las recopile. La opci√≥n m√°s inmediata son las [**matrices**]{.hl-yellow}: concatenaci√≥n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.\n\n. . .\n\nImagina que tenemos estaturas y pesos de 4 personas. ¬øC√≥mo [**crear un dataset con las dos variables**]{.hl-yellow}? Con `cbind()` concatenamos en forma de columnas\n\n```{r}\nestaturas <- c(150, 160, 170, 180)\npesos <- c(60, 70, 80, 90)\ncbind(estaturas, pesos)\n```\n\n. . .\n\n¬†\n\n[**No profundizaremos**]{.hl-red} m√°s ya que nuestro objetivo es tener variables de misma longitud pero [**tipos diferentes**]{.hl-yellow} (pero que sepas que existen).\n\n---\n\n## Segundo intento: data.frame\n\nLas matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte\n\n```{r}\n#| code-line-numbers: \"4\"\nedades <- c(14, 24, NA)\nsoltero <- c(TRUE, NA, FALSE)\nnombres <- c(\"javi\", \"laura\", \"luc√≠a\")\ncbind(edades, soltero, nombres)\n```\n\n¬†\n\n. . .\n\nPara poder trabajar con [**variables de distinto tipo**]{.hl-yellow} haremos uso de lo que se conoce como [**data.frame**]{.hl-yellow}: unimos variables de igual longitud pero [**tipo distinto**]{.hl-purple}.\n\n```{r}\n#| code-line-numbers: \"1\"\ntabla <- data.frame(edades, soltero, nombres)\ntabla\n```\n\n---\n\n## Segundo intento: data.frame\n\n```{r}\ntabla\nclass(tabla)\n```\n\n¬†\n\n. . .\n\nDado que un `data.frame` es ya una ¬´base de datos¬ª las variables no son meros vectores matem√°ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}\n\n```{r}\nlibrary(lubridate)\ntabla <- data.frame(\"edad\" = edades, \"estado\" = soltero, \"nombre\" = nombres,\n             \"f_nacimiento\" = as_date(c(\"1989-09-10\", \"1992-04-01\", \"1980-11-27\")))\ntabla\n```\n\n---\n\n## Segundo intento: data.frame\n\n[**¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} \n\n\nPuedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`\n\n![](img/view_tabla.jpg){width=\"70%\" fig-align=\"center\"}\n\nNo se recomienda abusar del uso de la funci√≥n `View()` dado que se consume demasiada memoria RAM.\n\n---\n\n## Segundo intento: data.frame\n\nSi queremos acceder a sus elementos, el operador ser√° similar al de los vectores: ahora [**tenemos dos √≠ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)\n\n```{r}\ntabla[2, ]  # segunda fila (todas sus variables)\ntabla[, 3]  # tercera columna (de todos los individuos)\ntabla[2, 1]  # primera caracter√≠stica de la segunda persona\n```\n\n. . .\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/menu_data_frame.jpg)\n:::\n\n::: {.column width=\"65%\"}\nTambi√©n tiene ventajas de una [**¬´base¬ª de datos**]{.hl-yellow} : podemos [**acceder a las variables por su nombre**]{.hl-purple} (recomendable ya que las variables pueden cambiar de posici√≥n), poniendo el nombre de la tabla seguido del s√≠mbolo `$` (con el **tabulador**, nos aparecer√° un men√∫ de columnas a elegir)\n:::\n:::\n\n---\n\n## Segundo intento: data.frame\n\n-   `names()`: nos muestra los nombres de las variables\n\n```{r}\nnames(tabla)\n```\n\n¬†\n\n. . .\n\n-   `dim()`: nos muestra las dimensiones (tambi√©n `nrow()` y `ncol()`)\n\n```{r}\ndim(tabla)\n```\n\n¬†\n\n. . .\n\n-   Podemos acceder a las variables por su nombre\n\n```{r}\ntabla[c(1, 3), \"nombre\"]\n```\n\n---\n\n## Intento final: tibble\n\nLas tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}\n\nLa principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC\n\n```{r}\n#| error: true\ndata.frame(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n           \"IMC\" = peso / (estatura^2))\n```\n\n\nDe ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})\n\n```{r}\nlibrary(tibble)\ntibble(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n       \"IMC\" = peso / (estatura^2))\n```\n\nUn data.frame puede ser tranformado en un tibble por medio del comando `as_tibble()`.\n\n---\n\n## Intento final: tibble\n\n```{r}\ntabla <- tibble(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n                \"IMC\" = peso / (estatura^2))\ntabla\n```\n\nLas tablas en formato `tibble` nos permitir√° una [**gesti√≥n m√°s √°gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:\n\n. . .\n\n-   [**Metainformaci√≥n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya autom√°ticamente el n√∫mero de filas y columnas, y el tipo de cada variable\n\n. . .\n\n-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)\n\n---\n\n## Intento final: tibble\n\n-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning\n\n```{r}\n#| warning: true\ntabla$invent\n```\n\n. . .\n\n-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`\n\n```{r}\ntribble(~colA, ~colB,\n        \"a\",   1,\n        \"b\",   2)\n```\n\n. . .\n\n::: callout-tip\nEl paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de p√°ginas web y documentos sencillos\n:::\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Carga del paquete `{datasets}` el conjunto de datos `airquality` (contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a tibble (busca en la documentaci√≥n del paquete en <https://tibble.tidyverse.org/index.html>).\n\n```{r}\n#| code-fold: true\n#| eval: false\nlibrary(tibble)\nclass(datasets::airquality)\nairquality_tb <- as_tibble(datasets::airquality)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Una vez convertido a `tibble` obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?\n\n```{r}\n#| code-fold: true\n#| eval: false\nnames(airquality_tb)\nncol(airquality_tb)\nnrow(airquality_tb)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Filtra solo los datos del mes de agosto.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month == 8, ]\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Selecciona aquellos datos que no sean ni de julio ni de agosto.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month %in% c(7, 8), ]\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Modifica el siguiente c√≥digo para quedarte solo con las variable de ozono y temperatura.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[, c(\"Ozone\", \"Temp\")]\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\nüìù Selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month == 8, c(\"Temp\", \"Wind\")]\nnames(airquality_tb) <- c(\"ozono\", \"rad_solar\", \"viento\", \"temp\", \"mes\", \"dia\") \n```\n:::\n\n# R base vs Tidyverse\n\n[**Spoiler: un multiverso de datos limpios**]{style=\"color:#444442;\"}\n\n---\n\n## R base vs Tidyverse\n\nSi conoces alg√∫n otro lenguaje de programaci√≥n (o tienes gente cercana que programa) te extra√±ar√° que a√∫n no hayamos hablado de conceptos habituales como\n\n-   [**Bucles for**]{.hl-yellow}: repetir un c√≥digo un n√∫mero fijo de iteraciones.\n\n-   [**Bucles while**]{.hl-yellow}: repetir un c√≥digo hasta que se cumpla una condici√≥n\n\n-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el c√≥digo en funci√≥n del valor de las variables.\n\n¬†\n\n. . .\n\nY aunque conocer dichas estructuras puede ser en alg√∫n momento interesante, en la [**mayor√≠a de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles) [‚Üí en lugar de trabajar con lo que se conoce como R Base vamos a vertebrar el curso en torno a [**Tidyverse**]{.hl-yellow}]{.fragment .fade-in}\n\n---\n\n## ¬øQu√© es tidyverse?\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"50%\"}\n![](img/flow_tidyverse.jpg)\n:::\n:::\n\n`{tidyverse}` es un [**¬´universo¬ª de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicogr√°ficamente sencillo de entender, basado en la idea de que [**nuestros datos est√°n limpios y ordenados (tidy)**]{.hl-purple}\n\n---\n\n## ¬øQu√© es tidyverse?\n\n::: columns\n::: {.column width=\"45%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"55%\"}\n-   `{tibble}`: optimizando data.frame\n-   `{tidyr}`: limpieza de datos\n-   `{readr}`: carga datos rectangulares (.txt, .csv)\n-   `{dplyr}`: gram√°tica para depurar\n-   `{stringr}`: manejo de textos\n-   `{ggplot2}`: visualizaci√≥n de datos\n-   `{tidymodels}`: modelizaci√≥n/predicci√≥n\n:::\n:::\n\nTambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para variables cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.\n\n---\n\n\n## ¬øQu√© es tidyverse?\n\n::: columns\n::: {.column width=\"45%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"55%\"}\n-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}\n-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}\n-   `{readr}`: [**carga datos**]{.hl-yellow} rectangulares (.txt, .csv)\n-   `{dplyr}`: [**gram√°tica para depurar**]{.hl-yellow}\n-   `{stringr}`: [**manejo de textos**]{.hl-purple}\n-   `{ggplot2}`: [**visualizaci√≥n de datos**]{.hl-purple}\n-   `{tidymodels}`: [**modelizaci√≥n/predicci√≥n**]{.hl-green}\n:::\n:::\n\nTambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para variables cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.\n\n---\n\n## Filosof√≠a base: tidy data\n\n> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)\n\n<div style=\"font-size:120px; text-align: center; color:#F8DF58;\"><b>TIDY</b><span style=\"color:#CAB0EE;\"><b>VERSE</b></span></div>\n\nEl [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato de los datos para:\n\n::: incremental\n\n* [**sistematizar**]{.hl-green} la depuraci√≥n\n* hacer m√°s [**sencillo**]{.hl-green} su manipulaci√≥n.\n* c√≥digo [**legible**]{.hl-green}\n\n:::\n \n---\n\n## Reglas del tidy data\n\nLo primero por tanto ser√° entender qu√© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos est√°n estandarizados.\n\n\n:::: columns\n::: {.column width=\"50%\"}\n\n::: {.fragment .fade-in}\n1. Cada [**variable**]{.hl-yellow} en una [**√∫nica columna**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n2. Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n3. Cada [**celda**]{.hl-yellow} con un [**√∫nico valor**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n4. Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n5. Si queremos cruzar [**m√∫ltiples tablas**]{.hl-yellow} debemos tener una [**columna en com√∫n**]{.hl-purple} (llave de cruce).\n:::\n:::\n::: {.column width=\"50%\"}\n![](img/tidy_def.jpg){width=\"160%\"}\n:::\n::::\n\n---\n\n## Tuber√≠a (pipe)\n\nEn `{tidyverse}` ser√° clave el [**operador pipe (tuber√≠a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): ser√° una [**tuber√≠a que recorre los datos**]{.hl-yellow} y los transforma.\n\n. . .\n\n:::: columns\n::: {.column width=\"50%\"}\nEn R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, ser√≠a\n\n```{r}\n#| eval: false\nthird(second(first(datos)))\n```\n:::\n\n::: {.column width=\"50%\"}\n\nEn `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones\n\n```{r}\n#| eval: false\ndatos |> first() |> second() |> third()\n```\n\n:::\n::::\n\n&nbsp;\n\n. . .\n\n::: callout-caution\n## Apunte importante\n\nDesde la versi√≥n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo**  disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que depend√≠a del paquete `{magrittr}` (bastante problem√°tico).\n:::\n\n---\n\n## Tuber√≠a (pipe)\n\nLa principal ventaja es que el [**c√≥digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas c√≥digo.\n\n&nbsp;\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  limpio(...) |>\n  filtro(...) |>\n  selecciono(...) |>\n  ordeno(...) |>\n  modifico(...) |>\n  renombro(...) |>\n  agrupo(...) |>\n  cuento(...) |>\n  resumo(...) |>\n  pinto(...)\n```\n:::\n\n::: {.column width=\"50%\"}\n\n<center><img src=\"img/logo_pipe.png\" width=\"360px\"/></center>\n:::\n::::\n  \n\n---\n\n## Datos SUCIOS: messy data\n\n¬øPero qu√© aspecto tienen los [**datos no tidy**]{.hl-yellow}? \n\nVamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).\n\n¬†\n\n. . .\n\n```{r}\nlibrary(tidyr)\ntable4a\n```\n\n¬†\n\n. . .\n\n[**¬øQu√© puede estar fallando?**]{.hl-red}\n\n---\n\n## Pivotar: pivot_longer()\n\n:::: columns\n::: {.column width=\"40%\"}\n```{r}\ntable4a\n```\n:::\n\n::: {.column width=\"60%\"}\n\n‚ùé  Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) ‚Üí las columnas `1999` y `2000` en realidad deber√≠an ser en s√≠ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.\n:::\n::::\n\n. . .\n\nIncluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el a√±o y otra que guarde el valor de la variable de inter√©s en cada uno de esos a√±os. Y lo haremos con la funci√≥n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:\n\n```{r}\ntable4a |> \n  pivot_longer(cols = c(\"1999\", \"2000\"), names_to = \"year\", values_to = \"cases\")\n```\n\n\n---\n\n## Pivotar: pivot_longer()\n\n:::: columns\n\n::: {.column width=\"50%\"}\n\n```{r}\ntable4a |> \n  pivot_longer(cols = c(\"1999\", \"2000\"),\n               names_to = \"year\",\n               values_to = \"cases\")\n```\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/table4a.jpg)\n\n:::\n::::\n\n&nbsp;\n\n* `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}\n* `names_to`: nombre de la nueva variable a la que mandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).\n* `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos otro ejemplo con la tabla `table2`\n\n&nbsp;\n\n```{r}\ntable2\n```\n\n\n&nbsp;\n\n[**¬øQu√© puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Pivotar: pivot_wider()\n\n:::: columns\n::: {.column width=\"60%\"}\n```{r}\n#| echo: false\ntable2\n```\n:::\n\n::: {.column width=\"40%\"}\n\n‚ùé Cada [**observaci√≥n est√° dividido en dos filas**]{.hl-red} ‚Üí los [**registros con el mismo a√±o deber√≠an ser el mismo**]{.hl-yellow}\n\n:::\n::::\n\n. . .\n\nLo que haremos ser√° lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}\n\n```{r}\ntable2 |>  pivot_wider(names_from = type, values_from = count)\n```\n\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos otro ejemplo con la tabla `table3`\n\n&nbsp;\n\n```{r}\ntable3\n```\n\n\n&nbsp;\n\n[**¬øQu√© puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Separar: separate()\n\n:::: columns\n::: {.column width=\"60%\"}\n```{r}\ntable3\n```\n:::\n\n::: {.column width=\"40%\"}\n\n‚ùé Cada [**celda contiene varios valores**]{.hl-red} \n\n:::\n::::\n\n. . .\n\nLo que haremos ser√° hacer uso de la funci√≥n `separate()` para mandar a [**separar cada valor**]{.hl-yellow} a una columna diferente.\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"))\n```\n\n---\n\n## Separar: separate()\n\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"))\n```\n\nF√≠jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deber√≠an ser variables num√©ricas. Para ello podemos a√±adir el argumento opcional `convert = TRUE`\n\n. . .\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"), convert = TRUE)\n```\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos el √∫ltimo ejemplo con la tabla `table5`\n\n&nbsp;\n\n```{r}\ntable5\n```\n\n\n&nbsp;\n\n[**¬øQu√© puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Unir unite()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\ntable5\n```\n:::\n\n::: {.column width=\"50%\"}\n\n‚ùé Tenemos [**mismos valores divididos en dos columnas**]{.hl-red} \n\n:::\n::::\n\n. . .\n\nUsaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y a√±o en una misma columna\n\n```{r}\ntable5 |> unite(col = year_completo, century, year, sep = \"\")\n```\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\ntable4b |>\n  pivot_longer(cols = \"1999\":\"2000\", names_to = \"year\",\n               values_to = \"cases\")\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\nrelig_income |>\n  pivot_longer(cols = \"<$10k\":\"Don't know/refused\",\n               names_to = \"income\",\n               values_to = \"people\")\n```\n\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\nbillboard |>\n  pivot_longer(cols = \"wk1\":\"wk76\",\n               names_to = \"week\",\n               names_prefix = \"wk\",\n               values_to = \"position\",\n               values_drop_na = TRUE)\n```\n\n:::\n\n# Introducci√≥n a Tidyverse\n\n[**Con los datos limpios, podemos trabajarlos**]{style=\"color:#444442;\"}\n\n---\n\n## Preprocesamiento: dplyr\n\nDentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuraci√≥n**]{.hl-yellow} de datos de datos.\n\n:::: columns\n::: {.column width=\"65%\"}\n![](img/dplyr.png)\n:::\n\n::: {.column width=\"35%\"}\n```{r}\n#| eval: false\ndatos |>\n  limpio(...) |>\n  filtro(...) |>\n  selecciono(...) |>\n  ordeno(...) |>\n  modifico(...) |>\n  renombro(...) |>\n  agrupo(...) |>\n  cuento(...) |>\n  resumo(...) |>\n  pinto(...)\n```\n:::\n::::\n\n---\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\nUna de las operaciones m√°s comunes es [**filtrar registros**]{.hl-yellow} en base a alguna condici√≥n l√≥gica: con `filter()` se seleccionar√°n solo individuos que cumplan ciertas condiciones.\n\n::: incremental\n\n* `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-purple} que\n* `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-purple} que\n* `>=`, `<=`: [**mayor o igual**]{.hl-purple} o [**menor o igual**]{.hl-purple} que\n* `%in%`: valores [**pertenencen**]{.hl-purple} a un listado de opciones\n* `between(variable, val1, val2)`: si los valores (normalmente continuos) [**caen dentro de un rango**]{.hl-purple} de valores\n\n:::\n\n---\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| echo: false\n#| include: false\nlibrary(tidyverse)\ndata(\"starwars\")\n```\n\n```{r}\n#| eval: false\nstarwars |>  dplyr::filter(eye_color == \"brown\")\n```\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(eye_color != \"brown\")\n```\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(eye_color %in% c(\"blue\", \"brown\"))\n```\n\n\n::: callout-tip\n\n## Importante\nRecuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores l√≥gicos**]{.hl-green}.\n\n:::\n\n---\n\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(between(height, 120, 160))\n```\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |>\n   filter(eye_color == \"brown\" & species != \"Human\")\n```\n\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan m√°s de 60 a√±os**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |>\n  filter((eye_color == \"brown\" & species != \"Human\") | birth_year > 60)\n```\n\n  \n---\n\n## Eliminar ausentes: drop_na()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  retirar_ausentes(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  drop_na(var1, var2, ...)\n```\n:::\n::::\n\nHay un filtro especial que es el de [**retirar los ausentes**]{.hl-yellow}, para lo cual podemos usar `filter(is.na(variable))` o directamente `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquiera de las variables.\n\n. . .\n\n&nbsp;\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> drop_na(mass, height)\n```\n\n```{r}\n#| echo: false\nstarwars |>\n  drop_na(mass, height, sex) |> \n  select(name, mass, height, hair_color) |> \n  slice(1:7)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> drop_na()\n```\n\n```{r}\n#| echo: false\nstarwars |>\n  drop_na() |> \n  select(name, mass, height, hair_color) |> \n  slice(1:7)\n```\n\n:::\n::::\n\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido\n \n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(species == \"Droid\" | is.na(species))\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Selecciona del conjunto de starwars solo los personajes cuyo peso est√© entre 65 y 90 kg.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> filter(between(mass, 65, 90))\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na() |> \n  filter(species == \"Human\" & homeworld == \"Tatooine\")\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter((species != \"Human\" & sex == \"male\" &\n            between(height, 120, 170)) |\n           eye_color %in% c(\"brown\", \"red\"))\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù  Busca informaci√≥n en la ayuda de la funci√≥n `str_detect()` del paquete `{stringr}` (cargado en `{tidyverse}`). Consejo: prueba antes las funciones que vayas a usar con alg√∫n vector de prueba para poder comprobar su funcionamiento. Tras saber lo que hace, filtra solo aquellos personajes con apellido `Skywalker`\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> filter(str_detect(name, \"Skywalker\"))\n```\n\n:::\n\n---\n\n## Rebanadas de datos: slice()\n\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> rebanadas(posiciones)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(posiciones)\n```\n:::\n::::\n\nNormalmente filtraremos condici√≥n pero a veces nos puede interesar [**filtrar por posici√≥n**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de √≠ndices**]{.hl-yellow}\n\n. . .\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(1)\n```\n\n```{r}\n#| echo: false\nstarwars |> slice(1) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(7:9)\n```\n\n```{r}\n#| echo: false\nstarwars |> slice(7:9) |> select(name:hair_color)\n```\n:::\n::::\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> slice(c(2, 7, 10, 31))\n```\n\n\n```{r}\n#| echo: false\nstarwars |> slice(c(2, 7, 10, 31)) |> select(name:sex)\n```\n\n---\n\n## Rebanadas de datos: slice()\n\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> rebanadas(posiciones)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(posiciones)\n```\n:::\n::::\n\nDisponemos de opciones por defecto: con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_head(n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_head(n = 2) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%}\n```{r}\n#| eval: false\nstarwars |> slice_tail(n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_tail(n = 2) |> select(name:hair_color)\n```\n:::\n::::\n\n. . .\n\nCon `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`).\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_min(mass, n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_max(height, n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)\n```\n:::\n::::\n\n\n---\n\n\n## Reordenar filas: arrange()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> ordenar(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> arrange(var1, var2, ...)\n```\n:::\n::::\n\nTambi√©n podemos [**ordenar filas**]{.hl-yellow} en funci√≥n de alguna variable con `arrange()`\n\n```{r}\n#| eval: false\nstarwars |> arrange(mass)\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) \n```\n\n. . .\n\nPor [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`\n\n:::: columns\n::: {.column width=\"50%\"}\n\n```{r}\n#| eval: false\nstarwars |> arrange(desc(height))\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) \n```\n:::\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> arrange(mass, desc(height))\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) \n```\n:::\n::::\n\n---\n\n## Eliminar duplicados: distinct()\n\nMuchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`. \n\n```{r}\nstarwars |> distinct(sex)\n```\n\n. . .\n\nPara mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.\n\n```{r}\n#| eval: false\nstarwars |> distinct(sex, .keep_all = TRUE)\n```\n\n```{r}\n#| echo: false\nstarwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)\n```\n\n\n---\n\n## A√±adir filas: bind_rows()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ntibble1 |> encuadernar_filas(tibble2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ntibble1 |> bind_rows(tibble2)\n```\n:::\n::::\n\nPor √∫ltimo, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)\n\n\n```{r}\ndatos <-\n  tibble(\"nombre\" = c(\"javi\", \"laura\"), \"edad\" = c(33, 50))\ndatos\n```\n\n\n. . .\n\n```{r}\ndatos |> bind_rows(tibble(\"nombre\" = c(\"carlos\", NA), \"cp\" = c(28045, 28019)))\n```\n\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Selecciona solo los personajes que sean humanos y de ojos marrones, para despu√©s ordernarlos en altura descendente y peso ascendente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(eye_color == \"brown\" & species == \"Human\") |> \n  arrange(height, desc(mass))\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n\nüìù Extrae 3 registros aleatoriamente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_sample(n = 3)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n\nüìù Extrae el 10% de los registros aleatoriamente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_sample(prop = 0.1)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (m√°s pesados, m√°s probable)\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(mass) |> \n  slice_sample(n = 10, weight_by = mass)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Selecciona los 3 personajes m√°s mayores.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_max(birth_year, n = 3)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\nüìù Para saber que valores √∫nicos hay en el color de pelo, elimina duplicados de la variable `hair_color`, eliminando antes los ausentes de dicha variable.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(hair_color) |> \n  distinct(hair_color)\n```\n\n### [**Ejercicio 7**]{.hl-yellow}\n\nüìù De los personajes que son humanos y miden m√°s de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 m√°s altos, y orden de mayor a menor peso. Devuelve la tabla.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(species == \"Human\" & height > 160) |> \n  distinct(eye_color, .keep_all = TRUE) |> \n  drop_na(mass) |> \n  slice_max(height, n = 3) |> \n  arrange(desc(mass))\n```\n\n\n:::\n\n---\n\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\nLa opci√≥n m√°s sencilla para [**seleccionar variables por nombre**]{.hl-yellow} es  `select()`, dando como argumentos los nombres de columnas sin comillas.\n\n```{r}\nstarwars %>% select(name, hair_color)\n```\n\n---\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nLa funci√≥n `select()` nos permite seleccionar varias variables a la vez [**concatenando sus nombres como si fuesen √≠ndices**]{.hl-yellow}\n\n```{r}\n#| eval: false\nstarwars |> select(name:eye_color) \n```\n\n```{r}\n#| echo: false\nstarwars |> select(name:eye_color) |> slice(1:4)\n```\n\n. . .\n\nY podemos [**deseleccionar columnas**]{.hl-yellow} con `-`\n\n```{r}\n#| eval: false\nstarwars |>  select(-mass, -(eye_color:starships))\n```\n\n```{r}\n#| echo: false\nstarwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)\n```\n\n\n---\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\nTenemos adem√°s [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...\n\n```{r}\n#| eval: false\nstarwars |> select(mass, homeworld, everything())\n```\n\n```{r}\n#| echo: false\nstarwars |> select(mass, homeworld, everything()) |> slice(1:4)\n```\n\n. . .\n\n...y `last_col()` para referirnos a [**la √∫ltima columna**]{.hl-purple}.\n\n```{r}\n#| eval: false\nstarwars |> select(name:mass, homeworld, last_col())\n```\n\n```{r}\n#| echo: false\nstarwars |> select(name:mass, homeworld, last_col()) |> slice(1:4)\n```\n\n---\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nPodemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresi√≥n regular**]{.hl-purple} (`matches()`).\n\n\n```{r}\n# variables cuyo nombre acaba en \"color\" y contengan sexo o g√©nero\nstarwars |> select(ends_with(\"color\"), matches(\"sex|gender\"))\n```\n\n\n---\n\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nIncluso podemos [**seleccionar por rango num√©rico**]{.hl-yellow} si tenemos variables con un prefijo y n√∫meros.\n\n```{r}\ndatos <-\n  tibble(\"semana1\" = c(115, 141, 232), \"semana2\" = c(7, NA, 17),\n         \"semana3\" = c(95, 162, NA), \"semana4\" = c(11, 19, 15),\n         \"semana5\" = c(NA, 262, 190), \"semana6\" = c(21, 15, 23))\n```\n\n\n. . .\n\nCon `num_range()` podemos seleccionar con un prefijo y una secuencia num√©rica.\n\n```{r}\ndatos |> select(num_range(\"semana\", 1:4))\n```\n\n---\n\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nPor √∫ltimo, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una funci√≥n que devuelva un valor l√≥gico de tipo de dato.\n\n```{r}\n# Solo columnas num√©ricas o de texto\nstarwars |> select(where(is.numeric) | where(is.character))\n```\n\n---\n\n\n## Mover columnas: relocate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  recolocar(var1, despues_de = var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  relocate(var1, .after = var2)\n```\n:::\n::::\n\nPara facilitar la [**recolocaci√≥n de variables**]{.hl-yellow} tenemos una funci√≥n para ello, `relocate()`, indic√°ndole en `.after` o `.before` [**detr√°s**]{.hl-purple} o [**delante**]{.hl-purple} de qu√© columnas queremos moverlas.\n\n```{r}\nstarwars |> relocate(species, .before = name)\n```\n\n\n\n---\n\n## Renombrar: rename()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> renombrar(nuevo = antiguo)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> rename(nuevo = antiguo)\n```\n:::\n::::\n\nA veces tambi√©n podemos querer [**modificar la ¬´metainformaci√≥n¬ª**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.\n\n```{r}\nstarwars |> rename(nombre = name, altura = height, peso = mass)\n```\n\n---\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\nEn muchas ocasiones queremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.\n\n```{r}\nstarwars |> mutate(height_m = height / 100)\n```\n\n---\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\nAdem√°s con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}\n\n```{r}\nstarwars |> \n  mutate(height_m = height / 100,\n         IMC = mass / (height_m^2), .before = name)\n```\n\n---\n\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\n::: callout-important\n## Importante...\n\nCuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la funci√≥n que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolver√° una constante**]{.hl-red}\n:::\n\n. . .\n\n```{r}\nstarwars |> \n  mutate(constante = mean(mass, na.rm = TRUE), .before = name)\n```\n\n\n---\n\n## Recategorizar: if_else()\n\nTambi√©n podemos combinar `mutate()` con la expresi√≥n de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condici√≥n**]{.hl-purple}, hace una cosa, en caso contrario otra.\n\n```{r}\nstarwars |> \n  mutate(human = if_else(species == \"Human\", \"Human\", \"Not Human\"),\n         .after = name) |> \n  select(name:mass)\n```\n\n\n---\n\n## Recategorizar: case_when()\n\nPara [**recategorizaciones m√°s complejas**]{.hl-yellow} tenemos  `case_when()`, por ejemplo, para crear una categor√≠a de los personajes en funci√≥n de su altura.\n \n```{r}\nstarwars |> \n  drop_na(height) |> \n  mutate(altura = case_when(height < 120 ~ \"enanos\",\n                            height < 160 ~ \"bajito\",\n                            height < 180 ~ \"normal\",\n                            height < 200 ~ \"alto\",\n                            TRUE ~ \"gigante\"), .before = name)\n```\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Selecciona solo las variables nombre, altura y as√≠ como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.\n \n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(name, height, contains(\"color\")) |> \n  drop_na(height)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(name, height, contains(\"color\")) |> \n  drop_na(height) |> \n  rename(nombre = name, altura = height,\n         color_pelo = eye_color, color_piel = skin_color,\n         color_pelo = hair_color)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detr√°s de la variable de nombres.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  select(name, height, contains(\"color\")) |> \n  drop_na(height) |> \n  rename(nombre = name, altura = height,\n         color_pelo = eye_color, color_piel = skin_color,\n         color_pelo = hair_color) |> \n  relocate(color_pelo, .after = nombre)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Con los datos originales, comprueba cu√°ntas modalidades √∫nicas hay en la variable de color de pelo.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  distinct(hair_color) |> \n  nrow()\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Del dataset original, selecciona solo las variables num√©ricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(where(is.numeric) | where(is.character)) |> \n  mutate(under_18 = birth_year < 18)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\nüìù Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  mutate(auburn = str_detect(hair_color, \"auburn\"))\n```\n\n### [**Ejercicio 7**]{.hl-yellow}\n\nüìù Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  mutate(IMC = mass / ((height/100)^2),\n         IMC_recat = case_when(species != \"Human\" ~ NA,\n                               IMC < 18 ~ \"delgadez\",\n                               IMC < 30 ~ \"normal\",\n                               TRUE ~ \"sobrepeso\"),\n         .after = name)\n```\n\n:::\n\n---\n\n## Contar: count()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> contar(var1, var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> count(var1, var2)\n```\n:::\n::::\n\nHasta ahora solo hemos transformado o consultado los datos pero no hemos generado estad√≠sticas. Empecemos por lo sencillo: [**¬øc√≥mo contar (frecuencias)?**]{.hl-yellow}\n\n. . .\n\nCuando lo usamos en solitario `count()` nos devolver√° simplemente el n√∫mero de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**n√∫mero de elementos de cada modalidad**]{.hl-purple}. \n\n```{r}\nstarwars |> count(sex)\n```\n\n---\n\n## Contar: count()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> contar(var1, var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> count(var1, var2)\n```\n:::\n::::\n\nAdem√°s si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolver√° el [**conteo ordenado**]{.hl-purple} (m√°s frecuentes primero).\n\n```{r}\nstarwars |> count(sex, gender, sort = TRUE)\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\nUna de las [**funciones m√°s potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitir√° [**agrupar nuestros registros**]{.hl-yellow} previamente\n\n```{r}\nstarwars |> \n  group_by(sex) |>\n  count() |>\n  ungroup()\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\nCuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificar√° las acciones futuras: las [**operaciones se aplicar√°n a cada subtabla por separado**]{.hl-purple}\n\n. . .\n\nPor ejemplo, imaginemos que queremos extraer el personaje m√°s alto con `slice_max()`.\n\n```{r}\nstarwars |> slice_max(height)\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\n¬øY si queremos [**extraer el personaje m√°s alto pero...de cada uno de los sexos**]{.hl-yellow}?\n\n. . .\n\n```{r}\nstarwars |>\n  group_by(sex) |> \n  slice_max(height) |> \n  ungroup()\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\n:::: columns\n::: {.column width=\"50%\"}\n![](img/tidydatatutor_1.jpg)\n:::\n\n::: {.column width=\"50%\"}\n![](img/tidydatatutor_2.jpg)\n:::\n::::\n\nLa web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)\n\n---\n\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |>\n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |>\n  ungroup()\n```\n:::\n::::\n\n::: callout-important\n## Importante\nRecuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada\n:::\n\n. . .\n\nEn la nueva versi√≥n de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`\n\n```{r}\n#| eval: false\nstarwars |> slice_max(height, by = sex)\n```\n\n.\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> slice_max(height, by = sex) |> select(name:eye_color)\n```\n\n---\n\n## Fila-a-fila: rowwise()\n\nUna opci√≥n muy √∫til usada antes de una operaci√≥n tambi√©n es `rowwise()`: toda [**operaci√≥n que venga despu√©s se aplicar√° en cada fila por separado**]{.hl-yellow}. Por ejemplo, vamos a definir un conjunto dummy de notas.\n\n```{r}\nnotas <- tibble(\"mates\" = c(7.5, 8, 9.1, 3),\n                \"lengua\" = c(8, 6, 6.5, 9.2))\n```\n\n. . .\n\nSi aplicamos la media directamente el valor ser√° id√©ntico ya que nos ha hecho la media global, pero nos gustar√≠a sacar una [**media por registro**]{.hl-yellow}. Para eso usaremos `rowwise()`\n\n```{r}\nnotas |> \n  rowwise() |> \n  mutate(media_curso = mean(c(mates, lengua)))\n```\n\n\n---\n\n## Resumir: summarise()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> summarise()\n```\n:::\n::::\n\nPor √∫ltimo tenemos `summarise()`, que nos permitir√° sacar res√∫menes estad√≠sticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.\n\n```{r}\nstarwars |> \n  drop_na(height) |> \n  summarise(media_altura = mean(height))\n```\n\n. . .\n\n::: callout-warning\n## Cuidado\nF√≠jate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que est√© indicado.\n:::\n\n---\n\n## Resumir: summarise()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> summarise()\n```\n:::\n::::\n\nSi adem√°s esto lo [**combinamos con la agrupaci√≥n**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas l√≠neas de c√≥digo puedes obtener [**estad√≠sticas desagregadas**]{.hl-purple}\n\n```{r}\nstarwars |> \n  drop_na(sex, height, mass) |> \n  summarise(media_altura = mean(height),\n            media_peso = mean(mass),\n            .by = sex)\n```\n\n---\n\n## Resumir: reframe()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> reframe()\n```\n:::\n::::\n\nEn el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos m√°s de un valor por variable**]{.hl-yellow}.\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: true\nstarwars |>\n  drop_na(mass) |>\n  summarise(quantile(mass))\n```\n:::\n::: {.column width=\"50%\"}\n```{r}\n#| eval: true\nstarwars |>\n  drop_na(mass) |>\n  reframe(quantile(mass))\n```\n:::\n::::\n\n---\n\n## Selectores: across()\n\nUn truco es [**hacer uso de selectores**]{.hl-yellow} `across` y `where`. El primero nos permite [**actuar sobre varias columnas por  nombre**]{.hl-purple} (con `mutate` o `summarise`)\n\n```{r}\nstarwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)\n```\n\n. . .\n\nEl segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.\n\n```{r}\nstarwars |> \n  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))\n```\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Calcula cu√°ntos personajes hay de cada especie, ordenados de m√°s a menor frecuencia.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> count(species, sort = TRUE)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Tras eliminar ausentes en las variables de peso y estatura, a√±ade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(mass, height) |> \n  mutate(IMC = mass / ((height/100)^2)) |> \n  summarise(IMC_medio = mean(IMC), .by = sex)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Obt√©n el personaje m√°s joven por cada sexo.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  slice_min(birth_year, by = sex)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Obt√©n la edad del personaje m√°s joven y m√°s viejo de cada sexo.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(birth_year) |>\n  summarise(min(birth_year), max(birth_year), .by = sex)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Determina la cantidad de personajes en cada d√©cada (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  count(birth_decade = round(birth_year, -1))\n```\n\n:::\n\n\n# Caso real: datos de encuestas\n\n[**Pongamos en pr√°ctica lo aprendido...**]{style=\"color:#444442;\"}\n\n---\n\n## Caso real: datos de encuestas\n\nEl paquete `{readr}` (ya en `{tidyverse}`) nos permite realizar una carga m√°s √°gil y m√°s inteligente que el `read.csv()` de base (lo importa a un `tibble` e interpreta bien el tipo de cada variable, incluso fechas)\n\n```{r}\n#| echo: false\n#| eval: false\nencuestas <- read_csv(file = \"./datos/historical_surveys.csv\")\nencuestas <-\n  encuestas |>\n  mutate(cod_elec = \"02\") |> \n  select(type_survey, date_elec, id_pollster, pollster,\n         media, field_date_from, field_date_to, exit_poll,\n         size, turnout, abbrev_candidacies, est_vote) |> \n  pivot_wider(names_from = \"abbrev_candidacies\",\n              values_from = \"est_vote\")\nwrite_csv(encuestas, file = \"./datos/historical_surveys.csv\")\n```\n\n```{r}\nencuestas <- read_csv(file = \"./datos/historical_surveys.csv\")\nencuestas\n```\n\n---\n\n## Caso real: datos de encuestas\n\nLo [**primero que debes hacer**]{.hl-yellow} es visualizar con `View()` la tabla para entenderla\n\n. . .\n\n* [**Primera tarea**]{.hl-purple}: crea una variable llamada `id_survey` que nos permita identificar a cada encuesta. ¬øQu√© podr√≠amos concatenar?\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |> \n  # Creamos un id con type_survey-date_elec-id_pollster\n  # con .before la ponemos delante de everything(), de todo (1¬™ col)\n  mutate(id_survey = glue(\"{type_survey}-{date_elec}-{id_pollster}\"),\n         .before = everything())\n```\n\n---\n\n## Caso real: datos de encuestas\n\n* [**Segunda tarea**]{.hl-purple}: usando la variable `id_survey` creada elimina duplicados.\n\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |>\n  # Eliminamos duplicados por id_survey, pero mantenemos todas las\n  # columnas con .keep_all = TRUE\n  distinct(id_survey, .keep_all = TRUE)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n* [**Tercera tarea**]{.hl-purple}: tenemos una variable `media` que representa el medio en el que se public√≥ o encargo la encuesta. Elimina dicha variable, as√≠ como el tipo de encuesta y el id de la encuestadora\n\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |> \n  # Eliminamos las columnas pedidas con un -\n  # las concateno para usar solo un - para todas\n  select(-c(type_survey, id_pollster, media))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Cuarta tarea**]{.hl-purple}: qu√©date solo con las encuestas cuyo tama√±o muestral conozcamos y que no sean encuestas a pie de urna. Elimina esta √∫ltima variable.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # eliminar ausentes\n  drop_na(size) |> \n  # Filtramos encuestas (registros) a pie de urna (aquellas que exit_poll == FALSE)\n  dplyr::filter(!exit_poll) |> \n  # Quitamos la variable pie de urna\n  select(-exit_poll)\n```\n\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Quinta tarea**]{.hl-purple}: convierte el dataset en tidydata. ¬øQu√© falla? ¬øC√≥mo arreglarlo? Reminder: no queremos ausentes.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Convertimos a tidydata\n  pivot_longer(cols = -(id_survey:turnout),\n               names_to = \"partido\",\n               values_to = \"est_voto\",\n               values_drop_na = TRUE)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Sexta tarea**]{.hl-purple}: calcula el n√∫mero de d√≠as que la encuesta ha hecho trabajo de campo, y coloca dicha columna tras el nombre de la encuestadora. Tras ello elimina aquellas encuestas que tengan 0 d√≠as de trabajo de campo.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Calculamos los d√≠as de campo como la diferencia de fechas \n  # con as.numeric() convertimos la dif. de fechas a un n√∫mero\n  mutate(n_dias_campo = as.numeric(field_date_to - field_date_from),\n         .after = pollster) |> \n  # Solo aquellas cuyo trabajo de campo haya durado 1 d√≠a o m√°s\n  dplyr::filter(n_dias_campo > 0)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**S√©ptima tarea**]{.hl-purple}: calcula el n√∫mero de d√≠as que faltan hasta las elecciones desde que la encuesta cerro el trabajo de campo y coloca dicha variable tras `n_dias_campo`. Tras ello elimina las fechas de inicio y fin de trabajo de campo de la manera m√°s eficiente posible\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Calculamos los d√≠as que faltan a las elecciones\n  # con as.numeric() convertimos la dif. de fechas a un n√∫mero\n  mutate(n_dias_elec = as.numeric(date_elec - field_date_to),\n         .after = n_dias_campo) |> \n  # Eliminamos ya las fechas de campo que no necesitamos\n  select(-contains(\"field\"))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Octava tarea**]{.hl-purple}: elimina encuestas que se hayan cerrado dentro de la ventana temporal en la que est√° prohibido la publicaci√≥n de encuestas (no se deber√≠an usar para predecir ya que ¬´no se conocen¬ª)\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |>\n  # Solo con encuestas antes del baneo electoral\n  dplyr::filter(n_dias_elec > 15)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Novena tarea**]{.hl-purple}: obt√©n, por cada elecci√≥n, la media de las encuestas de cada partido\n\n```{r}\n#| code-fold: true\nencuestas |>\n  # Resumen: media de voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\"))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**D√©cima tarea**]{.hl-purple}: realiza lo mismo que la tarea anterior pero solo para las encuestas de los 60 d√≠as previos a las elecciones. Ordena la salida de reciente a antiguo\n\n```{r}\n#| code-fold: true\nencuestas |>\n  # Filtramos ventana de 60 d√≠as\n  dplyr::filter(n_dias_elec <= 60) |>\n  # Media de est_voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\")) |>\n  # Ordenar de mayor a menor\n  arrange(desc(date_elec))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Und√©cima tarea**]{.hl-purple}: del dataset generado en el anterior ejercicio, obt√©n el primer y el segundo con mayor estimaci√≥n de voto (en promedio)\n\n```{r}\n#| code-fold: true\nencuestas |> \n  # Filtramos ventana de 60 d√≠as\n  dplyr::filter(n_dias_elec <= 60) |> \n  # Media de est_voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\")) |>\n  # Ordenar de mayor a menor por fecha\n  arrange(desc(date_elec)) |>\n  # extraemos los dos con m√°s est de voto (por cada fecha)\n  slice_max(media_voto, n = 2, by = date_elec)\n```\n\n# El mundo Github\n\n[**Trabajar ordenados, publicar resultados, replicabilidad de lo realizado**]{style=\"color:#444442;\"}\n\n---\n\n## ¬øQu√© es Github?\n\n[**GitHub**]{.hl-yellow} es la plataforma colaborativa m√°s conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}\n\n. . .\n\n* [**¬øQu√© es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programaci√≥n colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.\n\n. . .\n\n* [**¬øQu√© es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servir√° no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcci√≥n de nuestros proyectos de c√≥digo.\n\n. . .\n\n::: callout-important\n## Importante\n\nDesde el 4 de junio de 2018 Github es de Microsoft (ergo el c√≥digo que subas tambi√©n)\n\n:::\n\n---\n\n## Visi√≥n general\n\nTras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un c√≠rculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto\n\n:::: columns\n::: {.column width=\"55%\"}\n\n![](img/github_1.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"45%\"}\n* [**Edit profile**]{.hl-purple}: nos permite a√±adir una [**descripci√≥n y foto de perfil**]{.hl-yellow}.\n\n* [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizar√° nuestra actividad**]{.hl-yellow} a lo largo del tiempo.\n\n\n* [**Repositories**]{.hl-purple}: el c√≥dugo ser√° subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.\n\n:::\n::::\n\n---\n\n## Primer uso: consumidor\n\nAntes de aprender como crear repositorios, Github tambi√©n nos servir√° para\n\n* [**Acceder a c√≥digo**]{.hl-purple} ajeno\n* [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos\n\n. . .\n\n* [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente ¬´amplio¬ª para poder ser subido como paquete.\n\nEl c√≥digo de paquetes que no tengamos subido en CRAN podremos [**instalarlo como c√≥digo desde Github**]{.hl-yellow}\n\n---\n\n## Instalar desde Github\n\n\nPor ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya √∫nica funci√≥n es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**√°lbumes de m√∫sica urbana**]{.hl-yellow}\n\n:::: columns\n::: {.column width=\"50%\"}\n\n![](img/perrreo.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/rosalia.png){width=\"360\" fig-align=\"center\"}\n:::\n::::\n\n. . .\n\nPara ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitir√° la instalaci√≥n desde Github\n\n```{r}\n#| eval: false\ninstall.packages(\"devtools\")\n```\n\n---\n\n## Instalar desde Github\n\nLas [**instrucciones de instalaci√≥n**]{.hl-yellow} suelen venir detalladas en la portada del repositorio\n\n:::: columns\n::: {.column width=\"50%\"}\n\n![](img/install_perreo.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/rosalia.png){width=\"310\" fig-align=\"center\"}\n:::\n::::\n\n. . .\n\nEn la mayor√≠a de casos bastar√° con la funci√≥n `install_github()` (del paquete que acabamos de instalar), pas√°ndole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin \"github.com/\"). \n\n```{r}\n#| eval: false\ndevtools::install_github(\"jbgb13/peRReo\")\n```\n\n\nYa puedes perrear con ggplot ;)\n\n\n---\n\n## Descargar desde Github\n\nLa mayor√≠a de veces lo que subamos no ser√° un paquete de R como tal sino que [**subiremos un c√≥digo m√°s o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.\n\nPor ejemplo, vamos a descargarnos los scripts de `tidytable` que ha subido Hadley Wickham [TIDY:TABLE](https://github.com/hadley/tidytable)\n\n![](img/ceo_github.png){fig-align=\"center\"}\n\n---\n\n## Nuestro primer repositorio\n\nPara [**crear nuestro primero repositorio**]{.hl-yellow} que servir√° adem√°s como [**carta de presentaci√≥n**]{.hl-yellow} de nuestro perfil en Github, deber√°s tener una cuenta ya creada en [Github](https://github.com) y tener [Git](https://git-scm.com) instalado.\n\n\n1. Teniendo lo anterior ya realizado, podemos usar la librer√≠a [**usethis**]{.hl-purple} para simplificar el proceso.\n\n```{r}\n#| eval: false\ninstall.packages(\"usethis\")\n```\n\n2. Luego configuramos nuestras credenciales (los datos que usamos para la cuenta de GitHub):\n```{r}\nusethis::use_git_config(\n   user.name = \"Mi nombre\",\n   user.email = \"micorreo@gmail.com\"\n )\n```\n\n\n---\n\n## Nuestro primer repositorio\n\n3. Creamos nuestro GitHub PAT Token (es como una contrase√±a, pero m√°s segura). \n\n```{r}\n#| eval: false\nusethis::create_github_token()\n```\n\nCuando ejecutas este comando, se te abrir√° una pesta√±a de tu navegador. Tendr√°s que verificar algunos permisos a GitHub. Luego, en la configuraci√≥n del token, cambia el nombre, ajusta el tiempo de expiraci√≥n y el resto d√©jalo como est√°. Crea el token.\n\n4. Para guardar tu nuevo token, usa:\n\n```{r}\n#| eval: false\ngitcreds::gitcreds_set()\n```\n\nEn la consola se te mostrar√° un men√∫. Selecciona la opci√≥n 2: **Replace these credentials**. Luego copia el token de GitHub, actualiza y guarda tus credenciales.\n\n\n---\n\n\n## Nuestro primer repositorio\n\n5. Reinicia la sesi√≥n de RStudio para que [**se hagan efectivos los cambios**]{.hl-yellow}. Usualmente puedes usar **CTRL + SHIFT + F10** o del men√∫ de arriba selecciona la pesta√±a de **Session** y luego **Restart R**.\n\n6. Usa `usethis::git_sitrep()` para verificar si tus credenciales como nombre, email y PAT est√°n correctamente configuradas.\n\nF√≠jate que salga este texto: \n\n**Personal access token for https://github.com ... **\n\nCon eso ya deber√≠amos estar listos con la configuraci√≥n de GIT y GitHub.\n\n\n---\n\n## Nuestro primer repositorio\n\n7. Usaremos `use_git()` para iniciar el control de versiones de GIT en nuestro proyecto.\n\n![](img/use_git.png){width=\"380\" fig-align=\"center\"}\n\n8. Ahora, usaremos `usethis::use_github()` para crear un repositorio en GitHub y subir el proyecto.\n\nSi todo ha salido bien, se deber√≠a abrir tu navegador con el nuevo repositorio de GitHub.\n\n---\n\n## Github pages\n\n¬øC√≥mo [**convertir nuestro repositorio en una web**]{.hl-yellow}?\n\n![](./img/github-pages.png){fig-align=\"center\"}\n\n1. Haz click en `Settings`\n2. Ve al apartado `Pages`\n3. En el subapartado `branch` selecciona la √∫nica rama que tenemos ahora (`main`)\n4. Selecciona la carpeta donde tengas el `.html` (en web complejas estar√° como en cualquier web en `docs`, en algo simple estar√° en la ruta raiz del repositorio)\n5. Haz click en `Save`\n\n---\n\n## Github pages\n\nSi te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web est√° en proceso de ser desplegada (deploy)**]{.hl-orange}\n\n![](./img/github-naranja.png){fig-align=\"center\"}\n\n---\n\n## Github pages\n\nPasados unos segundos (dependiendo del tama√±o de la web y tu conexi√≥n a internet) ese [**icono pasar√° a ser un check verde**]{.hl-green}: habemus web\n\n![](./img/github-verde.png){fig-align=\"center\"}\n\n\nEl [**link de la web por defecto**]{.hl-yellow} ser√° `{nombre_usuario}.github.io/{nombre_repo}`\n\n---\n\n## Github pages\n\n\n![](./img/github-pages-deploy.png){fig-align=\"center\"}\n\n¬°Un momento! Ahora mismo nuestra web [**no nos est√° mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.\n\n. . .\n\nPara que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este √∫ltimo llam√°ndolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}\n\n---\n\n## Github pages\n\nVamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro\n\n\n![](./img/repo-index-html.png){fig-align=\"center\"}\n\n---\n\n## Github pages\n\nSi [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...\n\n:::: columns\n::: {.column width=\"50%\"}\n![](./img/index-html-qmd.png){fig-align=\"center\"}\n:::\n::: {.column width=\"50%\"}\n\nSi a tu `.qmd` ya le llamas de inicio `index.qmd`, autom√°ticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar a√±adiendo un archivo `css` de estilos)\n\n[**Habemus web**]{.hl-green} simplemente clickando en Pages :)\n\n:::\n::::\n\n\n---\n\n## Repo con diapositivas\n\nVamos a crear el √∫ltimo repositorio que se llamar√° `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.\n\n\n:::: columns\n::: {.column width=\"45%\"}\n![](img/quarto-slides.png)\n:::\n::: {.column width=\"55%\"}\nLa forma de escribir ser√° igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)\n\nLlama al archivo directamente `index.qmd`, s√∫belo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}\n:::\n::::\n\n\n# El mundo ggplot2\n\n[**Visualizaci√≥n de datos**]{style=\"color:#444442;\"}\n\n\n## ¬øQu√© es ggplot2?\n\n[**ggplot2**]{.hl-purple} es un paquete para graficar, que facilita crear gr√°ficas complejas a partir de datos en un [**data frame, data table o tibble**]{.hl-yellow}\n\n:::: columns\n::: {.column width=\"70%\"}\n\n- Incluye varias funciones para especificar que variables graficar, como √©stas son [**expuestas**]{.hl-yellow}, y varias otras caracter√≠sticas [**visuales**]{.hl-yellow}. \n\n- Funciona mejor con datos extensos, es decir, con aquellas estructuras donde se tiene una [**columna por cada dimensi√≥n o atributo**]{.hl-yellow}, y una [**fila por cada observaci√≥n**]{.hl-yellow}.\n\n::: callout-important\n## Importante\n\nggplot2 est√° incluido en el paquete tidyverse.\n\n:::\n\n:::\n::: {.column width=\"30%\"}\n![](img/ggplot2.png)\n:::\n::::\n\n\n---\n\n## Primera capa: el √°rea del gr√°fico\n\n::: incremental\n- La funci√≥n principal de ggplot2 es justamente `ggplot()` que permite iniciar el gr√°fico y adem√°s definir las [**caracter√≠sticas globales**]{.hl-yellow}. El primer argumento de esta funci√≥n ser√°n los datos que vas a visualizar.\n\n- El segundo argumento se llama `mapping` (mapeo en ingl√©s). Este argumento [**define la relaci√≥n**]{.hl-yellow} entre cada columna del data frame y los distintos par√°metros gr√°ficos.\n\n- Por ejemplo, qu√© columna va a representar el eje x, cu√°l va a ser el eje y, etc. Este mapeo se hace siempre con la funci√≥n `aes()` (que viene de aesthetics, est√©tica en ingl√©s).\n\n:::\n\n```{r}\n#| eval: true\n#| echo: true\ndatos <- tibble(Edad = seq(4,24, by = 2), \n                Estaturas = c(102, 109, 115, 121, 133, 141, 156, 167, 181, 187, 188),\n                Marca = sample(c(\"A\", \"B\"), size = 11, replace = TRUE))\n```\n\n```{r}\n#| eval: false\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas))\n```\n\n---\n\n## Segunda capa: geometr√≠as\n\nEl c√≥digo anterior s√≥lo genera el √°rea del gr√°fico y los ejes. Lo que falta es indicar con qu√© geometr√≠as representar los datos.\n\nPara agregar geometr√≠as lo que hay que hacer es sumar el resultado de una funci√≥n que devuelva una nueva capa. Estas suelen ser funciones que empiezan con `geom_` y luego el nombre de la geometr√≠a (en ingl√©s).\n\n::: incremental\n- [**geom_point()**]{.hl-purple}: para gr√°ficos de dispersi√≥n.\n\n- [**geom_boxplot()**]{.hl-purple}: para gr√°ficos de caja y bigotes.\n\n- [**geom_line()**]{.hl-purple}: para l√≠neas de tendencias, series de tiempo, etc.\n\n- [**geom_histogram()**]{.hl-purple}: para gr√°ficos de barras.\n\n:::\n\n::: callout-important\n## Importante\n\nUsa + para agregar un geom a una l√≠nea de comandos de ggplot.\n\n:::\n\n---\n\n## Gr√°fico de dispersi√≥n\n\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas)) + geom_point(size = 3, shape = 5, colour = \"blue\")\n```\n\n---\n\n## Gr√°fico de cajas y bigotes\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(y = Estaturas, fill = Marca)) + geom_boxplot()\n```\n\n---\n\n## Gr√°fico de l√≠neas\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas, colour = Marca)) + geom_line(size = 1.2, linetype = \"dashed\")\n```\n\n\n---\n\n## Gr√°fico de √°reas\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas)) + geom_area(colour = \"red\", fill = \"blue\", alpha = 0.3)\n```\n---\n\n## Nuestra Biblia\n\n![](img/cover.jpg){fig-align=\"center\"}\n\nSe puede acceder libremente al recurso a trav√©s del siguiente enlace: [**https://r-graphics.org**](https://r-graphics.org){.uri}\n\n\n\n\n# ENLACES\n\n[**Algunos paquetes o recursos curiosos**]{style=\"color:#444442;\"}\n\n\n---\n\n### Paletas de colores\n\n* [**{ggthemes}**]{.hl-purple}: [**temas y paletas extras**]{.hl-yellow} para ggplot (por ejemplo para **dalt√≥nicos**) <https://jrnold.github.io/ggthemes/> y <https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/>\n\n* [**{peRReo}**]{.hl-purple}: paletas inspiradas en [**portadas de m√∫sica urbana y latina**]{.hl-yellow} <https://github.com/jbgb13/peRReo>\n\n* [**Paletas inspiradas en el Metropolitan Museum**]{.hl-purple}: de Blake Robert Mills <https://github.com/BlakeRMills/MetBrewer/tree/main>\n\n* [**Paletas inspiradas en Harry Potter**]{.hl-purple}: de Alejandro Jim√©nez <https://github.com/aljrico/harrypotter>\n\n* [**{colorblindcheck}**]{.hl-purple}: detectar paletas de colores aptas [**dalt√≥nicos/as**]{.hl-yellow}. De Jakub Nowosad <https://github.com/Nowosad/colorblindcheck>\n\n---\n\n### Dataviz\n\n* [**R Graph Gallery**]{.hl-purple}: colecci√≥n de dataviz en R <https://www.r-graph-gallery.com/>\n\n* [**{patchwork}**]{.hl-purple}: agregar y [**componer gr√°ficas**]{.hl-yellow}. De Thomas Lin Pedersen. <https://patchwork.data-imaginist.com>\n\n* [**ggplotly**]{.hl-purple}: funci√≥n de `{plotly}`, para convertir ggplot a plotly ([**interactiva**]{.hl-yellow}) <https://www.rdocumentation.org/packages/plotly/versions/4.10.0/topics/ggplotly>.\n\n\nTras convertirlo a plotly se puede [**guardar autom√°ticamente en html**]{.hl-yellow} con <https://plotly-r.com/saving.html> y generar el [**c√≥digo del iframe responsive**]{.hl-yellow} con <https://bhaskarvk.github.io/widgetframe/articles/Using_widgetframe.html>\n\n\n\n---\n\n### Dataviz\n\n* [**{ggiraph}**]{.hl-purple}: gr√°ficas interactivas al [**estilo D3**]{.hl-yellow}. <https://davidgohel.github.io/ggiraph/>\n\n* [**Aprender a usar {ggiraph}**]{.hl-purple}: para gr√°ficas interactivas al [**estilo D3**]{.hl-yellow} <https://albert-rapp.de/posts/ggplot2-tips/17_ggiraph/17_ggiraph.html> \n\n* [**Gr√°ficas interactivas**]{.hl-purple}: <https://www.tanyashapiro.com/interactive-visuals>\n\n* [**{geomtextpath}**]{.hl-purple}: paquete para [**curvar el texto**]{.hl-yellow} ajust√°ndose a una gr√°fica. De Allan Cameron y Teun van den Brand. <https://allancameron.github.io/geomtextpath/>\n\n* [**{ggstream}**]{.hl-purple}: visualizaci√≥n de [**datos en flujo**]{.hl-yellow}. De Z. Gu. <https://github.com/davidsjoberg/ggstream>\n\n* [**{ggpattern}**]{.hl-purple}: rellenos con [**patrones geom√©tricos**]{.hl-yellow} en ggplot2. De coolbutuseless y Trevor L. Davis. <https://github.com/coolbutuseless/ggpattern>\n\n---\n\n### Mapas\n\n* [**{mapSpain}**]{.hl-purple}: visualizaci√≥n de [**datos en mapas de Espa√±a**]{.hl-yellow} en R. De Diego Hernang√≥mez <https://dieghernan.github.io/rpubs/mapSpain_RMadrid/#1>\n\n* [**{rasterpic}**]{.hl-purple}: visualizaci√≥n de [**mapas con im√°genes rasterizados de fondo**]{.hl-yellow}. De Diego Hernang√≥mez. <https://dieghernan.github.io/rasterpic/>\n\n\n---\n\n\n### Text mining\n\n* [**Manual de text mining**]{.hl-purple}: de Julia Silge y David Robinson. Recurso: <https://tidytextmining.com>\n\n* [**Descarga de textos libres**]{.hl-purple}: de David Robinson. Recurso: <https://github.com/ropensci/gutenbergr>\n\n* [**An√°lisis de sentimientos de tweets**]{.hl-purple}: de Harshvardhan. Recurso: <https://www.harsh17.in/twitter-sentiments/>\n\n### Grafos y redes\n\n* [**{tidygraph}**]{.hl-purple}: paquete al estilo `{tidyverse}` para [**visualizar y manipular grafos**]{.hl-yellow} <https://tidygraph.data-imaginist.com/index.html>\n\n\n---\n\n\n### Datos curiosos\n\n* [**{fitbitr}**]{.hl-purple}: API para acceder a [**datos de pulseras fitbit**]{.hl-yellow}. De Matt Kaye <https://mrkaye97.github.io/fitbitr/index.html>\n\n* [**{rtweet}**]{.hl-purple}: API para acceder (al menos antes) a [**Twitter**]{.hl-yellow}. De Michael W. Kearney <https://docs.ropensci.org/rtweet/>\n\n* [**{owiDR}**]{.hl-purple}: API para acceder a datos de [**Our World in Data**]{.hl-yellow} <https://github.com/piersyork/owidR>\n\n* [**{wordle}**]{.hl-purple}: API para acceder a [**datos de WORDLE**]{.hl-yellow}. De coolbutuseless <https://coolbutuseless.github.io/2022/01/04/wordle-v0.1.5-a-package-for-playing-and-helping-solve-wordle-puzzles/>\n\n* [**{chessR}**]{.hl-purple}: API para acceder a datos de [**partidas de ajedrez**]{.hl-yellow}. De Jason Zivkovic <https://github.com/JaseZiv/chessR>\n\n\n---\n\n\n### Informes, libros, diapositivas y webs\n\n* [**Manual de Quarto**]{.hl-purple}: el nuevo rmarkdown, m√°s completo y sencillo para elaborar manuales, diapositivas, informes e incluso webs <https://quarto.org/docs/guide/>\n\n* [**Shiny**]{.hl-purple}: webs interactivas con R <https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/>\n\n### Tablas\n\n* [**{gt}**]{.hl-purple}: tablas en R. De RStudio <https://gt.rstudio.com/>\n\n* [**{gtExtras}**]{.hl-purple}: visualizaci√≥n de datos en tablas. De Thomas Mock. <https://jthomasmock.github.io/gtExtras/index.html>\n\n* [**Tutorial de tablas**]{.hl-purple}: de Benjamin Nowak <https://bjnnowak.netlify.app/2021/10/04/r-beautiful-tables-with-gt-and-gtextras/>\n\n\n# ¬°GRACIAS!\n\n\n","srcMarkdownNoYaml":"\n\n# ¬°Bienvenidos al curso de Simulaci√≥n!\n\n[**Dejad Excel a un lado**]{style=\"color:#444442;\"}  \n![](img/hateExcel.png){width=10%}\n\n---\n\n## ¬°Hola a todos!\n\n::: columns\n::: {.column width=\"30%\"}\n![](img/me.jpeg)\n:::\n\n::: {.column width=\"70%\"}\n::: incremental\n-   [**Diego Pa√∫l Huaraca Shag√±ay**]{.hl-purple}\n\n-   Ingeniero Matem√°tico. [**Escuela Polit√©cnica Nacional**]{.hl-yellow} (2013).\n\n-   M√°ster en Ciencias Actuariales y Financieras. [**Universidad de Alcal√°**]{.hl-yellow} (2018).\n\n-   Consultor Anal√≠tico de Riesgo Financiero. [**BI-SCIENCES**]{.hl-green} (desde 2018).\n\n-   Docente del Departamento de Matem√°tica. [**Escuela Polit√©cnica Nacional**]{.hl-green} (desde 2018).\n\n-   Consultor Actuarial. [**Superintendencia de Bancos**]{.hl-green} (desde 2022).\n\n-   Socio Fundador de [**Tactary Consultor√≠a Actuarial**]{.hl-green} (desde 2022).\n:::\n:::\n:::\n\n---\n\n## Contenido del curso \n<!-- Primera parte -->\n::: columns\n::: {.column width=\"20%\"}\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTPKIAIbhuhpU6GMjL2jBdHycULZOCEVt-XWs9Z_b0elEikNTefOLW3yk2ajknsTLsMDo4&usqp=CAU)\n:::\n\n::: {.column width=\"80%\"}\n::: incremental\n-   [**Introducci√≥n al Lenguaje R**]{.hl-red} ‚Üí `{a programar se aprende programando}`.\n\n-   [**An√°lisis de datos**]{.hl-red} ‚Üí `{tibble, dplyr}`.\n\n-   [**Visualizaci√≥n de datos**]{.hl-red} ‚Üí `{gr√°ficos est√°ticos y din√°micos}`.\n\n-   [**Desarrollo de aplicativos web**]{.hl-red} ‚Üí `{shiny, shinydashboard}`.\n\n-   [**Reporter√≠a din√°mica**]{.hl-red} ‚Üí `{LaTeX, rmarkdown, Quarto}`.\n\n-   [**Simuladores de n√∫meros aleatorios**]{.hl-yellow}  ‚Üí `{base}`.\n\n:::\n:::\n:::\n\n\n## Contenido del curso\n<!-- Segunda Parte -->\n::: columns\n::: {.column width=\"20%\"}\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTPKIAIbhuhpU6GMjL2jBdHycULZOCEVt-XWs9Z_b0elEikNTefOLW3yk2ajknsTLsMDo4&usqp=CAU)\n:::\n\n::: {.column width=\"80%\"}\n::: incremental\n-   [**Simulaci√≥n de variables aleatorias**]{.hl-yellow} ‚Üí `{discretas y continuas}`.\n\n-   [**Simulaci√≥n de vectores aleatorias**]{.hl-yellow}.\n\n-   [**Simulaci√≥n de procesos estoc√°sticos**]{.hl-yellow} ‚Üí `{Markov, Weiner, etc.}`.\n\n-   [**M√©todos de MonteCarlo**]{.hl-red} ‚Üí `{secuenciales, inferencia estad√≠stica}`.\n\n-   [**T√©cnicas de Remuestreo**]{.hl-red}.\n\n-   [**M√©todos de MoteCarlo en Cadenas de Markov**]{.hl-red}\n\n-   [**Aplicaciones avanzadas**]{.hl-red} ‚Üí `{simulaci√≥n por eventos}`.\n:::\n:::\n:::\n\n\n# Instalaci√≥n del Lenguaje R\n\n[**Instalando R y RStudio**]{style=\"color:#444442;\"}\n\n---\n\n## Requisitos\n\nPara el desarrollo del curso se requiere:\n\n1.  [**Conexi√≥n a internet**]{.hl-yellow} (para la descarga de paquetes y bases de datos).\n\n2.  [**Descargar R**]{.hl-yellow}: La descarga se realiza (gratuitamente) desde el enlace: <https://cran.r-project.org/>\n\n3.  [**Descargar RStudio**]{.hl-yellow}: La descarga se realiza (gratuitamente) desde el enlace: <https://posit.co/download/rstudio-desktop/>\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/cranR.jpg){width=\"440\" fig-align=\"center\"}\n:::\n\n::: {.column width=\"50%\"}\n![](img/rstudio.jpg){width=\"440\" fig-align=\"center\"}\n:::\n:::\n\n---\n\n## Instalaci√≥n de R\n\n-   [**Paso 1**]{.hl-yellow}: Ingrese al repositorio CRAN en [**https://cran.r-project.org/**](https://cran.r-project.org/){.uri} y seleccione su sistema operativo.\n\n-   [**Paso 2**]{.hl-yellow}: Para el sistema MacOs basta con hacer click en **R-4.X.Y.pkg**, y abrirlo una vez descargado. Para el sistema Windows, basta con hacer click en **install R for the first time** y despu√©s en **Download R-X.Y.Z for Windows**, una vez descargado, abrirlo como cualquier archivo de instalaci√≥n.\n\n-   [**Paso 3**]{.hl-yellow}: Abrir el ejecutable e instalar el programa con todas las opciones por defecto.\n\n. . .\n\n::: callout-important\nSiempre que tengas que descargar algo del repositorio CRAN (ya sea el propio R o un paquete), [**aseg√∫rate de tener conexi√≥n a internet**]{.hl-red}.\n:::\n\n---\n\n## CRAN\n\n- El lenguaje R se distribuye gratuitamente a trav√©s del repositorio [**Comprehensive R Archive Network (CRAN)**]{.hl-purple}  propiedad de la R Foundation for Statistical Computing.\n\n- El mantenimiento se encuentra a cargo del [**grupo R Core Team**]{.hl-purple} asistido por una gran cantidad de colaboradores internacionales.\n\n- Con la finalidad de evitar el colapso del mundo estad√≠stico, el repositorio CRAN se refleja en [**diferentes lugares**]{.hl-purple} de todo el mundo\n\n\n![](img/CRAN.png){width=\"380\" fig-align=\"center\"}\n\n---\n\n## Funcionamiento\n\n- R es un lenguaje [**orientado a objetos**]{.hl-purple} dise√±ado en un entorno aut√©ntico bajo el cual esconde su simplicidad y flexibilidad, lo cual permite a sus usuarios a√±adir funcionalidad mediante la definici√≥n de nuevas funciones y operadores.\n\n- R almacena sus variables, datos, funciones y resultados en la [**memoria activa (RAM)**]{.hl-purple} del computador en forma de objetos con un nombre espec√≠fico y pueden ser [**modificados o manipulados**]{.hl-purple} por el usuario.\n\n::: {.column width=\"100%\"}\n![](img/FunR.png){width=\"630\" fig-align=\"center\"}\n:::\n\n\n---\n\n## Primera operaci√≥n\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.\n\nEsa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una simple **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\" fig-align=\"center\"}\n:::\n:::\n\n. . .\n\n[**Idea**]{.hl-yellow}: a una variable llamada `a` le asignaremos el valor de `3` (escribiremos el c√≥digo de abajo en la consola y daremos ¬´enter¬ª)\n\n```{r}\n#| code-line-numbers: \"1\"\na <- 3\n```\n\n---\n\n## Primera operaci√≥n\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.\n\nEsa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\" fig-align=\"center\"}\n:::\n:::\n\n[**Idea**]{.hl-yellow}: definiremos otra variable llamada `b` y le asignaremos el valor `5`\n\n```{r}\n#| code-line-numbers: \"2\"\na <- 3\nb <- 5\n```\n\n. . .\n\n::: callout-note\n## F√≠jate que...\n\nEn `R` usaremos `<-` como una **flecha**: la variable a la izquierda de dicha flecha recibe el valor que hay a la derecha (por ejemplo, `a <- 3`)\n:::\n\n---\n\n## Primera operaci√≥n\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.\n\nEsa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\"}\n:::\n:::\n\n[**Idea**]{.hl-yellow}: haremos la suma `a + b` y nos devolver√° su resultado\n\n```{r}\n#| code-line-numbers: \"3\"\na <- 3\nb <- 5\na + b\n```\n\n---\n\n## Instalaci√≥n de RStudio\n\n`RStudio` ser√° el [**Bloc de Notas**]{.hl-purple} que usaremos para escribir los c√≥digos (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).\n\n-   [**Paso 1**]{.hl-yellow}: Ingrese a la p√°gina de Posit en [**https://posit.co/download/rstudio-desktop/**](https://posit.co/download/rstudio-desktop/){.uri} y seleccione la descarga gratuita.\n\n-   [**Paso 2**]{.hl-yellow}: Selecciona el ejecutable en funci√≥n al sistema operativo que use.\n\n-   [**Paso 3**]{.hl-yellow}: Luego de la descarga, se apertura el ejecutable como cualquier otro programa y se instala todo por defecto.\n\n---\n\n## Organizaci√≥n de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes (la suma de las variables) en ella. La consola ser√° donde [**ejecutaremos √≥rdenes y mostraremos resultados**]{.hl-purple}.\n\n![](img/consola_rstudio.jpg){width=\"420\" fig-align=\"center\"}\n\n---\n\n## Organizaci√≥n de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Environment**]{.hl-yellow}: la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n a tu gusto) que tenemos en la parte superior derecha. Nos mostrar√° las [**variables que tenemos definidas**]{.hl-purple}.\n\n![](img/environment.jpg){width=\"380\" fig-align=\"center\"}\n\n---\n\n## Organizaci√≥n de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha servir√° para buscar [**ayuda de funciones**]{.hl-purple}, para [**visualizar gr√°ficos**]{.hl-purple}, as√≠ como para la [**carga de librer√≠as**]{.hl-purple} y [**navegaci√≥n**]{.hl-purple} por las carpetas del CPU.\n\n![](img/multiusos.jpg){width=\"420\" fig-align=\"center\"}\n\n# ¬øQu√© es R? Primeros usos\n\n[**¬øCu√°les son las ventajas? Primer uso**]{style=\"color:#444442;\"}\n\n---\n\n## ¬øQu√© es R? ¬øPor qu√© R?\n\n![](img/meme_barco.jpg){fig-align=\"center\"}\n\n---\n\n## ¬øQu√© es R? ¬øPor qu√© R?\n\n`R` es el [**lenguaje estad√≠stico por excelencia**]{.hl-yellow}, creado por y para estad√≠sticos/as, con 5 ventajas fundamentales [**frente a Excel**]{.hl-red}:\n\n\n::: incremental\n-   [**Lenguaje de programaci√≥n**]{.hl-yellow}: la obviedad [‚Üí an√°lisis [**replicables**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Gratuito**]{.hl-yellow}: la filosof√≠a de la comunidad de `R` es el compartir c√≥digo bajo **copyleft** [‚Üí [**uso √©tico de dinero p√∫blico**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a c√≥digo ajeno, incluso al **propio c√≥digo fuente** [‚Üí [**flexibilidad y transparencia**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo m√≠nimo, pero existen c√≥digos de otras personas que podemos reusar (19430 [**paquetes**]{.hl-yellow} al 28/04/2023) [‚Üí [**ahorro de tiempo**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programaci√≥n (como Python) [‚Üí [**menor curva de aprendizaje**]{.hl-purple}]{.fragment .fade-in}\n:::\n\n\n## ¬øPor qu√© programar?\n\n-   [**Automatizar**]{.hl-yellow} ‚Üí te permitir√° automatizar tareas recurrentes (ejemplo: actualizar pron√≥sticos del tiempo, actualizar informes estad√≠sticos) de forma que solo tendr√°s que programarlo uno vez.\n\n-   [**Replicabilidad**]{.hl-yellow} ‚Üí podr√°s replicar tu an√°lisis siempre de la misma manera.\n\n-   [**Flexibilidad**]{.hl-yellow} ‚Üí podr√°s adaptar el software a tus necesidades.\n\n-   [**Transparencia**]{.hl-yellow} ‚Üí ser auditado por la comunidad.\n\n![](img/the_general_problem.png){fig-align=\"center\"}\n\n---\n\n## Idea fundamental: paquetes\n\nUna de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: c√≥digos que otras personas han implementado para **resolver un problema**\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/paquetes.png)\n:::\n\n::: {.column width=\"65%\"}\n::: {.fragment fragment-index=\"1\"}\n-   [**Instalaci√≥n**]{.hl-yellow}: descargamos los c√≥digos de la web (necesitamos internet) ‚Üí [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)\n\n```{r}\n#| eval: false\ninstall.packages(\"dplyr\")\n```\n:::\n\n::: {.fragment fragment-index=\"2\"}\n-   [**Carga**]{.hl-yellow}: indicamos qu√© paquetes queremos usar cada vez que iniciamos `RStudio` ‚Üí [**traer el libro de la estanter√≠a**]{.hl-purple}\n\n```{r}\n#| eval: false\nlibrary(dplyr)\n```\n:::\n:::\n:::\n\n---\n\n## Idea fundamental: paquetes\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/paquetes.png)\n:::\n\n::: {.column width=\"65%\"}\nUna vez instalado, hay dos manera de usar un paquete (traerlo de la estanter√≠a)\n\n::: {.fragment fragment-index=\"1\"}\n-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesi√≥n [**todo el libro**]{.hl-purple}\n\n```{r}\n#| eval: false\nlibrary(dplyr)\n```\n:::\n\n::: {.fragment fragment-index=\"2\"}\n-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le √≠ndicamos que solo queremos una [**p√°gina concreta de ese libro**]{.hl-purple}\n\n```{r}\n#| eval: false\ndplyr::rename_if()\n```\n:::\n:::\n:::\n\n---\n\n## Paquetes: Acceso a funciones\n\n::: columns\n::: {.column width=\"22%\"}\n![](img/stringr.png)\n:::\n\n::: {.column width=\"78%\"}\nUna vez instalado y cargado el paquete, es posible indagar sobre las funciones que contiene a partir del comando `ls(\"package:_____\")`.\n\n```{r}\nlibrary(stringr)\nls(\"package:stringr\")\n```\n:::\n\n:::\n\n---\n\n## Carga de m√∫ltiples paquetes\n\nEn el caso que se requieran cargar varias librer√≠as se puede evitar la ejecuci√≥n de varias l√≠neas de c√≥digo a partir de la siguiente opci√≥n:\n```{r}\n#| eval: false\n# Listado de paquetes a cargar\npaquetes <- c(\"pckg_1\",\"pckg_2\", ... , \"pckg_n\")\n\n# Sentencia de carga\nlapply(paquetes, FUN=library, character.only=TRUE)\n```\n\n¬†\n\n. . .\n\nCon el fin de evitar cargar las librer√≠as m√°s utilizadas al arranque de cada sesi√≥n, se puede automatizar esta tarea a partir del archivo `.RProfile`\n```{r}\n#| eval: false\n# Crea el archivo .RProfile en el caso que no exista\nif(!file.exists(\"~/.Rprofile\")){\n  file.create(\"~/.Rprofile\")\n} \n\n# edita el archivo .RProfile y coloca las instrucciones a ejecutar autom√°ticamente\nfile.edit(\"~/.Rprofile\") \n```\n\n---\n\n## Respaldando informaci√≥n\n\nUna tarea importante dentro del an√°lisis de datos es el respaldo de informaci√≥n que se pueda dar sobre ciertos resultados obtenidos, en este punto R consta de dos comandos muy √∫tiles: `save` y `load`.\n\n¬†\n\n. . .\n\nEl primero de ellos permite almacenar en disco los objetos que desee el usuario (almacenamiento parcial), dicho comando tambi√©n puede ser configurado de tal manera que almacenen todos los objetos que se encuentra v√°lidos en el √°rea de trabajo.\n\n```{r}\n#| eval: false\nvector <- c(1,2,3,4,5)\nmatriz <- matrix(c(1,2,3,4,5,6), ncol = 2)\n\n# Si deseas guardar el objeto \"vector\" con el nombre \"Respaldos\"\nsave(vector, file = \"Respaldos.RData\")\n\n# para el caso que se desee almacenar todos los objetos con el nombre \"TotalRespaldos\" \nsave(list = ls(all = TRUE), file = \"TotalRespaldos.RData\")\n```\n\n---\n\n\n## Mensajes de error o advertencia\n\nDurante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera ‚Üí [**te vas equivocar**]{.hl-yellow}. No solo ser√° importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.\n\n. . .\n\n-   [**Mensajes de error**]{.hl-red}: precedidos de **¬´Error in...¬ª** y ser√°n aquellos fallos que [**impidan la ejecuci√≥n**]{.hl-yellow}\n\n```{r}\n#| error: true\n\"a\" + 1 \n```\n\n. . .\n\n-   [**Mensajes de warning**]{.hl-orange}: precedidos de **¬´Warning in...¬ª** son los (posibles) fallos m√°s delicados ya que son incoherencias que [**no impiden la ejecuci√≥n**]{.hl-yellow}\n\n```{r}\n#| warning: true\n# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe\nsqrt(-1)\n```\n\n---\n\n## Antes de arrancar: scripts\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/abrir_script.jpg){width=\"350\"}\n:::\n\n::: {.column width=\"65%\"}\nUn [**script**]{.hl-yellow} ser√° el documento en el que programamos, nuestro `blog de notas` (aqu√≠ con extensi√≥n `.R`) donde escribiremos las √≥rdenes. Para **abrir nuestro primero script**, haz click en el men√∫ en `File < New File < R Script`.\n:::\n:::\n\n::: callout-warning\n## Cuidado\n\nEs importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habr√°s perdido**]{.hl-red}.\n:::\n\n---\n\n## Ejecutando el primer script\n\nAhora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros c√≥digos**]{.hl-yellow}. ¬øC√≥mo ejecutarlo?\n\n. . .\n\n1.  **Escribimos** el c√≥digo a ejecutar.\n\n. . .\n\n2.  **Guardamos** el archivo .R haciendo click en `Save current document`.\n\n. . .\n\n3.  El c√≥digo no se ejecuta salvo que se lo indiquemos. Tenemos tres opciones:\n\n-   [**Copiar y pegar**]{.hl-yellow} en consola.\n-   [**Seleccionar l√≠neas**]{.hl-yellow} y `Ctrl+Enter`\n-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el c√≥digo **completo**.\n\n---\n\n## üíª Tu turno\n\n[**Ejecuta tu primer script**: crea un script de cero, programa lo indicado debajo y ejec√∫talo (de las 3 maneras posibles)]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Define una variable de nombre `a` y cuyo valor sea -1\n\n```{r}\n#| code-fold: true\na <- -1\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù A√±ade debajo otra l√≠nea para definir una variable `b` con el valor 5. Tras ello m√∫ltiplica ambas variables\n\n```{r}\n#| code-fold: true\n#| eval: false\nb <- 5\na * b # sin guardar\nmultiplicacion <- a * b # guardado\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Modifica el c√≥digo inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables.\n\n```{r}\n#| eval: false\nc <- # deber√≠as asignarle el valor 3\nd <- # deber√≠as asignarle el valor -1\n```\n\n```{r}\n#| code-fold: true\n#| eval: false\nc <- 3\nd <- -1\nc / d # sin guardar\ndivision <- c / d # guardado\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Asigna un valor positivo a `x` y calcula su ra√≠z cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la funci√≥n `abs()`.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx <- 5\nsqrt(x)\n\ny <- -2\nabs(y)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Usando la variable `x` ya definida, completa/modifica el c√≥digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.\n\n```{r}\n#| eval: false\nz <- ? - ? # completa el c√≥digo\nz\n```\n\n```{r}\n#| code-fold: true\n#| eval: false\nz <- x - 5\nz\n```\n:::\n\n::: callout-note\n## Toma nota\n\nComandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: l√≠neas de c√≥digo que hemos ¬´encapsulado¬ª bajo un nombre, y dado unos argumentos de entrada, ejecuta las √≥rdenes (una especie de atajo).\n:::\n\n\n# Primeros datos: variables\n\n[**¬øQu√© tipos de datos existen?**]{style=\"color:#444442;\"}\n\n---\n\n## De la CELDA a la TABLA\n\n¬øQu√© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?\n\n![](img/celdas.jpg){fig-align=\"center\"}\n\n::: incremental\n-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.\n-   [**Variable**]{.hl-yellow}: **concatenaci√≥n** de valores del mismo tipo ([**vectores**]{.hl-purple}).\n-   [**Matriz**]{.hl-yellow}: concatenaci√≥n de variables del **mismo tipo y longitud**.\n-   [**Tabla**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}\n-   [**Lista**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}\n:::\n\n---\n\n## Celdas: tipos de datos\n\n¬øExisten [**variables m√°s all√° de los n√∫meros**]{.hl-yellow}?\n\n. . .\n\nPiensa por ejemplo en los datos guardados de una persona:\n\n::: {.fragment .fade-up}\n-   La edad o el peso ser√° un [**n√∫mero**]{.hl-yellow}.\n\n```{r}\nedad <- 33\n```\n:::\n\n::: {.fragment .fade-up}\n-   Su nombre ser√° una cadena de [**texto (string o char)**]{.hl-yellow}.\n\n```{r}\nnombre <- \"Diego\"\n```\n:::\n\n::: {.fragment .fade-up}\n-   A la pregunta ¬´¬øest√° usted soltero/a?¬ª la respuesta ser√° lo que llamamos una [**variable l√≥gica**]{.hl-yellow} (`TRUE` si est√° soltero/a o `FALSE` en otro caso).\n\n```{r}\nsoltero <- FALSE\n```\n:::\n\n::: {.fragment .fade-up}\n-   Su fecha de nacimiento ser√° precisamente eso, una [**fecha**]{.hl-yellow}.\n:::\n\n---\n\n## Variables num√©ricas\n\nEl dato m√°s sencillo (ya lo hemos usado) ser√°n las [**variables num√©ricas**]{.hl-yellow}\n\n```{r}\n#| eval: false\na <- 5\nb <- 2\na + b\n```\n\n```{r}\n#| echo: false\n#| include: false\na <- 5\nb <- 2\na + b\n```\n\n¬†\n\n. . .\n\nPara saber el tipo de una variable tenemos la funci√≥n `class()`\n\n```{r}\nclass(a)\n```\n\n¬†\n\n. . .\n\nCon las variables num√©ricas podemos realizar las [**operaciones aritm√©ticas**]{.hl-yellow} de una calculadora: sumar (`+`), ra√≠z cuadrada (`sqrt()`), cuadrado (`^2`), etc.\n\n```{r}\na^2\n```\n\n---\n\n## Variables de texto\n\nImagina que adem√°s de la edad de una persona queremos guardar su nombre\n\n```{r}\nnombre <- \"Diego\"\nclass(nombre)\n```\n\n¬†\n\n. . .\n\nLas [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones**]{.hl-red} aritm√©ticas (s√≠ otras operaciones como pegar o localizar patrones).\n\n```{r}\n#| error: true\nnombre + 1 # error al sumar n√∫mero a texto\n```\n\n¬†\n\n. . .\n\n::: callout-warning\n## Recuerda que...\n\nLas variables de tipo texto (character o stringr) van siempre [**entre comillas**]{.hl-orange}.\n:::\n\n---\n\n## Primera funci√≥n: paste\n\nComo hemos comentado, una [**funci√≥n**]{.hl-yellow} es un trozo de **c√≥digo encapsulado** bajo un nombre que depende de unos argumentos de entrada. Nuestra primera funci√≥n ser√° `paste()`: dadas dos cadenas de texto nos permite pegarlas.\n\n```{r}\npaste(\"Diego\", \"Huaraca\")\n```\n\n¬†\n\n. . .\n\nF√≠jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos a√±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador\n\n```{r}\npaste(\"Diego\", \"Huaraca\", sep = \"*\")\n```\n\n¬†\n\n. . .\n\n```{r}\npaste(\"Diego\", \"Huaraca\", sep = \" - \")\n```\n\n---\n\n## Primera funci√≥n: paste\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/paste_help.jpg)\n:::\n\n::: {.column width=\"50%\"}\n¬øC√≥mo saber que argumentos tiene una funci√≥n? Escribiendo en consola `? paste` o alternativamente `help(\"paste\")` te aparecer√° una [**ayuda**]{.hl-yellow} en el panel multiusos.\n\nEn dicha ayuda podr√°s ver en su cabecera que argumentos ya tiene asignados por defecto la funci√≥n\n:::\n:::\n\n. . .\n\nExiste una funci√≥n similar llamada `paste0()` que pega por defecto con `sep = \"\"` (sin nada).\n\n```{r}\npaste0(\"Diego\", \"Huaraca\")\n```\n\n---\n\n## Primer paquete: glue\n\nUna forma m√°s intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos ser√° ¬´comprar el libro¬ª (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}\n\n```{r}\n#| eval: false\ninstall.packages(\"glue\") # solo la primera vez\nlibrary(glue)\n```\n\n```{r}\n#| echo: false\nlibrary(glue)\n```\n\n. . .\n\nCon dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, ¬´la edad es de ... a√±os¬ª, donde la edad est√° guardada en una variable.\n\n```{r}\nedad <- 33\nglue(\"La edad es de {edad} a√±os\")\n```\n\n. . .\n\nDentro de las llaves tambi√©n podemos ejecutar operaciones\n\n```{r}\nunidades <- \"d√≠as\"\nglue(\"La edad es de {edad * 365} {unidades}\")\n```\n\n---\n\n## Variables l√≥gicas\n\nUna [**variable l√≥gica o binaria**]{.hl-yellow} es aquella que toma **dos valores**:\n\n-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.\n-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.\n-   `NA`: [**dato ausente**]{.hl-yellow} son las siglas de *not available*.\n\n```{r}\nsoltero <- TRUE # ¬øEs soltero? --> S√ç\nclass(soltero)\n```\n\n. . .\n\n::: callout-important\n## Importante\n\nLas variables l√≥gicas [**NO son variables de texto**]{.hl-red}: `\"TRUE\"` es un texto, `TRUE` es un valor l√≥gico.\n\n```{r}\n#| error: true\nTRUE + 1\n\"TRUE\" + 1\n```\n:::\n\n---\n\n## Condiciones l√≥gicas\n\nLos valores l√≥gicos suelen ser resultado de [**evaluar condiciones l√≥gicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos comprobar si una persona se llama Julia.\n\n```{r}\nnombre <- \"Mar√≠a\"\n```\n\n¬†\n\n. . .\n\nCon el [**operador l√≥gico**]{.hl-yellow} `==` preguntamos s√≠ a la izquierda es igual a la derecha\n\n```{r}\nnombre == \"Julia\"\n```\n\n. . .\n\nCon su opuesto `!=` preguntamos si es distinto.\n\n```{r}\nnombre != \"Julia\"\n```\n\n. . .\n\n::: callout-note\n## F√≠jate que...\n\nNo es lo mismo `<-` (asignaci√≥n) que una [**comparaci√≥n l√≥gica**]{.hl-yellow} con `==` (estamos preguntando).\n:::\n\n---\n\n## Condiciones l√≥gicas\n\nAdem√°s de las comparaciones ¬´igual a¬ª frente ¬´distinto¬ª, tambi√©n comparaciones de orden como `<, <=, > o >=`.\n\n¬†\n\n**¬øTiene la persona menos de 32 a√±os?**\n\n```{r}\nedad <- 38\nedad < 32 # ¬øEs la edad menor de 32 a√±os?\n```\n\n¬†\n\n**¬øLa edad es mayor o igual que 38 a√±os?**\n\n```{r}\nedad >= 38\n```\n\n---\n\n## Variables de fecha\n\nUn tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.\n\n```{r}\nfecha_char <- \"2021-04-21\"\n```\n\n. . .\n\nParece una simple cadena de texto pero [**representa un instante en el tiempo**]{.hl-yellow}. ¬øQu√© deber√≠a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?\n\n```{r}\n#| error: true\nfecha_char + 1\n```\n\n. . .\n\nLas fechas [**no pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha con `as_date()` del paquete `{lubridate}`\n\n```{r}\nlibrary(lubridate) # instala si no lo has hecho\nfecha <- as_date(\"2023-03-28\")\nfecha + 1\nclass(fecha)\n```\n\n---\n\n## Variables de fecha\n\nEn dicho paquete tenemos funciones muy √∫tiles para [**manejar fechas**]{.hl-yellow}:\n\n-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.\n\n```{r}\ntoday()\n```\n\n. . .\n\n-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}\n\n```{r}\nnow()\n```\n\n. . .\n\n-   Con `year()`, `month()` o `day()` podemos [**extraer el a√±o, mes y d√≠a**]{.hl-purple}\n\n```{r}\nfecha <- today()\nyear(fecha)\nmonth(fecha)\n```\n\n---\n\n## Res√∫menes de paquetes\n\n![](img/lubridate.png)\n\n::: callout-note\n## Amplia contenido\n\nTienes un resumen en pdf de los paquetes m√°s importantes en la [**carpeta ¬´fichas paquetes¬ª**]{.hl-green}\n:::\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Define una variable que guarde tu edad y otra con tu nombre\n\n```{r}\n#| code-fold: true\nedad <- 33\nnombre <- \"Javi\"\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Define otra variable que responda la pregunta ¬´¬øtengo hermanos?¬ª y otra con la fecha de tu nacimiento.\n\n```{r}\n#| code-fold: true\nhermanos <- TRUE\n\nlibrary(lubridate)\nfecha_nacimiento <- as_date(\"1989-09-10\")\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Define otra variable con tus apellidos y junta con `glue()` las variables `nombre` y `apellidos` (una coma entre ellos) en una sola variable `nombre_completo`.\n\n```{r}\n#| code-fold: true\n#| eval: false\napellidos <- \"√Ålvarez Li√©bana\"\nglue(\"{nombre}, {apellidos}\")\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Calcula los d√≠as que han pasado desde la fecha de tu nacimiento, haciendo la resta entre la fecha de hoy y la fecha de nacimiento definida en el ejercicio 2.\n\n```{r}\n#| code-fold: true\n#| eval: false\ntoday() - fecha_nacimiento\n```\n:::\n\n\n# Primeros datos: vectores\n\n[**¬øC√≥mo concatenamos valores? ¬øC√≥mo creamos una columna?**]{style=\"color:#444442;\"}\n\n---\n\n## Vectores: concatenar\n\nCuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaci√≥n**]{.hl-purple} de variables del [**mismo tipo**]{.hl-purple}\n\n¬†\n\n. . .\n\nLa forma m√°s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus elementos entre par√©ntesis y separados por comas\n\n```{r}\nedades <- c(33, 27, 60, 61)\nedades\n```\n\n¬†\n\n. . .\n\n::: callout-tip\nUn n√∫mero individual `x <- 1` es en realidad un vector de longitud uno.\n:::\n\n---\n\n## Vectores: concatenar\n\n::: columns\n::: {.column width=\"40%\"}\n![](img/edades_environment.jpg)\n:::\n\n::: {.column width=\"60%\"}\nComo ves ahora en el `environment` tenemos una **colecci√≥n de elementos** guardada\n\n```{r}\nedades\n```\n:::\n:::\n\n. . .\n\n¬†\n\nLa [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`\n\n```{r}\nlength(edades)\n```\n\n. . .\n\nTambi√©n podemos [**concatenar vectores**]{.hl-yellow}\n\n```{r}\nc(edades, edades, 8)\n```\n\n---\n\n## Secuencias num√©ricas\n\nEn muchas ocasiones querremos crear [**secuencias num√©ricas**]{.hl-yellow} (por ejemplo, los d√≠as del mes). El comando `seq(inicio, fin)` nos permite crear una **secuencia** desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.\n\n```{r}\nseq(1, 31)\n```\n\n¬†\n\n. . .\n\nEl comando `1:n` nos devuelve lo mismo que `seq(1, n)` (si el elemento inicial es mayor que el final, entender√° que la secuencia es **decreciente**)\n\n```{r}\n1:5\n7:-3\n```\n\n---\n\n## Secuencias num√©ricas\n\nTambi√©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos\n\n```{r}\nseq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5\n```\n\n. . .\n\n¬†\n\nOtras veces nos interesar√° definir una [**secuencia con una longitud concreta**]{.hl-yellow}\n\n```{r}\nseq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7\n```\n\n. . .\n\n¬†\n\nIncluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}\n\n```{r}\nrep(0, 7) # vector de 7 ceros\n```\n\n---\n\n## Vectores de caracteres\n\nUn vector es una **concatenaci√≥n** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo.\n\n```{r}\nfrase <- \"Me llamo Diego\"\nfrase\nlength(frase)\n```\n\n¬†\n\n. . .\n\nEn el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas\n\n```{r}\nvector <- c(\"Me\", \"llamo\", \"Diego\")\nvector\nlength(vector)\n```\n\n---\n\n## Vectores de caracteres\n\n¬øQu√© suceder√° si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?\n\n¬†\n\n. . .\n\n```{r}\nc(1, 2, \"Diego\", \"3\", TRUE)\n```\n\nF√≠jate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}\n\n¬†\n\n. . .\n\n```{r}\nc(3, 4, TRUE, FALSE)\n```\n\nEs importante entender que los valores l√≥gicos en realidad est√°n [**almacenados internamente como 0/1**]{.hl-yellow}\n\n---\n\n## Operaciones con vectores\n\nCon los vectores num√©ricos podemos hacer las mismas [**operaciones aritm√©ticas**]{.hl-yellow} que con los n√∫meros [‚Üí un [**n√∫mero es un vector**]{.hl-purple} (de longitud uno)]{.fragment .fade-in}\n\n\n. . .\n\n¬øQu√© suceder√° si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?\n\n. . .\n\n```{r}\nx <- c(1, 3, 5, 7)\nx + 1\nx * 2\n3 * x - 5\nx/2\n```\n\n::: callout-warning\n## Cuidado\n\nSalvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}\n:::\n\n---\n\n## Operaciones con vectores\n\nLos vectores tambi√©n pueden interactuar entre ellos, as√≠ que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)\n\n```{r}\nx <- c(2, 4, 6)\ny <- c(1, 3, 5)\nx + y\n```\n\n¬†\n\n. . .\n\nDado que la operaci√≥n (por ejemplo, una suma) se realiza elemento a elemento, ¬øqu√© suceder√° si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?\n\n. . .\n\n```{r}\nz <- c(1, 3, 5, 7)\nx + z\n```\n\nLo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que har√° ser√° reciclar del vector con menor longitud.\n\n---\n\n## Operaciones con vectores\n\nUna operaci√≥n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones l√≥gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...\n\n[**¬øQu√© d√≠as hizo menos de 22 grados?**]{.hl-yellow}\n\n```{r}\nx <- c(15, 20, 31, 27, 15, 29)\n```\n\n. . .\n\n```{r}\nx < 22\n```\n\nNos devolver√° un [**vector l√≥gico**]{.hl-yellow}, en funci√≥n de si **cada elemento** cumple o no la condici√≥n pedida.\n\n. . .\n\nSi tuvi√©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese d√≠a), la condici√≥n evaluada tambi√©n ser√≠a `NA`\n\n```{r}\ny <- c(15, 20, NA, 31, 27, 7, 29, 10)\ny < 22\n```\n\n---\n\n## Operaciones con vectores\n\nLas [**condiciones l√≥gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:\n\n-   [**Intersecci√≥n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunci√≥n y**]{.hl-purple} con `&`) para devolver un `TRUE`\n\n```{r}\nx < 30 & x > 15\n```\n\n-   [**Uni√≥n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunci√≥n o**]{.hl-purple} con `|`)\n\n```{r}\nx < 30 | x > 15\n```\n\n. . .\n\nCon `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen\n\n```{r}\nany(x < 30)\nall(x < 30)\n```\n\n---\n\n## Operaciones con vectores\n\nTambi√©n podemos hacer uso de [**operaciones estad√≠sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.\n\n```{r}\nx <- c(4, -2, 3, -7)\nsum(x)\n```\n\n¬†\n\n[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}\n\n. . .\n\n```{r}\nx <- c(4, -2, 3, NA, -7)\nsum(x)\n```\n\nPor defecto, si tenemos un dato ausente, la [**operaci√≥n tambi√©n ser√° ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`\n\n```{r}\nsum(x, na.rm = TRUE)\n```\n\n---\n\n## Operaciones con vectores\n\nComo hemos comentado que los valores l√≥gicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritm√©ticas.\n\n¬†\n\nPor ejemplo, si queremos [**averiguar el n√∫mero o el promedio de elementos que cumplen una condici√≥n**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendr√°n asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar o promediar dicho vector l√≥gico para obtener el n√∫mero de elementos que cumplen\n\n```{r}\nx <- c(-5, 7, 2, 4, 6, 9, -1)\n\n# N√∫mero de elementos que cumplen la condici√≥n\nsum(x < 3)\n\n# Promedio de elementos que cumplen la condici√≥n\nmean(x<3)\n```\n\n---\n\n## Operaciones con vectores\n\nOtras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.\n\n¬†\n\n-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La m√°s conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores at√≠picos o outliers (valores muy grandes o muy peque√±os), la media se perturba con mucha facilidad.\n\n```{r}\nx <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)\nmean(x, na.rm = TRUE)\n```\n\n---\n\n## Operaciones con vectores\n\nOtras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.\n\n¬†\n\n-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.\n\n```{r}\nx <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)\nmedian(x)\n```\n\n. . .\n\n-   [**Percentiles**]{.hl-yellow}: medidas de posici√≥n (nos dividen en partes iguales los datos).\n\n```{r}\nquantile(x) # por defecto percentiles 0-25-50-75-100\nquantile(x, probs = seq(0.1, 0.9, by = 0.1)) # deciles\n```\n\n---\n\n## Operaciones con vectores\n\nOtra operaci√≥n muy habitual es la de [**acceder a elementos**]{.hl-yellow} de un vector. La forma m√°s sencilla es usar el operador `[i]` (acceder al elemento i-√©simo)\n\n```{r}\nedades <- c(20, 30, 33, NA, 61) \nedades[3] # accedemos a la edad de la tercera persona \n```\n\n. . .\n\n¬†\n\nDado que un n√∫mero no es m√°s que un vector de longitud uno, esta operaci√≥n tambi√©n la podemos aplicar usando un [**vector de √≠ndices a seleccionar**]{.hl-yellow}\n\n```{r}\ny <- c(\"hola\", \"qu√©\", \"tal\", \"est√°s\", \"?\")\ny[c(1:2, 4)] # primer, segundo y cuarto elemento\n```\n\n::: callout-tip\nPara acceder al √∫ltimo sin preocuparnos, podemos pasarle como √≠ndice la longitud `x[length(x)]`\n:::\n\n---\n\n## Operaciones con vectores\n\nOtras veces queremos [**eliminar algunos elementos**]{.hl-yellow}, para ello, se repite la misma operaci√≥n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-√©simo del vector sino que lo ¬´des-selecciona¬ª\n\n```{r}\ny\ny[-2]\n```\n\n¬†\n\n. . .\n\nEn muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones l√≥gicas**]{.hl-yellow}, en funci√≥n de los valores, as√≠ que pasaremos como √≠ndice la propia condici√≥n (recuerda, `x < 2` nos devuelve un vector l√≥gico)\n\n```{r}\nedades <- c(15, 21, 30, 17, 45)\nnombres <- c(\"Javier\", \"Mar√≠a\", \"Laura\", \"Julia\", \"Luis\")\nnombres[edades < 18] # nombres de los menores de edad\n```\n\n---\n\n## Operaciones con vectores\n\nPor √∫ltimo, una acci√≥n habitual es saber [**ordenar valores**]{.hl-yellow}:\n\n-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo\n\n```{r}\nedades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)\nsort(edades)\nsort(edades, decreasing = TRUE)\n```\n\n. . .\n\n-   `order()`: devuelve el [**vector de √≠ndices**]{.hl-yellow} que tendr√≠amos que usar para tener el vector ordenado\n\n```{r}\norder(x)\nx[order(x)]\n```\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares, y calcula su suma.\n\n```{r}\n#| code-fold: true\n#| eval: false\n# Dos formas\nx <- c(1, 3, 5, 7, 9)\nx <- seq(1, 9, by = 2)\n\nsum(x)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Obt√©n los elementos de `x` mayores que 4. Calcula el n√∫mero de elementos de `x` mayores que 4.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx[x > 4]\nsum(x > 4)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor).\n\n```{r}\n#| code-fold: true\n#| eval: false\nz <- 1/x\nsort(z)\nz[order(z)]\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Encuentra el m√°ximo y el m√≠nimo del vector `x`\n\n```{r}\n#| code-fold: true\n#| eval: false\nmin(x)\nmax(x)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx[x > 1 & x < 7]\nall(x > 0)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\nüìù Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. Elimina del vector el segundo elemento. Tras eliminarlo determina su suma y su media\n\n```{r}\n#| code-fold: true\n#| eval: false\nx <- c(1, -5, 8, NA, 10, -3, 9)\nx[c(1, 2, 5, 6)]\ny <- x[-2]\nsum(y, na.rm = TRUE)\nmean(y, na.rm = TRUE)\n```\n:::\n\n# Primera base de datos\n\n[**¬øC√≥mo construimos una tabla? Matrices, data.frame y tibble**]{style=\"color:#444442;\"}\n\n---\n\n## Primer intento: matrices\n\nCuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una ¬´tabla¬ª que las recopile. La opci√≥n m√°s inmediata son las [**matrices**]{.hl-yellow}: concatenaci√≥n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.\n\n. . .\n\nImagina que tenemos estaturas y pesos de 4 personas. ¬øC√≥mo [**crear un dataset con las dos variables**]{.hl-yellow}? Con `cbind()` concatenamos en forma de columnas\n\n```{r}\nestaturas <- c(150, 160, 170, 180)\npesos <- c(60, 70, 80, 90)\ncbind(estaturas, pesos)\n```\n\n. . .\n\n¬†\n\n[**No profundizaremos**]{.hl-red} m√°s ya que nuestro objetivo es tener variables de misma longitud pero [**tipos diferentes**]{.hl-yellow} (pero que sepas que existen).\n\n---\n\n## Segundo intento: data.frame\n\nLas matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte\n\n```{r}\n#| code-line-numbers: \"4\"\nedades <- c(14, 24, NA)\nsoltero <- c(TRUE, NA, FALSE)\nnombres <- c(\"javi\", \"laura\", \"luc√≠a\")\ncbind(edades, soltero, nombres)\n```\n\n¬†\n\n. . .\n\nPara poder trabajar con [**variables de distinto tipo**]{.hl-yellow} haremos uso de lo que se conoce como [**data.frame**]{.hl-yellow}: unimos variables de igual longitud pero [**tipo distinto**]{.hl-purple}.\n\n```{r}\n#| code-line-numbers: \"1\"\ntabla <- data.frame(edades, soltero, nombres)\ntabla\n```\n\n---\n\n## Segundo intento: data.frame\n\n```{r}\ntabla\nclass(tabla)\n```\n\n¬†\n\n. . .\n\nDado que un `data.frame` es ya una ¬´base de datos¬ª las variables no son meros vectores matem√°ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}\n\n```{r}\nlibrary(lubridate)\ntabla <- data.frame(\"edad\" = edades, \"estado\" = soltero, \"nombre\" = nombres,\n             \"f_nacimiento\" = as_date(c(\"1989-09-10\", \"1992-04-01\", \"1980-11-27\")))\ntabla\n```\n\n---\n\n## Segundo intento: data.frame\n\n[**¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} \n\n\nPuedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`\n\n![](img/view_tabla.jpg){width=\"70%\" fig-align=\"center\"}\n\nNo se recomienda abusar del uso de la funci√≥n `View()` dado que se consume demasiada memoria RAM.\n\n---\n\n## Segundo intento: data.frame\n\nSi queremos acceder a sus elementos, el operador ser√° similar al de los vectores: ahora [**tenemos dos √≠ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)\n\n```{r}\ntabla[2, ]  # segunda fila (todas sus variables)\ntabla[, 3]  # tercera columna (de todos los individuos)\ntabla[2, 1]  # primera caracter√≠stica de la segunda persona\n```\n\n. . .\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/menu_data_frame.jpg)\n:::\n\n::: {.column width=\"65%\"}\nTambi√©n tiene ventajas de una [**¬´base¬ª de datos**]{.hl-yellow} : podemos [**acceder a las variables por su nombre**]{.hl-purple} (recomendable ya que las variables pueden cambiar de posici√≥n), poniendo el nombre de la tabla seguido del s√≠mbolo `$` (con el **tabulador**, nos aparecer√° un men√∫ de columnas a elegir)\n:::\n:::\n\n---\n\n## Segundo intento: data.frame\n\n-   `names()`: nos muestra los nombres de las variables\n\n```{r}\nnames(tabla)\n```\n\n¬†\n\n. . .\n\n-   `dim()`: nos muestra las dimensiones (tambi√©n `nrow()` y `ncol()`)\n\n```{r}\ndim(tabla)\n```\n\n¬†\n\n. . .\n\n-   Podemos acceder a las variables por su nombre\n\n```{r}\ntabla[c(1, 3), \"nombre\"]\n```\n\n---\n\n## Intento final: tibble\n\nLas tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}\n\nLa principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC\n\n```{r}\n#| error: true\ndata.frame(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n           \"IMC\" = peso / (estatura^2))\n```\n\n\nDe ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})\n\n```{r}\nlibrary(tibble)\ntibble(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n       \"IMC\" = peso / (estatura^2))\n```\n\nUn data.frame puede ser tranformado en un tibble por medio del comando `as_tibble()`.\n\n---\n\n## Intento final: tibble\n\n```{r}\ntabla <- tibble(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n                \"IMC\" = peso / (estatura^2))\ntabla\n```\n\nLas tablas en formato `tibble` nos permitir√° una [**gesti√≥n m√°s √°gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:\n\n. . .\n\n-   [**Metainformaci√≥n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya autom√°ticamente el n√∫mero de filas y columnas, y el tipo de cada variable\n\n. . .\n\n-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)\n\n---\n\n## Intento final: tibble\n\n-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning\n\n```{r}\n#| warning: true\ntabla$invent\n```\n\n. . .\n\n-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`\n\n```{r}\ntribble(~colA, ~colB,\n        \"a\",   1,\n        \"b\",   2)\n```\n\n. . .\n\n::: callout-tip\nEl paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de p√°ginas web y documentos sencillos\n:::\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Carga del paquete `{datasets}` el conjunto de datos `airquality` (contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a tibble (busca en la documentaci√≥n del paquete en <https://tibble.tidyverse.org/index.html>).\n\n```{r}\n#| code-fold: true\n#| eval: false\nlibrary(tibble)\nclass(datasets::airquality)\nairquality_tb <- as_tibble(datasets::airquality)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Una vez convertido a `tibble` obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?\n\n```{r}\n#| code-fold: true\n#| eval: false\nnames(airquality_tb)\nncol(airquality_tb)\nnrow(airquality_tb)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Filtra solo los datos del mes de agosto.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month == 8, ]\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Selecciona aquellos datos que no sean ni de julio ni de agosto.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month %in% c(7, 8), ]\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Modifica el siguiente c√≥digo para quedarte solo con las variable de ozono y temperatura.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[, c(\"Ozone\", \"Temp\")]\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\nüìù Selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month == 8, c(\"Temp\", \"Wind\")]\nnames(airquality_tb) <- c(\"ozono\", \"rad_solar\", \"viento\", \"temp\", \"mes\", \"dia\") \n```\n:::\n\n# R base vs Tidyverse\n\n[**Spoiler: un multiverso de datos limpios**]{style=\"color:#444442;\"}\n\n---\n\n## R base vs Tidyverse\n\nSi conoces alg√∫n otro lenguaje de programaci√≥n (o tienes gente cercana que programa) te extra√±ar√° que a√∫n no hayamos hablado de conceptos habituales como\n\n-   [**Bucles for**]{.hl-yellow}: repetir un c√≥digo un n√∫mero fijo de iteraciones.\n\n-   [**Bucles while**]{.hl-yellow}: repetir un c√≥digo hasta que se cumpla una condici√≥n\n\n-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el c√≥digo en funci√≥n del valor de las variables.\n\n¬†\n\n. . .\n\nY aunque conocer dichas estructuras puede ser en alg√∫n momento interesante, en la [**mayor√≠a de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles) [‚Üí en lugar de trabajar con lo que se conoce como R Base vamos a vertebrar el curso en torno a [**Tidyverse**]{.hl-yellow}]{.fragment .fade-in}\n\n---\n\n## ¬øQu√© es tidyverse?\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"50%\"}\n![](img/flow_tidyverse.jpg)\n:::\n:::\n\n`{tidyverse}` es un [**¬´universo¬ª de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicogr√°ficamente sencillo de entender, basado en la idea de que [**nuestros datos est√°n limpios y ordenados (tidy)**]{.hl-purple}\n\n---\n\n## ¬øQu√© es tidyverse?\n\n::: columns\n::: {.column width=\"45%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"55%\"}\n-   `{tibble}`: optimizando data.frame\n-   `{tidyr}`: limpieza de datos\n-   `{readr}`: carga datos rectangulares (.txt, .csv)\n-   `{dplyr}`: gram√°tica para depurar\n-   `{stringr}`: manejo de textos\n-   `{ggplot2}`: visualizaci√≥n de datos\n-   `{tidymodels}`: modelizaci√≥n/predicci√≥n\n:::\n:::\n\nTambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para variables cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.\n\n---\n\n\n## ¬øQu√© es tidyverse?\n\n::: columns\n::: {.column width=\"45%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"55%\"}\n-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}\n-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}\n-   `{readr}`: [**carga datos**]{.hl-yellow} rectangulares (.txt, .csv)\n-   `{dplyr}`: [**gram√°tica para depurar**]{.hl-yellow}\n-   `{stringr}`: [**manejo de textos**]{.hl-purple}\n-   `{ggplot2}`: [**visualizaci√≥n de datos**]{.hl-purple}\n-   `{tidymodels}`: [**modelizaci√≥n/predicci√≥n**]{.hl-green}\n:::\n:::\n\nTambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para variables cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.\n\n---\n\n## Filosof√≠a base: tidy data\n\n> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)\n\n<div style=\"font-size:120px; text-align: center; color:#F8DF58;\"><b>TIDY</b><span style=\"color:#CAB0EE;\"><b>VERSE</b></span></div>\n\nEl [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato de los datos para:\n\n::: incremental\n\n* [**sistematizar**]{.hl-green} la depuraci√≥n\n* hacer m√°s [**sencillo**]{.hl-green} su manipulaci√≥n.\n* c√≥digo [**legible**]{.hl-green}\n\n:::\n \n---\n\n## Reglas del tidy data\n\nLo primero por tanto ser√° entender qu√© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos est√°n estandarizados.\n\n\n:::: columns\n::: {.column width=\"50%\"}\n\n::: {.fragment .fade-in}\n1. Cada [**variable**]{.hl-yellow} en una [**√∫nica columna**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n2. Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n3. Cada [**celda**]{.hl-yellow} con un [**√∫nico valor**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n4. Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n5. Si queremos cruzar [**m√∫ltiples tablas**]{.hl-yellow} debemos tener una [**columna en com√∫n**]{.hl-purple} (llave de cruce).\n:::\n:::\n::: {.column width=\"50%\"}\n![](img/tidy_def.jpg){width=\"160%\"}\n:::\n::::\n\n---\n\n## Tuber√≠a (pipe)\n\nEn `{tidyverse}` ser√° clave el [**operador pipe (tuber√≠a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): ser√° una [**tuber√≠a que recorre los datos**]{.hl-yellow} y los transforma.\n\n. . .\n\n:::: columns\n::: {.column width=\"50%\"}\nEn R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, ser√≠a\n\n```{r}\n#| eval: false\nthird(second(first(datos)))\n```\n:::\n\n::: {.column width=\"50%\"}\n\nEn `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones\n\n```{r}\n#| eval: false\ndatos |> first() |> second() |> third()\n```\n\n:::\n::::\n\n&nbsp;\n\n. . .\n\n::: callout-caution\n## Apunte importante\n\nDesde la versi√≥n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo**  disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que depend√≠a del paquete `{magrittr}` (bastante problem√°tico).\n:::\n\n---\n\n## Tuber√≠a (pipe)\n\nLa principal ventaja es que el [**c√≥digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas c√≥digo.\n\n&nbsp;\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  limpio(...) |>\n  filtro(...) |>\n  selecciono(...) |>\n  ordeno(...) |>\n  modifico(...) |>\n  renombro(...) |>\n  agrupo(...) |>\n  cuento(...) |>\n  resumo(...) |>\n  pinto(...)\n```\n:::\n\n::: {.column width=\"50%\"}\n\n<center><img src=\"img/logo_pipe.png\" width=\"360px\"/></center>\n:::\n::::\n  \n\n---\n\n## Datos SUCIOS: messy data\n\n¬øPero qu√© aspecto tienen los [**datos no tidy**]{.hl-yellow}? \n\nVamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).\n\n¬†\n\n. . .\n\n```{r}\nlibrary(tidyr)\ntable4a\n```\n\n¬†\n\n. . .\n\n[**¬øQu√© puede estar fallando?**]{.hl-red}\n\n---\n\n## Pivotar: pivot_longer()\n\n:::: columns\n::: {.column width=\"40%\"}\n```{r}\ntable4a\n```\n:::\n\n::: {.column width=\"60%\"}\n\n‚ùé  Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) ‚Üí las columnas `1999` y `2000` en realidad deber√≠an ser en s√≠ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.\n:::\n::::\n\n. . .\n\nIncluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el a√±o y otra que guarde el valor de la variable de inter√©s en cada uno de esos a√±os. Y lo haremos con la funci√≥n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:\n\n```{r}\ntable4a |> \n  pivot_longer(cols = c(\"1999\", \"2000\"), names_to = \"year\", values_to = \"cases\")\n```\n\n\n---\n\n## Pivotar: pivot_longer()\n\n:::: columns\n\n::: {.column width=\"50%\"}\n\n```{r}\ntable4a |> \n  pivot_longer(cols = c(\"1999\", \"2000\"),\n               names_to = \"year\",\n               values_to = \"cases\")\n```\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/table4a.jpg)\n\n:::\n::::\n\n&nbsp;\n\n* `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}\n* `names_to`: nombre de la nueva variable a la que mandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).\n* `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos otro ejemplo con la tabla `table2`\n\n&nbsp;\n\n```{r}\ntable2\n```\n\n\n&nbsp;\n\n[**¬øQu√© puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Pivotar: pivot_wider()\n\n:::: columns\n::: {.column width=\"60%\"}\n```{r}\n#| echo: false\ntable2\n```\n:::\n\n::: {.column width=\"40%\"}\n\n‚ùé Cada [**observaci√≥n est√° dividido en dos filas**]{.hl-red} ‚Üí los [**registros con el mismo a√±o deber√≠an ser el mismo**]{.hl-yellow}\n\n:::\n::::\n\n. . .\n\nLo que haremos ser√° lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}\n\n```{r}\ntable2 |>  pivot_wider(names_from = type, values_from = count)\n```\n\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos otro ejemplo con la tabla `table3`\n\n&nbsp;\n\n```{r}\ntable3\n```\n\n\n&nbsp;\n\n[**¬øQu√© puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Separar: separate()\n\n:::: columns\n::: {.column width=\"60%\"}\n```{r}\ntable3\n```\n:::\n\n::: {.column width=\"40%\"}\n\n‚ùé Cada [**celda contiene varios valores**]{.hl-red} \n\n:::\n::::\n\n. . .\n\nLo que haremos ser√° hacer uso de la funci√≥n `separate()` para mandar a [**separar cada valor**]{.hl-yellow} a una columna diferente.\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"))\n```\n\n---\n\n## Separar: separate()\n\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"))\n```\n\nF√≠jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deber√≠an ser variables num√©ricas. Para ello podemos a√±adir el argumento opcional `convert = TRUE`\n\n. . .\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"), convert = TRUE)\n```\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos el √∫ltimo ejemplo con la tabla `table5`\n\n&nbsp;\n\n```{r}\ntable5\n```\n\n\n&nbsp;\n\n[**¬øQu√© puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Unir unite()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\ntable5\n```\n:::\n\n::: {.column width=\"50%\"}\n\n‚ùé Tenemos [**mismos valores divididos en dos columnas**]{.hl-red} \n\n:::\n::::\n\n. . .\n\nUsaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y a√±o en una misma columna\n\n```{r}\ntable5 |> unite(col = year_completo, century, year, sep = \"\")\n```\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\ntable4b |>\n  pivot_longer(cols = \"1999\":\"2000\", names_to = \"year\",\n               values_to = \"cases\")\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\nrelig_income |>\n  pivot_longer(cols = \"<$10k\":\"Don't know/refused\",\n               names_to = \"income\",\n               values_to = \"people\")\n```\n\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\nbillboard |>\n  pivot_longer(cols = \"wk1\":\"wk76\",\n               names_to = \"week\",\n               names_prefix = \"wk\",\n               values_to = \"position\",\n               values_drop_na = TRUE)\n```\n\n:::\n\n# Introducci√≥n a Tidyverse\n\n[**Con los datos limpios, podemos trabajarlos**]{style=\"color:#444442;\"}\n\n---\n\n## Preprocesamiento: dplyr\n\nDentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuraci√≥n**]{.hl-yellow} de datos de datos.\n\n:::: columns\n::: {.column width=\"65%\"}\n![](img/dplyr.png)\n:::\n\n::: {.column width=\"35%\"}\n```{r}\n#| eval: false\ndatos |>\n  limpio(...) |>\n  filtro(...) |>\n  selecciono(...) |>\n  ordeno(...) |>\n  modifico(...) |>\n  renombro(...) |>\n  agrupo(...) |>\n  cuento(...) |>\n  resumo(...) |>\n  pinto(...)\n```\n:::\n::::\n\n---\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\nUna de las operaciones m√°s comunes es [**filtrar registros**]{.hl-yellow} en base a alguna condici√≥n l√≥gica: con `filter()` se seleccionar√°n solo individuos que cumplan ciertas condiciones.\n\n::: incremental\n\n* `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-purple} que\n* `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-purple} que\n* `>=`, `<=`: [**mayor o igual**]{.hl-purple} o [**menor o igual**]{.hl-purple} que\n* `%in%`: valores [**pertenencen**]{.hl-purple} a un listado de opciones\n* `between(variable, val1, val2)`: si los valores (normalmente continuos) [**caen dentro de un rango**]{.hl-purple} de valores\n\n:::\n\n---\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| echo: false\n#| include: false\nlibrary(tidyverse)\ndata(\"starwars\")\n```\n\n```{r}\n#| eval: false\nstarwars |>  dplyr::filter(eye_color == \"brown\")\n```\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(eye_color != \"brown\")\n```\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(eye_color %in% c(\"blue\", \"brown\"))\n```\n\n\n::: callout-tip\n\n## Importante\nRecuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores l√≥gicos**]{.hl-green}.\n\n:::\n\n---\n\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(between(height, 120, 160))\n```\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |>\n   filter(eye_color == \"brown\" & species != \"Human\")\n```\n\n\n¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan m√°s de 60 a√±os**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |>\n  filter((eye_color == \"brown\" & species != \"Human\") | birth_year > 60)\n```\n\n  \n---\n\n## Eliminar ausentes: drop_na()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  retirar_ausentes(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  drop_na(var1, var2, ...)\n```\n:::\n::::\n\nHay un filtro especial que es el de [**retirar los ausentes**]{.hl-yellow}, para lo cual podemos usar `filter(is.na(variable))` o directamente `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquiera de las variables.\n\n. . .\n\n&nbsp;\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> drop_na(mass, height)\n```\n\n```{r}\n#| echo: false\nstarwars |>\n  drop_na(mass, height, sex) |> \n  select(name, mass, height, hair_color) |> \n  slice(1:7)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> drop_na()\n```\n\n```{r}\n#| echo: false\nstarwars |>\n  drop_na() |> \n  select(name, mass, height, hair_color) |> \n  slice(1:7)\n```\n\n:::\n::::\n\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido\n \n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(species == \"Droid\" | is.na(species))\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Selecciona del conjunto de starwars solo los personajes cuyo peso est√© entre 65 y 90 kg.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> filter(between(mass, 65, 90))\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na() |> \n  filter(species == \"Human\" & homeworld == \"Tatooine\")\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter((species != \"Human\" & sex == \"male\" &\n            between(height, 120, 170)) |\n           eye_color %in% c(\"brown\", \"red\"))\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù  Busca informaci√≥n en la ayuda de la funci√≥n `str_detect()` del paquete `{stringr}` (cargado en `{tidyverse}`). Consejo: prueba antes las funciones que vayas a usar con alg√∫n vector de prueba para poder comprobar su funcionamiento. Tras saber lo que hace, filtra solo aquellos personajes con apellido `Skywalker`\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> filter(str_detect(name, \"Skywalker\"))\n```\n\n:::\n\n---\n\n## Rebanadas de datos: slice()\n\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> rebanadas(posiciones)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(posiciones)\n```\n:::\n::::\n\nNormalmente filtraremos condici√≥n pero a veces nos puede interesar [**filtrar por posici√≥n**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de √≠ndices**]{.hl-yellow}\n\n. . .\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(1)\n```\n\n```{r}\n#| echo: false\nstarwars |> slice(1) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(7:9)\n```\n\n```{r}\n#| echo: false\nstarwars |> slice(7:9) |> select(name:hair_color)\n```\n:::\n::::\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> slice(c(2, 7, 10, 31))\n```\n\n\n```{r}\n#| echo: false\nstarwars |> slice(c(2, 7, 10, 31)) |> select(name:sex)\n```\n\n---\n\n## Rebanadas de datos: slice()\n\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> rebanadas(posiciones)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(posiciones)\n```\n:::\n::::\n\nDisponemos de opciones por defecto: con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_head(n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_head(n = 2) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%}\n```{r}\n#| eval: false\nstarwars |> slice_tail(n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_tail(n = 2) |> select(name:hair_color)\n```\n:::\n::::\n\n. . .\n\nCon `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`).\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_min(mass, n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_max(height, n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)\n```\n:::\n::::\n\n\n---\n\n\n## Reordenar filas: arrange()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> ordenar(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> arrange(var1, var2, ...)\n```\n:::\n::::\n\nTambi√©n podemos [**ordenar filas**]{.hl-yellow} en funci√≥n de alguna variable con `arrange()`\n\n```{r}\n#| eval: false\nstarwars |> arrange(mass)\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) \n```\n\n. . .\n\nPor [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`\n\n:::: columns\n::: {.column width=\"50%\"}\n\n```{r}\n#| eval: false\nstarwars |> arrange(desc(height))\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) \n```\n:::\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> arrange(mass, desc(height))\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) \n```\n:::\n::::\n\n---\n\n## Eliminar duplicados: distinct()\n\nMuchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`. \n\n```{r}\nstarwars |> distinct(sex)\n```\n\n. . .\n\nPara mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.\n\n```{r}\n#| eval: false\nstarwars |> distinct(sex, .keep_all = TRUE)\n```\n\n```{r}\n#| echo: false\nstarwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)\n```\n\n\n---\n\n## A√±adir filas: bind_rows()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ntibble1 |> encuadernar_filas(tibble2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ntibble1 |> bind_rows(tibble2)\n```\n:::\n::::\n\nPor √∫ltimo, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)\n\n\n```{r}\ndatos <-\n  tibble(\"nombre\" = c(\"javi\", \"laura\"), \"edad\" = c(33, 50))\ndatos\n```\n\n\n. . .\n\n```{r}\ndatos |> bind_rows(tibble(\"nombre\" = c(\"carlos\", NA), \"cp\" = c(28045, 28019)))\n```\n\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Selecciona solo los personajes que sean humanos y de ojos marrones, para despu√©s ordernarlos en altura descendente y peso ascendente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(eye_color == \"brown\" & species == \"Human\") |> \n  arrange(height, desc(mass))\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n\nüìù Extrae 3 registros aleatoriamente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_sample(n = 3)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n\nüìù Extrae el 10% de los registros aleatoriamente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_sample(prop = 0.1)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (m√°s pesados, m√°s probable)\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(mass) |> \n  slice_sample(n = 10, weight_by = mass)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Selecciona los 3 personajes m√°s mayores.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_max(birth_year, n = 3)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\nüìù Para saber que valores √∫nicos hay en el color de pelo, elimina duplicados de la variable `hair_color`, eliminando antes los ausentes de dicha variable.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(hair_color) |> \n  distinct(hair_color)\n```\n\n### [**Ejercicio 7**]{.hl-yellow}\n\nüìù De los personajes que son humanos y miden m√°s de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 m√°s altos, y orden de mayor a menor peso. Devuelve la tabla.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(species == \"Human\" & height > 160) |> \n  distinct(eye_color, .keep_all = TRUE) |> \n  drop_na(mass) |> \n  slice_max(height, n = 3) |> \n  arrange(desc(mass))\n```\n\n\n:::\n\n---\n\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\nLa opci√≥n m√°s sencilla para [**seleccionar variables por nombre**]{.hl-yellow} es  `select()`, dando como argumentos los nombres de columnas sin comillas.\n\n```{r}\nstarwars %>% select(name, hair_color)\n```\n\n---\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nLa funci√≥n `select()` nos permite seleccionar varias variables a la vez [**concatenando sus nombres como si fuesen √≠ndices**]{.hl-yellow}\n\n```{r}\n#| eval: false\nstarwars |> select(name:eye_color) \n```\n\n```{r}\n#| echo: false\nstarwars |> select(name:eye_color) |> slice(1:4)\n```\n\n. . .\n\nY podemos [**deseleccionar columnas**]{.hl-yellow} con `-`\n\n```{r}\n#| eval: false\nstarwars |>  select(-mass, -(eye_color:starships))\n```\n\n```{r}\n#| echo: false\nstarwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)\n```\n\n\n---\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\nTenemos adem√°s [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...\n\n```{r}\n#| eval: false\nstarwars |> select(mass, homeworld, everything())\n```\n\n```{r}\n#| echo: false\nstarwars |> select(mass, homeworld, everything()) |> slice(1:4)\n```\n\n. . .\n\n...y `last_col()` para referirnos a [**la √∫ltima columna**]{.hl-purple}.\n\n```{r}\n#| eval: false\nstarwars |> select(name:mass, homeworld, last_col())\n```\n\n```{r}\n#| echo: false\nstarwars |> select(name:mass, homeworld, last_col()) |> slice(1:4)\n```\n\n---\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nPodemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresi√≥n regular**]{.hl-purple} (`matches()`).\n\n\n```{r}\n# variables cuyo nombre acaba en \"color\" y contengan sexo o g√©nero\nstarwars |> select(ends_with(\"color\"), matches(\"sex|gender\"))\n```\n\n\n---\n\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nIncluso podemos [**seleccionar por rango num√©rico**]{.hl-yellow} si tenemos variables con un prefijo y n√∫meros.\n\n```{r}\ndatos <-\n  tibble(\"semana1\" = c(115, 141, 232), \"semana2\" = c(7, NA, 17),\n         \"semana3\" = c(95, 162, NA), \"semana4\" = c(11, 19, 15),\n         \"semana5\" = c(NA, 262, 190), \"semana6\" = c(21, 15, 23))\n```\n\n\n. . .\n\nCon `num_range()` podemos seleccionar con un prefijo y una secuencia num√©rica.\n\n```{r}\ndatos |> select(num_range(\"semana\", 1:4))\n```\n\n---\n\n\n## Selecci√≥n columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nPor √∫ltimo, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una funci√≥n que devuelva un valor l√≥gico de tipo de dato.\n\n```{r}\n# Solo columnas num√©ricas o de texto\nstarwars |> select(where(is.numeric) | where(is.character))\n```\n\n---\n\n\n## Mover columnas: relocate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  recolocar(var1, despues_de = var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  relocate(var1, .after = var2)\n```\n:::\n::::\n\nPara facilitar la [**recolocaci√≥n de variables**]{.hl-yellow} tenemos una funci√≥n para ello, `relocate()`, indic√°ndole en `.after` o `.before` [**detr√°s**]{.hl-purple} o [**delante**]{.hl-purple} de qu√© columnas queremos moverlas.\n\n```{r}\nstarwars |> relocate(species, .before = name)\n```\n\n\n\n---\n\n## Renombrar: rename()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> renombrar(nuevo = antiguo)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> rename(nuevo = antiguo)\n```\n:::\n::::\n\nA veces tambi√©n podemos querer [**modificar la ¬´metainformaci√≥n¬ª**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.\n\n```{r}\nstarwars |> rename(nombre = name, altura = height, peso = mass)\n```\n\n---\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\nEn muchas ocasiones queremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.\n\n```{r}\nstarwars |> mutate(height_m = height / 100)\n```\n\n---\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\nAdem√°s con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}\n\n```{r}\nstarwars |> \n  mutate(height_m = height / 100,\n         IMC = mass / (height_m^2), .before = name)\n```\n\n---\n\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\n::: callout-important\n## Importante...\n\nCuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la funci√≥n que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolver√° una constante**]{.hl-red}\n:::\n\n. . .\n\n```{r}\nstarwars |> \n  mutate(constante = mean(mass, na.rm = TRUE), .before = name)\n```\n\n\n---\n\n## Recategorizar: if_else()\n\nTambi√©n podemos combinar `mutate()` con la expresi√≥n de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condici√≥n**]{.hl-purple}, hace una cosa, en caso contrario otra.\n\n```{r}\nstarwars |> \n  mutate(human = if_else(species == \"Human\", \"Human\", \"Not Human\"),\n         .after = name) |> \n  select(name:mass)\n```\n\n\n---\n\n## Recategorizar: case_when()\n\nPara [**recategorizaciones m√°s complejas**]{.hl-yellow} tenemos  `case_when()`, por ejemplo, para crear una categor√≠a de los personajes en funci√≥n de su altura.\n \n```{r}\nstarwars |> \n  drop_na(height) |> \n  mutate(altura = case_when(height < 120 ~ \"enanos\",\n                            height < 160 ~ \"bajito\",\n                            height < 180 ~ \"normal\",\n                            height < 200 ~ \"alto\",\n                            TRUE ~ \"gigante\"), .before = name)\n```\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Selecciona solo las variables nombre, altura y as√≠ como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.\n \n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(name, height, contains(\"color\")) |> \n  drop_na(height)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(name, height, contains(\"color\")) |> \n  drop_na(height) |> \n  rename(nombre = name, altura = height,\n         color_pelo = eye_color, color_piel = skin_color,\n         color_pelo = hair_color)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detr√°s de la variable de nombres.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  select(name, height, contains(\"color\")) |> \n  drop_na(height) |> \n  rename(nombre = name, altura = height,\n         color_pelo = eye_color, color_piel = skin_color,\n         color_pelo = hair_color) |> \n  relocate(color_pelo, .after = nombre)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Con los datos originales, comprueba cu√°ntas modalidades √∫nicas hay en la variable de color de pelo.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  distinct(hair_color) |> \n  nrow()\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Del dataset original, selecciona solo las variables num√©ricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(where(is.numeric) | where(is.character)) |> \n  mutate(under_18 = birth_year < 18)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\nüìù Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  mutate(auburn = str_detect(hair_color, \"auburn\"))\n```\n\n### [**Ejercicio 7**]{.hl-yellow}\n\nüìù Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  mutate(IMC = mass / ((height/100)^2),\n         IMC_recat = case_when(species != \"Human\" ~ NA,\n                               IMC < 18 ~ \"delgadez\",\n                               IMC < 30 ~ \"normal\",\n                               TRUE ~ \"sobrepeso\"),\n         .after = name)\n```\n\n:::\n\n---\n\n## Contar: count()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> contar(var1, var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> count(var1, var2)\n```\n:::\n::::\n\nHasta ahora solo hemos transformado o consultado los datos pero no hemos generado estad√≠sticas. Empecemos por lo sencillo: [**¬øc√≥mo contar (frecuencias)?**]{.hl-yellow}\n\n. . .\n\nCuando lo usamos en solitario `count()` nos devolver√° simplemente el n√∫mero de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**n√∫mero de elementos de cada modalidad**]{.hl-purple}. \n\n```{r}\nstarwars |> count(sex)\n```\n\n---\n\n## Contar: count()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> contar(var1, var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> count(var1, var2)\n```\n:::\n::::\n\nAdem√°s si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolver√° el [**conteo ordenado**]{.hl-purple} (m√°s frecuentes primero).\n\n```{r}\nstarwars |> count(sex, gender, sort = TRUE)\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\nUna de las [**funciones m√°s potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitir√° [**agrupar nuestros registros**]{.hl-yellow} previamente\n\n```{r}\nstarwars |> \n  group_by(sex) |>\n  count() |>\n  ungroup()\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\nCuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificar√° las acciones futuras: las [**operaciones se aplicar√°n a cada subtabla por separado**]{.hl-purple}\n\n. . .\n\nPor ejemplo, imaginemos que queremos extraer el personaje m√°s alto con `slice_max()`.\n\n```{r}\nstarwars |> slice_max(height)\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\n¬øY si queremos [**extraer el personaje m√°s alto pero...de cada uno de los sexos**]{.hl-yellow}?\n\n. . .\n\n```{r}\nstarwars |>\n  group_by(sex) |> \n  slice_max(height) |> \n  ungroup()\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\n:::: columns\n::: {.column width=\"50%\"}\n![](img/tidydatatutor_1.jpg)\n:::\n\n::: {.column width=\"50%\"}\n![](img/tidydatatutor_2.jpg)\n:::\n::::\n\nLa web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)\n\n---\n\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |>\n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |>\n  ungroup()\n```\n:::\n::::\n\n::: callout-important\n## Importante\nRecuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada\n:::\n\n. . .\n\nEn la nueva versi√≥n de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`\n\n```{r}\n#| eval: false\nstarwars |> slice_max(height, by = sex)\n```\n\n.\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> slice_max(height, by = sex) |> select(name:eye_color)\n```\n\n---\n\n## Fila-a-fila: rowwise()\n\nUna opci√≥n muy √∫til usada antes de una operaci√≥n tambi√©n es `rowwise()`: toda [**operaci√≥n que venga despu√©s se aplicar√° en cada fila por separado**]{.hl-yellow}. Por ejemplo, vamos a definir un conjunto dummy de notas.\n\n```{r}\nnotas <- tibble(\"mates\" = c(7.5, 8, 9.1, 3),\n                \"lengua\" = c(8, 6, 6.5, 9.2))\n```\n\n. . .\n\nSi aplicamos la media directamente el valor ser√° id√©ntico ya que nos ha hecho la media global, pero nos gustar√≠a sacar una [**media por registro**]{.hl-yellow}. Para eso usaremos `rowwise()`\n\n```{r}\nnotas |> \n  rowwise() |> \n  mutate(media_curso = mean(c(mates, lengua)))\n```\n\n\n---\n\n## Resumir: summarise()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> summarise()\n```\n:::\n::::\n\nPor √∫ltimo tenemos `summarise()`, que nos permitir√° sacar res√∫menes estad√≠sticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.\n\n```{r}\nstarwars |> \n  drop_na(height) |> \n  summarise(media_altura = mean(height))\n```\n\n. . .\n\n::: callout-warning\n## Cuidado\nF√≠jate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que est√© indicado.\n:::\n\n---\n\n## Resumir: summarise()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> summarise()\n```\n:::\n::::\n\nSi adem√°s esto lo [**combinamos con la agrupaci√≥n**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas l√≠neas de c√≥digo puedes obtener [**estad√≠sticas desagregadas**]{.hl-purple}\n\n```{r}\nstarwars |> \n  drop_na(sex, height, mass) |> \n  summarise(media_altura = mean(height),\n            media_peso = mean(mass),\n            .by = sex)\n```\n\n---\n\n## Resumir: reframe()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> reframe()\n```\n:::\n::::\n\nEn el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos m√°s de un valor por variable**]{.hl-yellow}.\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: true\nstarwars |>\n  drop_na(mass) |>\n  summarise(quantile(mass))\n```\n:::\n::: {.column width=\"50%\"}\n```{r}\n#| eval: true\nstarwars |>\n  drop_na(mass) |>\n  reframe(quantile(mass))\n```\n:::\n::::\n\n---\n\n## Selectores: across()\n\nUn truco es [**hacer uso de selectores**]{.hl-yellow} `across` y `where`. El primero nos permite [**actuar sobre varias columnas por  nombre**]{.hl-purple} (con `mutate` o `summarise`)\n\n```{r}\nstarwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)\n```\n\n. . .\n\nEl segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.\n\n```{r}\nstarwars |> \n  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))\n```\n\n---\n\n## üíª Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\nüìù Calcula cu√°ntos personajes hay de cada especie, ordenados de m√°s a menor frecuencia.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> count(species, sort = TRUE)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\nüìù Tras eliminar ausentes en las variables de peso y estatura, a√±ade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(mass, height) |> \n  mutate(IMC = mass / ((height/100)^2)) |> \n  summarise(IMC_medio = mean(IMC), .by = sex)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\nüìù Obt√©n el personaje m√°s joven por cada sexo.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  slice_min(birth_year, by = sex)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\nüìù Obt√©n la edad del personaje m√°s joven y m√°s viejo de cada sexo.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(birth_year) |>\n  summarise(min(birth_year), max(birth_year), .by = sex)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\nüìù Determina la cantidad de personajes en cada d√©cada (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  count(birth_decade = round(birth_year, -1))\n```\n\n:::\n\n\n# Caso real: datos de encuestas\n\n[**Pongamos en pr√°ctica lo aprendido...**]{style=\"color:#444442;\"}\n\n---\n\n## Caso real: datos de encuestas\n\nEl paquete `{readr}` (ya en `{tidyverse}`) nos permite realizar una carga m√°s √°gil y m√°s inteligente que el `read.csv()` de base (lo importa a un `tibble` e interpreta bien el tipo de cada variable, incluso fechas)\n\n```{r}\n#| echo: false\n#| eval: false\nencuestas <- read_csv(file = \"./datos/historical_surveys.csv\")\nencuestas <-\n  encuestas |>\n  mutate(cod_elec = \"02\") |> \n  select(type_survey, date_elec, id_pollster, pollster,\n         media, field_date_from, field_date_to, exit_poll,\n         size, turnout, abbrev_candidacies, est_vote) |> \n  pivot_wider(names_from = \"abbrev_candidacies\",\n              values_from = \"est_vote\")\nwrite_csv(encuestas, file = \"./datos/historical_surveys.csv\")\n```\n\n```{r}\nencuestas <- read_csv(file = \"./datos/historical_surveys.csv\")\nencuestas\n```\n\n---\n\n## Caso real: datos de encuestas\n\nLo [**primero que debes hacer**]{.hl-yellow} es visualizar con `View()` la tabla para entenderla\n\n. . .\n\n* [**Primera tarea**]{.hl-purple}: crea una variable llamada `id_survey` que nos permita identificar a cada encuesta. ¬øQu√© podr√≠amos concatenar?\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |> \n  # Creamos un id con type_survey-date_elec-id_pollster\n  # con .before la ponemos delante de everything(), de todo (1¬™ col)\n  mutate(id_survey = glue(\"{type_survey}-{date_elec}-{id_pollster}\"),\n         .before = everything())\n```\n\n---\n\n## Caso real: datos de encuestas\n\n* [**Segunda tarea**]{.hl-purple}: usando la variable `id_survey` creada elimina duplicados.\n\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |>\n  # Eliminamos duplicados por id_survey, pero mantenemos todas las\n  # columnas con .keep_all = TRUE\n  distinct(id_survey, .keep_all = TRUE)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n* [**Tercera tarea**]{.hl-purple}: tenemos una variable `media` que representa el medio en el que se public√≥ o encargo la encuesta. Elimina dicha variable, as√≠ como el tipo de encuesta y el id de la encuestadora\n\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |> \n  # Eliminamos las columnas pedidas con un -\n  # las concateno para usar solo un - para todas\n  select(-c(type_survey, id_pollster, media))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Cuarta tarea**]{.hl-purple}: qu√©date solo con las encuestas cuyo tama√±o muestral conozcamos y que no sean encuestas a pie de urna. Elimina esta √∫ltima variable.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # eliminar ausentes\n  drop_na(size) |> \n  # Filtramos encuestas (registros) a pie de urna (aquellas que exit_poll == FALSE)\n  dplyr::filter(!exit_poll) |> \n  # Quitamos la variable pie de urna\n  select(-exit_poll)\n```\n\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Quinta tarea**]{.hl-purple}: convierte el dataset en tidydata. ¬øQu√© falla? ¬øC√≥mo arreglarlo? Reminder: no queremos ausentes.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Convertimos a tidydata\n  pivot_longer(cols = -(id_survey:turnout),\n               names_to = \"partido\",\n               values_to = \"est_voto\",\n               values_drop_na = TRUE)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Sexta tarea**]{.hl-purple}: calcula el n√∫mero de d√≠as que la encuesta ha hecho trabajo de campo, y coloca dicha columna tras el nombre de la encuestadora. Tras ello elimina aquellas encuestas que tengan 0 d√≠as de trabajo de campo.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Calculamos los d√≠as de campo como la diferencia de fechas \n  # con as.numeric() convertimos la dif. de fechas a un n√∫mero\n  mutate(n_dias_campo = as.numeric(field_date_to - field_date_from),\n         .after = pollster) |> \n  # Solo aquellas cuyo trabajo de campo haya durado 1 d√≠a o m√°s\n  dplyr::filter(n_dias_campo > 0)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**S√©ptima tarea**]{.hl-purple}: calcula el n√∫mero de d√≠as que faltan hasta las elecciones desde que la encuesta cerro el trabajo de campo y coloca dicha variable tras `n_dias_campo`. Tras ello elimina las fechas de inicio y fin de trabajo de campo de la manera m√°s eficiente posible\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Calculamos los d√≠as que faltan a las elecciones\n  # con as.numeric() convertimos la dif. de fechas a un n√∫mero\n  mutate(n_dias_elec = as.numeric(date_elec - field_date_to),\n         .after = n_dias_campo) |> \n  # Eliminamos ya las fechas de campo que no necesitamos\n  select(-contains(\"field\"))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Octava tarea**]{.hl-purple}: elimina encuestas que se hayan cerrado dentro de la ventana temporal en la que est√° prohibido la publicaci√≥n de encuestas (no se deber√≠an usar para predecir ya que ¬´no se conocen¬ª)\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |>\n  # Solo con encuestas antes del baneo electoral\n  dplyr::filter(n_dias_elec > 15)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Novena tarea**]{.hl-purple}: obt√©n, por cada elecci√≥n, la media de las encuestas de cada partido\n\n```{r}\n#| code-fold: true\nencuestas |>\n  # Resumen: media de voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\"))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**D√©cima tarea**]{.hl-purple}: realiza lo mismo que la tarea anterior pero solo para las encuestas de los 60 d√≠as previos a las elecciones. Ordena la salida de reciente a antiguo\n\n```{r}\n#| code-fold: true\nencuestas |>\n  # Filtramos ventana de 60 d√≠as\n  dplyr::filter(n_dias_elec <= 60) |>\n  # Media de est_voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\")) |>\n  # Ordenar de mayor a menor\n  arrange(desc(date_elec))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Und√©cima tarea**]{.hl-purple}: del dataset generado en el anterior ejercicio, obt√©n el primer y el segundo con mayor estimaci√≥n de voto (en promedio)\n\n```{r}\n#| code-fold: true\nencuestas |> \n  # Filtramos ventana de 60 d√≠as\n  dplyr::filter(n_dias_elec <= 60) |> \n  # Media de est_voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\")) |>\n  # Ordenar de mayor a menor por fecha\n  arrange(desc(date_elec)) |>\n  # extraemos los dos con m√°s est de voto (por cada fecha)\n  slice_max(media_voto, n = 2, by = date_elec)\n```\n\n# El mundo Github\n\n[**Trabajar ordenados, publicar resultados, replicabilidad de lo realizado**]{style=\"color:#444442;\"}\n\n---\n\n## ¬øQu√© es Github?\n\n[**GitHub**]{.hl-yellow} es la plataforma colaborativa m√°s conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}\n\n. . .\n\n* [**¬øQu√© es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programaci√≥n colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.\n\n. . .\n\n* [**¬øQu√© es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servir√° no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcci√≥n de nuestros proyectos de c√≥digo.\n\n. . .\n\n::: callout-important\n## Importante\n\nDesde el 4 de junio de 2018 Github es de Microsoft (ergo el c√≥digo que subas tambi√©n)\n\n:::\n\n---\n\n## Visi√≥n general\n\nTras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un c√≠rculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto\n\n:::: columns\n::: {.column width=\"55%\"}\n\n![](img/github_1.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"45%\"}\n* [**Edit profile**]{.hl-purple}: nos permite a√±adir una [**descripci√≥n y foto de perfil**]{.hl-yellow}.\n\n* [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizar√° nuestra actividad**]{.hl-yellow} a lo largo del tiempo.\n\n\n* [**Repositories**]{.hl-purple}: el c√≥dugo ser√° subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.\n\n:::\n::::\n\n---\n\n## Primer uso: consumidor\n\nAntes de aprender como crear repositorios, Github tambi√©n nos servir√° para\n\n* [**Acceder a c√≥digo**]{.hl-purple} ajeno\n* [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos\n\n. . .\n\n* [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente ¬´amplio¬ª para poder ser subido como paquete.\n\nEl c√≥digo de paquetes que no tengamos subido en CRAN podremos [**instalarlo como c√≥digo desde Github**]{.hl-yellow}\n\n---\n\n## Instalar desde Github\n\n\nPor ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya √∫nica funci√≥n es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**√°lbumes de m√∫sica urbana**]{.hl-yellow}\n\n:::: columns\n::: {.column width=\"50%\"}\n\n![](img/perrreo.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/rosalia.png){width=\"360\" fig-align=\"center\"}\n:::\n::::\n\n. . .\n\nPara ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitir√° la instalaci√≥n desde Github\n\n```{r}\n#| eval: false\ninstall.packages(\"devtools\")\n```\n\n---\n\n## Instalar desde Github\n\nLas [**instrucciones de instalaci√≥n**]{.hl-yellow} suelen venir detalladas en la portada del repositorio\n\n:::: columns\n::: {.column width=\"50%\"}\n\n![](img/install_perreo.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/rosalia.png){width=\"310\" fig-align=\"center\"}\n:::\n::::\n\n. . .\n\nEn la mayor√≠a de casos bastar√° con la funci√≥n `install_github()` (del paquete que acabamos de instalar), pas√°ndole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin \"github.com/\"). \n\n```{r}\n#| eval: false\ndevtools::install_github(\"jbgb13/peRReo\")\n```\n\n\nYa puedes perrear con ggplot ;)\n\n\n---\n\n## Descargar desde Github\n\nLa mayor√≠a de veces lo que subamos no ser√° un paquete de R como tal sino que [**subiremos un c√≥digo m√°s o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.\n\nPor ejemplo, vamos a descargarnos los scripts de `tidytable` que ha subido Hadley Wickham [TIDY:TABLE](https://github.com/hadley/tidytable)\n\n![](img/ceo_github.png){fig-align=\"center\"}\n\n---\n\n## Nuestro primer repositorio\n\nPara [**crear nuestro primero repositorio**]{.hl-yellow} que servir√° adem√°s como [**carta de presentaci√≥n**]{.hl-yellow} de nuestro perfil en Github, deber√°s tener una cuenta ya creada en [Github](https://github.com) y tener [Git](https://git-scm.com) instalado.\n\n\n1. Teniendo lo anterior ya realizado, podemos usar la librer√≠a [**usethis**]{.hl-purple} para simplificar el proceso.\n\n```{r}\n#| eval: false\ninstall.packages(\"usethis\")\n```\n\n2. Luego configuramos nuestras credenciales (los datos que usamos para la cuenta de GitHub):\n```{r}\nusethis::use_git_config(\n   user.name = \"Mi nombre\",\n   user.email = \"micorreo@gmail.com\"\n )\n```\n\n\n---\n\n## Nuestro primer repositorio\n\n3. Creamos nuestro GitHub PAT Token (es como una contrase√±a, pero m√°s segura). \n\n```{r}\n#| eval: false\nusethis::create_github_token()\n```\n\nCuando ejecutas este comando, se te abrir√° una pesta√±a de tu navegador. Tendr√°s que verificar algunos permisos a GitHub. Luego, en la configuraci√≥n del token, cambia el nombre, ajusta el tiempo de expiraci√≥n y el resto d√©jalo como est√°. Crea el token.\n\n4. Para guardar tu nuevo token, usa:\n\n```{r}\n#| eval: false\ngitcreds::gitcreds_set()\n```\n\nEn la consola se te mostrar√° un men√∫. Selecciona la opci√≥n 2: **Replace these credentials**. Luego copia el token de GitHub, actualiza y guarda tus credenciales.\n\n\n---\n\n\n## Nuestro primer repositorio\n\n5. Reinicia la sesi√≥n de RStudio para que [**se hagan efectivos los cambios**]{.hl-yellow}. Usualmente puedes usar **CTRL + SHIFT + F10** o del men√∫ de arriba selecciona la pesta√±a de **Session** y luego **Restart R**.\n\n6. Usa `usethis::git_sitrep()` para verificar si tus credenciales como nombre, email y PAT est√°n correctamente configuradas.\n\nF√≠jate que salga este texto: \n\n**Personal access token for https://github.com ... **\n\nCon eso ya deber√≠amos estar listos con la configuraci√≥n de GIT y GitHub.\n\n\n---\n\n## Nuestro primer repositorio\n\n7. Usaremos `use_git()` para iniciar el control de versiones de GIT en nuestro proyecto.\n\n![](img/use_git.png){width=\"380\" fig-align=\"center\"}\n\n8. Ahora, usaremos `usethis::use_github()` para crear un repositorio en GitHub y subir el proyecto.\n\nSi todo ha salido bien, se deber√≠a abrir tu navegador con el nuevo repositorio de GitHub.\n\n---\n\n## Github pages\n\n¬øC√≥mo [**convertir nuestro repositorio en una web**]{.hl-yellow}?\n\n![](./img/github-pages.png){fig-align=\"center\"}\n\n1. Haz click en `Settings`\n2. Ve al apartado `Pages`\n3. En el subapartado `branch` selecciona la √∫nica rama que tenemos ahora (`main`)\n4. Selecciona la carpeta donde tengas el `.html` (en web complejas estar√° como en cualquier web en `docs`, en algo simple estar√° en la ruta raiz del repositorio)\n5. Haz click en `Save`\n\n---\n\n## Github pages\n\nSi te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web est√° en proceso de ser desplegada (deploy)**]{.hl-orange}\n\n![](./img/github-naranja.png){fig-align=\"center\"}\n\n---\n\n## Github pages\n\nPasados unos segundos (dependiendo del tama√±o de la web y tu conexi√≥n a internet) ese [**icono pasar√° a ser un check verde**]{.hl-green}: habemus web\n\n![](./img/github-verde.png){fig-align=\"center\"}\n\n\nEl [**link de la web por defecto**]{.hl-yellow} ser√° `{nombre_usuario}.github.io/{nombre_repo}`\n\n---\n\n## Github pages\n\n\n![](./img/github-pages-deploy.png){fig-align=\"center\"}\n\n¬°Un momento! Ahora mismo nuestra web [**no nos est√° mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.\n\n. . .\n\nPara que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este √∫ltimo llam√°ndolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}\n\n---\n\n## Github pages\n\nVamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro\n\n\n![](./img/repo-index-html.png){fig-align=\"center\"}\n\n---\n\n## Github pages\n\nSi [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...\n\n:::: columns\n::: {.column width=\"50%\"}\n![](./img/index-html-qmd.png){fig-align=\"center\"}\n:::\n::: {.column width=\"50%\"}\n\nSi a tu `.qmd` ya le llamas de inicio `index.qmd`, autom√°ticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar a√±adiendo un archivo `css` de estilos)\n\n[**Habemus web**]{.hl-green} simplemente clickando en Pages :)\n\n:::\n::::\n\n\n---\n\n## Repo con diapositivas\n\nVamos a crear el √∫ltimo repositorio que se llamar√° `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.\n\n\n:::: columns\n::: {.column width=\"45%\"}\n![](img/quarto-slides.png)\n:::\n::: {.column width=\"55%\"}\nLa forma de escribir ser√° igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)\n\nLlama al archivo directamente `index.qmd`, s√∫belo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}\n:::\n::::\n\n\n# El mundo ggplot2\n\n[**Visualizaci√≥n de datos**]{style=\"color:#444442;\"}\n\n\n## ¬øQu√© es ggplot2?\n\n[**ggplot2**]{.hl-purple} es un paquete para graficar, que facilita crear gr√°ficas complejas a partir de datos en un [**data frame, data table o tibble**]{.hl-yellow}\n\n:::: columns\n::: {.column width=\"70%\"}\n\n- Incluye varias funciones para especificar que variables graficar, como √©stas son [**expuestas**]{.hl-yellow}, y varias otras caracter√≠sticas [**visuales**]{.hl-yellow}. \n\n- Funciona mejor con datos extensos, es decir, con aquellas estructuras donde se tiene una [**columna por cada dimensi√≥n o atributo**]{.hl-yellow}, y una [**fila por cada observaci√≥n**]{.hl-yellow}.\n\n::: callout-important\n## Importante\n\nggplot2 est√° incluido en el paquete tidyverse.\n\n:::\n\n:::\n::: {.column width=\"30%\"}\n![](img/ggplot2.png)\n:::\n::::\n\n\n---\n\n## Primera capa: el √°rea del gr√°fico\n\n::: incremental\n- La funci√≥n principal de ggplot2 es justamente `ggplot()` que permite iniciar el gr√°fico y adem√°s definir las [**caracter√≠sticas globales**]{.hl-yellow}. El primer argumento de esta funci√≥n ser√°n los datos que vas a visualizar.\n\n- El segundo argumento se llama `mapping` (mapeo en ingl√©s). Este argumento [**define la relaci√≥n**]{.hl-yellow} entre cada columna del data frame y los distintos par√°metros gr√°ficos.\n\n- Por ejemplo, qu√© columna va a representar el eje x, cu√°l va a ser el eje y, etc. Este mapeo se hace siempre con la funci√≥n `aes()` (que viene de aesthetics, est√©tica en ingl√©s).\n\n:::\n\n```{r}\n#| eval: true\n#| echo: true\ndatos <- tibble(Edad = seq(4,24, by = 2), \n                Estaturas = c(102, 109, 115, 121, 133, 141, 156, 167, 181, 187, 188),\n                Marca = sample(c(\"A\", \"B\"), size = 11, replace = TRUE))\n```\n\n```{r}\n#| eval: false\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas))\n```\n\n---\n\n## Segunda capa: geometr√≠as\n\nEl c√≥digo anterior s√≥lo genera el √°rea del gr√°fico y los ejes. Lo que falta es indicar con qu√© geometr√≠as representar los datos.\n\nPara agregar geometr√≠as lo que hay que hacer es sumar el resultado de una funci√≥n que devuelva una nueva capa. Estas suelen ser funciones que empiezan con `geom_` y luego el nombre de la geometr√≠a (en ingl√©s).\n\n::: incremental\n- [**geom_point()**]{.hl-purple}: para gr√°ficos de dispersi√≥n.\n\n- [**geom_boxplot()**]{.hl-purple}: para gr√°ficos de caja y bigotes.\n\n- [**geom_line()**]{.hl-purple}: para l√≠neas de tendencias, series de tiempo, etc.\n\n- [**geom_histogram()**]{.hl-purple}: para gr√°ficos de barras.\n\n:::\n\n::: callout-important\n## Importante\n\nUsa + para agregar un geom a una l√≠nea de comandos de ggplot.\n\n:::\n\n---\n\n## Gr√°fico de dispersi√≥n\n\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas)) + geom_point(size = 3, shape = 5, colour = \"blue\")\n```\n\n---\n\n## Gr√°fico de cajas y bigotes\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(y = Estaturas, fill = Marca)) + geom_boxplot()\n```\n\n---\n\n## Gr√°fico de l√≠neas\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas, colour = Marca)) + geom_line(size = 1.2, linetype = \"dashed\")\n```\n\n\n---\n\n## Gr√°fico de √°reas\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas)) + geom_area(colour = \"red\", fill = \"blue\", alpha = 0.3)\n```\n---\n\n## Nuestra Biblia\n\n![](img/cover.jpg){fig-align=\"center\"}\n\nSe puede acceder libremente al recurso a trav√©s del siguiente enlace: [**https://r-graphics.org**](https://r-graphics.org){.uri}\n\n\n\n\n# ENLACES\n\n[**Algunos paquetes o recursos curiosos**]{style=\"color:#444442;\"}\n\n\n---\n\n### Paletas de colores\n\n* [**{ggthemes}**]{.hl-purple}: [**temas y paletas extras**]{.hl-yellow} para ggplot (por ejemplo para **dalt√≥nicos**) <https://jrnold.github.io/ggthemes/> y <https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/>\n\n* [**{peRReo}**]{.hl-purple}: paletas inspiradas en [**portadas de m√∫sica urbana y latina**]{.hl-yellow} <https://github.com/jbgb13/peRReo>\n\n* [**Paletas inspiradas en el Metropolitan Museum**]{.hl-purple}: de Blake Robert Mills <https://github.com/BlakeRMills/MetBrewer/tree/main>\n\n* [**Paletas inspiradas en Harry Potter**]{.hl-purple}: de Alejandro Jim√©nez <https://github.com/aljrico/harrypotter>\n\n* [**{colorblindcheck}**]{.hl-purple}: detectar paletas de colores aptas [**dalt√≥nicos/as**]{.hl-yellow}. De Jakub Nowosad <https://github.com/Nowosad/colorblindcheck>\n\n---\n\n### Dataviz\n\n* [**R Graph Gallery**]{.hl-purple}: colecci√≥n de dataviz en R <https://www.r-graph-gallery.com/>\n\n* [**{patchwork}**]{.hl-purple}: agregar y [**componer gr√°ficas**]{.hl-yellow}. De Thomas Lin Pedersen. <https://patchwork.data-imaginist.com>\n\n* [**ggplotly**]{.hl-purple}: funci√≥n de `{plotly}`, para convertir ggplot a plotly ([**interactiva**]{.hl-yellow}) <https://www.rdocumentation.org/packages/plotly/versions/4.10.0/topics/ggplotly>.\n\n\nTras convertirlo a plotly se puede [**guardar autom√°ticamente en html**]{.hl-yellow} con <https://plotly-r.com/saving.html> y generar el [**c√≥digo del iframe responsive**]{.hl-yellow} con <https://bhaskarvk.github.io/widgetframe/articles/Using_widgetframe.html>\n\n\n\n---\n\n### Dataviz\n\n* [**{ggiraph}**]{.hl-purple}: gr√°ficas interactivas al [**estilo D3**]{.hl-yellow}. <https://davidgohel.github.io/ggiraph/>\n\n* [**Aprender a usar {ggiraph}**]{.hl-purple}: para gr√°ficas interactivas al [**estilo D3**]{.hl-yellow} <https://albert-rapp.de/posts/ggplot2-tips/17_ggiraph/17_ggiraph.html> \n\n* [**Gr√°ficas interactivas**]{.hl-purple}: <https://www.tanyashapiro.com/interactive-visuals>\n\n* [**{geomtextpath}**]{.hl-purple}: paquete para [**curvar el texto**]{.hl-yellow} ajust√°ndose a una gr√°fica. De Allan Cameron y Teun van den Brand. <https://allancameron.github.io/geomtextpath/>\n\n* [**{ggstream}**]{.hl-purple}: visualizaci√≥n de [**datos en flujo**]{.hl-yellow}. De Z. Gu. <https://github.com/davidsjoberg/ggstream>\n\n* [**{ggpattern}**]{.hl-purple}: rellenos con [**patrones geom√©tricos**]{.hl-yellow} en ggplot2. De coolbutuseless y Trevor L. Davis. <https://github.com/coolbutuseless/ggpattern>\n\n---\n\n### Mapas\n\n* [**{mapSpain}**]{.hl-purple}: visualizaci√≥n de [**datos en mapas de Espa√±a**]{.hl-yellow} en R. De Diego Hernang√≥mez <https://dieghernan.github.io/rpubs/mapSpain_RMadrid/#1>\n\n* [**{rasterpic}**]{.hl-purple}: visualizaci√≥n de [**mapas con im√°genes rasterizados de fondo**]{.hl-yellow}. De Diego Hernang√≥mez. <https://dieghernan.github.io/rasterpic/>\n\n\n---\n\n\n### Text mining\n\n* [**Manual de text mining**]{.hl-purple}: de Julia Silge y David Robinson. Recurso: <https://tidytextmining.com>\n\n* [**Descarga de textos libres**]{.hl-purple}: de David Robinson. Recurso: <https://github.com/ropensci/gutenbergr>\n\n* [**An√°lisis de sentimientos de tweets**]{.hl-purple}: de Harshvardhan. Recurso: <https://www.harsh17.in/twitter-sentiments/>\n\n### Grafos y redes\n\n* [**{tidygraph}**]{.hl-purple}: paquete al estilo `{tidyverse}` para [**visualizar y manipular grafos**]{.hl-yellow} <https://tidygraph.data-imaginist.com/index.html>\n\n\n---\n\n\n### Datos curiosos\n\n* [**{fitbitr}**]{.hl-purple}: API para acceder a [**datos de pulseras fitbit**]{.hl-yellow}. De Matt Kaye <https://mrkaye97.github.io/fitbitr/index.html>\n\n* [**{rtweet}**]{.hl-purple}: API para acceder (al menos antes) a [**Twitter**]{.hl-yellow}. De Michael W. Kearney <https://docs.ropensci.org/rtweet/>\n\n* [**{owiDR}**]{.hl-purple}: API para acceder a datos de [**Our World in Data**]{.hl-yellow} <https://github.com/piersyork/owidR>\n\n* [**{wordle}**]{.hl-purple}: API para acceder a [**datos de WORDLE**]{.hl-yellow}. De coolbutuseless <https://coolbutuseless.github.io/2022/01/04/wordle-v0.1.5-a-package-for-playing-and-helping-solve-wordle-puzzles/>\n\n* [**{chessR}**]{.hl-purple}: API para acceder a datos de [**partidas de ajedrez**]{.hl-yellow}. De Jason Zivkovic <https://github.com/JaseZiv/chessR>\n\n\n---\n\n\n### Informes, libros, diapositivas y webs\n\n* [**Manual de Quarto**]{.hl-purple}: el nuevo rmarkdown, m√°s completo y sencillo para elaborar manuales, diapositivas, informes e incluso webs <https://quarto.org/docs/guide/>\n\n* [**Shiny**]{.hl-purple}: webs interactivas con R <https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/>\n\n### Tablas\n\n* [**{gt}**]{.hl-purple}: tablas en R. De RStudio <https://gt.rstudio.com/>\n\n* [**{gtExtras}**]{.hl-purple}: visualizaci√≥n de datos en tablas. De Thomas Mock. <https://jthomasmock.github.io/gtExtras/index.html>\n\n* [**Tutorial de tablas**]{.hl-purple}: de Benjamin Nowak <https://bjnnowak.netlify.app/2021/10/04/r-beautiful-tables-with-gt-and-gtextras/>\n\n\n# ¬°GRACIAS!\n\n\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","output-file":"index.html"},"language":{"toc-title-document":"Tabla de contenidos","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Consejo","callout-note-title":"F√≠jate que...","callout-warning-title":"Cuidado","callout-important-title":"Importante","callout-caution-title":"Peligro","code-summary":"C√≥digo","code-tools-menu-caption":"C√≥digo","code-tools-show-all-code":"Mostrar c√≥digo","code-tools-hide-all-code":"Ocultar c√≥digo","code-tools-view-source":"Ver c√≥digo","code-tools-source-code":"C√≥digo fuente","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Buscar","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"es","fig-responsive":false,"quarto-version":"1.3.450","auto-stretch":true,"title":"An√°lisis y visualizaci√≥n de datos con R","subtitle":"Simulaci√≥n (IMAD743)","title-slide-attributes":{"data-background-image":"img/highcharts.jpg","data-background-size":"contain","data-background-opacity":"0.40"},"author":"Escuela Polit√©cnica Nacional","affiliation":"Escuela Polit√©cnica Nacional","theme":["default","style.scss"],"chalkboard":true,"multiplex":false,"menu":{"side":"left","width":"normal"},"footer":"[<strong>Diego Pa√∫l Huaraca S.</strong>](...) ‚Ä¢ Semestre 2025-B","slideNumber":"c/t"}}},"projectFormats":["html"]}