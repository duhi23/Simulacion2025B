{"title":"Análisis y visualización de datos con R","markdown":{"yaml":{"title":"Análisis y visualización de datos con R","subtitle":"Simulación (IMAD743)","title-slide-attributes":{"data-background-image":"img/highcharts.jpg","data-background-size":"contain","data-background-opacity":"0.40"},"author":"Escuela Politécnica Nacional","affiliation":"Escuela Politécnica Nacional","lang":"es","language":"custom_lang.yml","format":{"revealjs":{"theme":["default","style.scss"],"chalkboard":true,"multiplex":false,"menu":{"side":"left","width":"normal"},"footer":"[<strong>Diego Paúl Huaraca S.</strong>](...) • Semestre 2025-B","slide-number":"c/t"}},"execute":{"echo":true}},"headingText":"¡Bienvenidos al curso de Simulación!","containsRefs":false,"markdown":"\n\n\n[**Dejad Excel a un lado**]{style=\"color:#444442;\"}  \n![](img/hateExcel.png){width=10%}\n\n---\n\n## ¡Hola a todos!\n\n::: columns\n::: {.column width=\"30%\"}\n![](img/me.jpeg)\n:::\n\n::: {.column width=\"70%\"}\n::: incremental\n-   [**Diego Paúl Huaraca Shagñay**]{.hl-purple}\n\n-   Ingeniero Matemático. [**Escuela Politécnica Nacional**]{.hl-yellow} (2013).\n\n-   Máster en Ciencias Actuariales y Financieras. [**Universidad de Alcalá**]{.hl-yellow} (2018).\n\n-   Consultor Analítico de Riesgo Financiero. [**BI-SCIENCES**]{.hl-green} (desde 2018).\n\n-   Docente del Departamento de Matemática. [**Escuela Politécnica Nacional**]{.hl-green} (desde 2018).\n\n-   Consultor Actuarial. [**Superintendencia de Bancos**]{.hl-green} (desde 2022).\n\n-   Socio Fundador de [**Tactary Consultoría Actuarial**]{.hl-green} (desde 2022).\n:::\n:::\n:::\n\n---\n\n## Contenido del curso \n<!-- Primera parte -->\n::: columns\n::: {.column width=\"20%\"}\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTPKIAIbhuhpU6GMjL2jBdHycULZOCEVt-XWs9Z_b0elEikNTefOLW3yk2ajknsTLsMDo4&usqp=CAU)\n:::\n\n::: {.column width=\"80%\"}\n::: incremental\n-   [**Introducción al Lenguaje R**]{.hl-red} → `{a programar se aprende programando}`.\n\n-   [**Análisis de datos**]{.hl-red} → `{tibble, dplyr}`.\n\n-   [**Visualización de datos**]{.hl-red} → `{gráficos estáticos y dinámicos}`.\n\n-   [**Desarrollo de aplicativos web**]{.hl-red} → `{shiny, shinydashboard}`.\n\n-   [**Reportería dinámica**]{.hl-red} → `{LaTeX, rmarkdown, Quarto}`.\n\n-   [**Simuladores de números aleatorios**]{.hl-yellow}  → `{base}`.\n\n:::\n:::\n:::\n\n\n## Contenido del curso\n<!-- Segunda Parte -->\n::: columns\n::: {.column width=\"20%\"}\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTPKIAIbhuhpU6GMjL2jBdHycULZOCEVt-XWs9Z_b0elEikNTefOLW3yk2ajknsTLsMDo4&usqp=CAU)\n:::\n\n::: {.column width=\"80%\"}\n::: incremental\n-   [**Simulación de variables aleatorias**]{.hl-yellow} → `{discretas y continuas}`.\n\n-   [**Simulación de vectores aleatorias**]{.hl-yellow}.\n\n-   [**Simulación de procesos estocásticos**]{.hl-yellow} → `{Markov, Weiner, etc.}`.\n\n-   [**Métodos de MonteCarlo**]{.hl-red} → `{secuenciales, inferencia estadística}`.\n\n-   [**Técnicas de Remuestreo**]{.hl-red}.\n\n-   [**Métodos de MoteCarlo en Cadenas de Markov**]{.hl-red}\n\n-   [**Aplicaciones avanzadas**]{.hl-red} → `{simulación por eventos}`.\n:::\n:::\n:::\n\n\n# Instalación del Lenguaje R\n\n[**Instalando R y RStudio**]{style=\"color:#444442;\"}\n\n---\n\n## Requisitos\n\nPara el desarrollo del curso se requiere:\n\n1.  [**Conexión a internet**]{.hl-yellow} (para la descarga de paquetes y bases de datos).\n\n2.  [**Descargar R**]{.hl-yellow}: La descarga se realiza (gratuitamente) desde el enlace: <https://cran.r-project.org/>\n\n3.  [**Descargar RStudio**]{.hl-yellow}: La descarga se realiza (gratuitamente) desde el enlace: <https://posit.co/download/rstudio-desktop/>\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/cranR.jpg){width=\"440\" fig-align=\"center\"}\n:::\n\n::: {.column width=\"50%\"}\n![](img/rstudio.jpg){width=\"440\" fig-align=\"center\"}\n:::\n:::\n\n---\n\n## Instalación de R\n\n-   [**Paso 1**]{.hl-yellow}: Ingrese al repositorio CRAN en [**https://cran.r-project.org/**](https://cran.r-project.org/){.uri} y seleccione su sistema operativo.\n\n-   [**Paso 2**]{.hl-yellow}: Para el sistema MacOs basta con hacer click en **R-4.X.Y.pkg**, y abrirlo una vez descargado. Para el sistema Windows, basta con hacer click en **install R for the first time** y después en **Download R-X.Y.Z for Windows**, una vez descargado, abrirlo como cualquier archivo de instalación.\n\n-   [**Paso 3**]{.hl-yellow}: Abrir el ejecutable e instalar el programa con todas las opciones por defecto.\n\n. . .\n\n::: callout-important\nSiempre que tengas que descargar algo del repositorio CRAN (ya sea el propio R o un paquete), [**asegúrate de tener conexión a internet**]{.hl-red}.\n:::\n\n---\n\n## CRAN\n\n- El lenguaje R se distribuye gratuitamente a través del repositorio [**Comprehensive R Archive Network (CRAN)**]{.hl-purple}  propiedad de la R Foundation for Statistical Computing.\n\n- El mantenimiento se encuentra a cargo del [**grupo R Core Team**]{.hl-purple} asistido por una gran cantidad de colaboradores internacionales.\n\n- Con la finalidad de evitar el colapso del mundo estadístico, el repositorio CRAN se refleja en [**diferentes lugares**]{.hl-purple} de todo el mundo\n\n\n![](img/CRAN.png){width=\"380\" fig-align=\"center\"}\n\n---\n\n## Funcionamiento\n\n- R es un lenguaje [**orientado a objetos**]{.hl-purple} diseñado en un entorno auténtico bajo el cual esconde su simplicidad y flexibilidad, lo cual permite a sus usuarios añadir funcionalidad mediante la definición de nuevas funciones y operadores.\n\n- R almacena sus variables, datos, funciones y resultados en la [**memoria activa (RAM)**]{.hl-purple} del computador en forma de objetos con un nombre específico y pueden ser [**modificados o manipulados**]{.hl-purple} por el usuario.\n\n::: {.column width=\"100%\"}\n![](img/FunR.png){width=\"630\" fig-align=\"center\"}\n:::\n\n\n---\n\n## Primera operación\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta.\n\nEsa «pantalla blanca» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una simple **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\" fig-align=\"center\"}\n:::\n:::\n\n. . .\n\n[**Idea**]{.hl-yellow}: a una variable llamada `a` le asignaremos el valor de `3` (escribiremos el código de abajo en la consola y daremos «enter»)\n\n```{r}\n#| code-line-numbers: \"1\"\na <- 3\n```\n\n---\n\n## Primera operación\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta.\n\nEsa «pantalla blanca» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\" fig-align=\"center\"}\n:::\n:::\n\n[**Idea**]{.hl-yellow}: definiremos otra variable llamada `b` y le asignaremos el valor `5`\n\n```{r}\n#| code-line-numbers: \"2\"\na <- 3\nb <- 5\n```\n\n. . .\n\n::: callout-note\n## Fíjate que...\n\nEn `R` usaremos `<-` como una **flecha**: la variable a la izquierda de dicha flecha recibe el valor que hay a la derecha (por ejemplo, `a <- 3`)\n:::\n\n---\n\n## Primera operación\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta.\n\nEsa «pantalla blanca» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\"}\n:::\n:::\n\n[**Idea**]{.hl-yellow}: haremos la suma `a + b` y nos devolverá su resultado\n\n```{r}\n#| code-line-numbers: \"3\"\na <- 3\nb <- 5\na + b\n```\n\n---\n\n## Instalación de RStudio\n\n`RStudio` será el [**Bloc de Notas**]{.hl-purple} que usaremos para escribir los códigos (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).\n\n-   [**Paso 1**]{.hl-yellow}: Ingrese a la página de Posit en [**https://posit.co/download/rstudio-desktop/**](https://posit.co/download/rstudio-desktop/){.uri} y seleccione la descarga gratuita.\n\n-   [**Paso 2**]{.hl-yellow}: Selecciona el ejecutable en función al sistema operativo que use.\n\n-   [**Paso 3**]{.hl-yellow}: Luego de la descarga, se apertura el ejecutable como cualquier otro programa y se instala todo por defecto.\n\n---\n\n## Organización de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo código que antes (la suma de las variables) en ella. La consola será donde [**ejecutaremos órdenes y mostraremos resultados**]{.hl-purple}.\n\n![](img/consola_rstudio.jpg){width=\"420\" fig-align=\"center\"}\n\n---\n\n## Organización de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Environment**]{.hl-yellow}: la pantalla pequeña (puedes ajustar los márgenes con el ratón a tu gusto) que tenemos en la parte superior derecha. Nos mostrará las [**variables que tenemos definidas**]{.hl-purple}.\n\n![](img/environment.jpg){width=\"380\" fig-align=\"center\"}\n\n---\n\n## Organización de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha servirá para buscar [**ayuda de funciones**]{.hl-purple}, para [**visualizar gráficos**]{.hl-purple}, así como para la [**carga de librerías**]{.hl-purple} y [**navegación**]{.hl-purple} por las carpetas del CPU.\n\n![](img/multiusos.jpg){width=\"420\" fig-align=\"center\"}\n\n# ¿Qué es R? Primeros usos\n\n[**¿Cuáles son las ventajas? Primer uso**]{style=\"color:#444442;\"}\n\n---\n\n## ¿Qué es R? ¿Por qué R?\n\n![](img/meme_barco.jpg){fig-align=\"center\"}\n\n---\n\n## ¿Qué es R? ¿Por qué R?\n\n`R` es el [**lenguaje estadístico por excelencia**]{.hl-yellow}, creado por y para estadísticos/as, con 5 ventajas fundamentales [**frente a Excel**]{.hl-red}:\n\n\n::: incremental\n-   [**Lenguaje de programación**]{.hl-yellow}: la obviedad [→ análisis [**replicables**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Gratuito**]{.hl-yellow}: la filosofía de la comunidad de `R` es el compartir código bajo **copyleft** [→ [**uso ético de dinero público**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a código ajeno, incluso al **propio código fuente** [→ [**flexibilidad y transparencia**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo mínimo, pero existen códigos de otras personas que podemos reusar (19430 [**paquetes**]{.hl-yellow} al 28/04/2023) [→ [**ahorro de tiempo**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programación (como Python) [→ [**menor curva de aprendizaje**]{.hl-purple}]{.fragment .fade-in}\n:::\n\n\n## ¿Por qué programar?\n\n-   [**Automatizar**]{.hl-yellow} → te permitirá automatizar tareas recurrentes (ejemplo: actualizar pronósticos del tiempo, actualizar informes estadísticos) de forma que solo tendrás que programarlo uno vez.\n\n-   [**Replicabilidad**]{.hl-yellow} → podrás replicar tu análisis siempre de la misma manera.\n\n-   [**Flexibilidad**]{.hl-yellow} → podrás adaptar el software a tus necesidades.\n\n-   [**Transparencia**]{.hl-yellow} → ser auditado por la comunidad.\n\n![](img/the_general_problem.png){fig-align=\"center\"}\n\n---\n\n## Idea fundamental: paquetes\n\nUna de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: códigos que otras personas han implementado para **resolver un problema**\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/paquetes.png)\n:::\n\n::: {.column width=\"65%\"}\n::: {.fragment fragment-index=\"1\"}\n-   [**Instalación**]{.hl-yellow}: descargamos los códigos de la web (necesitamos internet) → [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)\n\n```{r}\n#| eval: false\ninstall.packages(\"dplyr\")\n```\n:::\n\n::: {.fragment fragment-index=\"2\"}\n-   [**Carga**]{.hl-yellow}: indicamos qué paquetes queremos usar cada vez que iniciamos `RStudio` → [**traer el libro de la estantería**]{.hl-purple}\n\n```{r}\n#| eval: false\nlibrary(dplyr)\n```\n:::\n:::\n:::\n\n---\n\n## Idea fundamental: paquetes\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/paquetes.png)\n:::\n\n::: {.column width=\"65%\"}\nUna vez instalado, hay dos manera de usar un paquete (traerlo de la estantería)\n\n::: {.fragment fragment-index=\"1\"}\n-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesión [**todo el libro**]{.hl-purple}\n\n```{r}\n#| eval: false\nlibrary(dplyr)\n```\n:::\n\n::: {.fragment fragment-index=\"2\"}\n-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le índicamos que solo queremos una [**página concreta de ese libro**]{.hl-purple}\n\n```{r}\n#| eval: false\ndplyr::rename_if()\n```\n:::\n:::\n:::\n\n---\n\n## Paquetes: Acceso a funciones\n\n::: columns\n::: {.column width=\"22%\"}\n![](img/stringr.png)\n:::\n\n::: {.column width=\"78%\"}\nUna vez instalado y cargado el paquete, es posible indagar sobre las funciones que contiene a partir del comando `ls(\"package:_____\")`.\n\n```{r}\nlibrary(stringr)\nls(\"package:stringr\")\n```\n:::\n\n:::\n\n---\n\n## Carga de múltiples paquetes\n\nEn el caso que se requieran cargar varias librerías se puede evitar la ejecución de varias líneas de código a partir de la siguiente opción:\n```{r}\n#| eval: false\n# Listado de paquetes a cargar\npaquetes <- c(\"pckg_1\",\"pckg_2\", ... , \"pckg_n\")\n\n# Sentencia de carga\nlapply(paquetes, FUN=library, character.only=TRUE)\n```\n\n \n\n. . .\n\nCon el fin de evitar cargar las librerías más utilizadas al arranque de cada sesión, se puede automatizar esta tarea a partir del archivo `.RProfile`\n```{r}\n#| eval: false\n# Crea el archivo .RProfile en el caso que no exista\nif(!file.exists(\"~/.Rprofile\")){\n  file.create(\"~/.Rprofile\")\n} \n\n# edita el archivo .RProfile y coloca las instrucciones a ejecutar automáticamente\nfile.edit(\"~/.Rprofile\") \n```\n\n---\n\n## Respaldando información\n\nUna tarea importante dentro del análisis de datos es el respaldo de información que se pueda dar sobre ciertos resultados obtenidos, en este punto R consta de dos comandos muy útiles: `save` y `load`.\n\n \n\n. . .\n\nEl primero de ellos permite almacenar en disco los objetos que desee el usuario (almacenamiento parcial), dicho comando también puede ser configurado de tal manera que almacenen todos los objetos que se encuentra válidos en el área de trabajo.\n\n```{r}\n#| eval: false\nvector <- c(1,2,3,4,5)\nmatriz <- matrix(c(1,2,3,4,5,6), ncol = 2)\n\n# Si deseas guardar el objeto \"vector\" con el nombre \"Respaldos\"\nsave(vector, file = \"Respaldos.RData\")\n\n# para el caso que se desee almacenar todos los objetos con el nombre \"TotalRespaldos\" \nsave(list = ls(all = TRUE), file = \"TotalRespaldos.RData\")\n```\n\n---\n\n\n## Mensajes de error o advertencia\n\nDurante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera → [**te vas equivocar**]{.hl-yellow}. No solo será importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.\n\n. . .\n\n-   [**Mensajes de error**]{.hl-red}: precedidos de **«Error in...»** y serán aquellos fallos que [**impidan la ejecución**]{.hl-yellow}\n\n```{r}\n#| error: true\n\"a\" + 1 \n```\n\n. . .\n\n-   [**Mensajes de warning**]{.hl-orange}: precedidos de **«Warning in...»** son los (posibles) fallos más delicados ya que son incoherencias que [**no impiden la ejecución**]{.hl-yellow}\n\n```{r}\n#| warning: true\n# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe\nsqrt(-1)\n```\n\n---\n\n## Antes de arrancar: scripts\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/abrir_script.jpg){width=\"350\"}\n:::\n\n::: {.column width=\"65%\"}\nUn [**script**]{.hl-yellow} será el documento en el que programamos, nuestro `blog de notas` (aquí con extensión `.R`) donde escribiremos las órdenes. Para **abrir nuestro primero script**, haz click en el menú en `File < New File < R Script`.\n:::\n:::\n\n::: callout-warning\n## Cuidado\n\nEs importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habrás perdido**]{.hl-red}.\n:::\n\n---\n\n## Ejecutando el primer script\n\nAhora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros códigos**]{.hl-yellow}. ¿Cómo ejecutarlo?\n\n. . .\n\n1.  **Escribimos** el código a ejecutar.\n\n. . .\n\n2.  **Guardamos** el archivo .R haciendo click en `Save current document`.\n\n. . .\n\n3.  El código no se ejecuta salvo que se lo indiquemos. Tenemos tres opciones:\n\n-   [**Copiar y pegar**]{.hl-yellow} en consola.\n-   [**Seleccionar líneas**]{.hl-yellow} y `Ctrl+Enter`\n-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el código **completo**.\n\n---\n\n## 💻 Tu turno\n\n[**Ejecuta tu primer script**: crea un script de cero, programa lo indicado debajo y ejecútalo (de las 3 maneras posibles)]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Define una variable de nombre `a` y cuyo valor sea -1\n\n```{r}\n#| code-fold: true\na <- -1\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Añade debajo otra línea para definir una variable `b` con el valor 5. Tras ello múltiplica ambas variables\n\n```{r}\n#| code-fold: true\n#| eval: false\nb <- 5\na * b # sin guardar\nmultiplicacion <- a * b # guardado\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Modifica el código inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables.\n\n```{r}\n#| eval: false\nc <- # deberías asignarle el valor 3\nd <- # deberías asignarle el valor -1\n```\n\n```{r}\n#| code-fold: true\n#| eval: false\nc <- 3\nd <- -1\nc / d # sin guardar\ndivision <- c / d # guardado\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Asigna un valor positivo a `x` y calcula su raíz cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la función `abs()`.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx <- 5\nsqrt(x)\n\ny <- -2\nabs(y)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Usando la variable `x` ya definida, completa/modifica el código inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.\n\n```{r}\n#| eval: false\nz <- ? - ? # completa el código\nz\n```\n\n```{r}\n#| code-fold: true\n#| eval: false\nz <- x - 5\nz\n```\n:::\n\n::: callout-note\n## Toma nota\n\nComandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: líneas de código que hemos «encapsulado» bajo un nombre, y dado unos argumentos de entrada, ejecuta las órdenes (una especie de atajo).\n:::\n\n\n# Primeros datos: variables\n\n[**¿Qué tipos de datos existen?**]{style=\"color:#444442;\"}\n\n---\n\n## De la CELDA a la TABLA\n\n¿Qué [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?\n\n![](img/celdas.jpg){fig-align=\"center\"}\n\n::: incremental\n-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.\n-   [**Variable**]{.hl-yellow}: **concatenación** de valores del mismo tipo ([**vectores**]{.hl-purple}).\n-   [**Matriz**]{.hl-yellow}: concatenación de variables del **mismo tipo y longitud**.\n-   [**Tabla**]{.hl-yellow}: concatenación de variables de [**distinto tipo pero igual longitud**]{.hl-purple}\n-   [**Lista**]{.hl-yellow}: concatenación de variables de [**distinto tipo y distinta longitud**]{.hl-purple}\n:::\n\n---\n\n## Celdas: tipos de datos\n\n¿Existen [**variables más allá de los números**]{.hl-yellow}?\n\n. . .\n\nPiensa por ejemplo en los datos guardados de una persona:\n\n::: {.fragment .fade-up}\n-   La edad o el peso será un [**número**]{.hl-yellow}.\n\n```{r}\nedad <- 33\n```\n:::\n\n::: {.fragment .fade-up}\n-   Su nombre será una cadena de [**texto (string o char)**]{.hl-yellow}.\n\n```{r}\nnombre <- \"Diego\"\n```\n:::\n\n::: {.fragment .fade-up}\n-   A la pregunta «¿está usted soltero/a?» la respuesta será lo que llamamos una [**variable lógica**]{.hl-yellow} (`TRUE` si está soltero/a o `FALSE` en otro caso).\n\n```{r}\nsoltero <- FALSE\n```\n:::\n\n::: {.fragment .fade-up}\n-   Su fecha de nacimiento será precisamente eso, una [**fecha**]{.hl-yellow}.\n:::\n\n---\n\n## Variables numéricas\n\nEl dato más sencillo (ya lo hemos usado) serán las [**variables numéricas**]{.hl-yellow}\n\n```{r}\n#| eval: false\na <- 5\nb <- 2\na + b\n```\n\n```{r}\n#| echo: false\n#| include: false\na <- 5\nb <- 2\na + b\n```\n\n \n\n. . .\n\nPara saber el tipo de una variable tenemos la función `class()`\n\n```{r}\nclass(a)\n```\n\n \n\n. . .\n\nCon las variables numéricas podemos realizar las [**operaciones aritméticas**]{.hl-yellow} de una calculadora: sumar (`+`), raíz cuadrada (`sqrt()`), cuadrado (`^2`), etc.\n\n```{r}\na^2\n```\n\n---\n\n## Variables de texto\n\nImagina que además de la edad de una persona queremos guardar su nombre\n\n```{r}\nnombre <- \"Diego\"\nclass(nombre)\n```\n\n \n\n. . .\n\nLas [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones**]{.hl-red} aritméticas (sí otras operaciones como pegar o localizar patrones).\n\n```{r}\n#| error: true\nnombre + 1 # error al sumar número a texto\n```\n\n \n\n. . .\n\n::: callout-warning\n## Recuerda que...\n\nLas variables de tipo texto (character o stringr) van siempre [**entre comillas**]{.hl-orange}.\n:::\n\n---\n\n## Primera función: paste\n\nComo hemos comentado, una [**función**]{.hl-yellow} es un trozo de **código encapsulado** bajo un nombre que depende de unos argumentos de entrada. Nuestra primera función será `paste()`: dadas dos cadenas de texto nos permite pegarlas.\n\n```{r}\npaste(\"Diego\", \"Huaraca\")\n```\n\n \n\n. . .\n\nFíjate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos añadir un [**argumento opcional**]{.hl-yellow} para indicarle el separador\n\n```{r}\npaste(\"Diego\", \"Huaraca\", sep = \"*\")\n```\n\n \n\n. . .\n\n```{r}\npaste(\"Diego\", \"Huaraca\", sep = \" - \")\n```\n\n---\n\n## Primera función: paste\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/paste_help.jpg)\n:::\n\n::: {.column width=\"50%\"}\n¿Cómo saber que argumentos tiene una función? Escribiendo en consola `? paste` o alternativamente `help(\"paste\")` te aparecerá una [**ayuda**]{.hl-yellow} en el panel multiusos.\n\nEn dicha ayuda podrás ver en su cabecera que argumentos ya tiene asignados por defecto la función\n:::\n:::\n\n. . .\n\nExiste una función similar llamada `paste0()` que pega por defecto con `sep = \"\"` (sin nada).\n\n```{r}\npaste0(\"Diego\", \"Huaraca\")\n```\n\n---\n\n## Primer paquete: glue\n\nUna forma más intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos será «comprar el libro» (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}\n\n```{r}\n#| eval: false\ninstall.packages(\"glue\") # solo la primera vez\nlibrary(glue)\n```\n\n```{r}\n#| echo: false\nlibrary(glue)\n```\n\n. . .\n\nCon dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, «la edad es de ... años», donde la edad está guardada en una variable.\n\n```{r}\nedad <- 33\nglue(\"La edad es de {edad} años\")\n```\n\n. . .\n\nDentro de las llaves también podemos ejecutar operaciones\n\n```{r}\nunidades <- \"días\"\nglue(\"La edad es de {edad * 365} {unidades}\")\n```\n\n---\n\n## Variables lógicas\n\nUna [**variable lógica o binaria**]{.hl-yellow} es aquella que toma **dos valores**:\n\n-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.\n-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.\n-   `NA`: [**dato ausente**]{.hl-yellow} son las siglas de *not available*.\n\n```{r}\nsoltero <- TRUE # ¿Es soltero? --> SÍ\nclass(soltero)\n```\n\n. . .\n\n::: callout-important\n## Importante\n\nLas variables lógicas [**NO son variables de texto**]{.hl-red}: `\"TRUE\"` es un texto, `TRUE` es un valor lógico.\n\n```{r}\n#| error: true\nTRUE + 1\n\"TRUE\" + 1\n```\n:::\n\n---\n\n## Condiciones lógicas\n\nLos valores lógicos suelen ser resultado de [**evaluar condiciones lógicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos comprobar si una persona se llama Julia.\n\n```{r}\nnombre <- \"María\"\n```\n\n \n\n. . .\n\nCon el [**operador lógico**]{.hl-yellow} `==` preguntamos sí a la izquierda es igual a la derecha\n\n```{r}\nnombre == \"Julia\"\n```\n\n. . .\n\nCon su opuesto `!=` preguntamos si es distinto.\n\n```{r}\nnombre != \"Julia\"\n```\n\n. . .\n\n::: callout-note\n## Fíjate que...\n\nNo es lo mismo `<-` (asignación) que una [**comparación lógica**]{.hl-yellow} con `==` (estamos preguntando).\n:::\n\n---\n\n## Condiciones lógicas\n\nAdemás de las comparaciones «igual a» frente «distinto», también comparaciones de orden como `<, <=, > o >=`.\n\n \n\n**¿Tiene la persona menos de 32 años?**\n\n```{r}\nedad <- 38\nedad < 32 # ¿Es la edad menor de 32 años?\n```\n\n \n\n**¿La edad es mayor o igual que 38 años?**\n\n```{r}\nedad >= 38\n```\n\n---\n\n## Variables de fecha\n\nUn tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.\n\n```{r}\nfecha_char <- \"2021-04-21\"\n```\n\n. . .\n\nParece una simple cadena de texto pero [**representa un instante en el tiempo**]{.hl-yellow}. ¿Qué debería suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?\n\n```{r}\n#| error: true\nfecha_char + 1\n```\n\n. . .\n\nLas fechas [**no pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha con `as_date()` del paquete `{lubridate}`\n\n```{r}\nlibrary(lubridate) # instala si no lo has hecho\nfecha <- as_date(\"2023-03-28\")\nfecha + 1\nclass(fecha)\n```\n\n---\n\n## Variables de fecha\n\nEn dicho paquete tenemos funciones muy útiles para [**manejar fechas**]{.hl-yellow}:\n\n-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.\n\n```{r}\ntoday()\n```\n\n. . .\n\n-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}\n\n```{r}\nnow()\n```\n\n. . .\n\n-   Con `year()`, `month()` o `day()` podemos [**extraer el año, mes y día**]{.hl-purple}\n\n```{r}\nfecha <- today()\nyear(fecha)\nmonth(fecha)\n```\n\n---\n\n## Resúmenes de paquetes\n\n![](img/lubridate.png)\n\n::: callout-note\n## Amplia contenido\n\nTienes un resumen en pdf de los paquetes más importantes en la [**carpeta «fichas paquetes»**]{.hl-green}\n:::\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Define una variable que guarde tu edad y otra con tu nombre\n\n```{r}\n#| code-fold: true\nedad <- 33\nnombre <- \"Javi\"\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Define otra variable que responda la pregunta «¿tengo hermanos?» y otra con la fecha de tu nacimiento.\n\n```{r}\n#| code-fold: true\nhermanos <- TRUE\n\nlibrary(lubridate)\nfecha_nacimiento <- as_date(\"1989-09-10\")\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Define otra variable con tus apellidos y junta con `glue()` las variables `nombre` y `apellidos` (una coma entre ellos) en una sola variable `nombre_completo`.\n\n```{r}\n#| code-fold: true\n#| eval: false\napellidos <- \"Álvarez Liébana\"\nglue(\"{nombre}, {apellidos}\")\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Calcula los días que han pasado desde la fecha de tu nacimiento, haciendo la resta entre la fecha de hoy y la fecha de nacimiento definida en el ejercicio 2.\n\n```{r}\n#| code-fold: true\n#| eval: false\ntoday() - fecha_nacimiento\n```\n:::\n\n\n# Primeros datos: vectores\n\n[**¿Cómo concatenamos valores? ¿Cómo creamos una columna?**]{style=\"color:#444442;\"}\n\n---\n\n## Vectores: concatenar\n\nCuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenación**]{.hl-purple} de variables del [**mismo tipo**]{.hl-purple}\n\n \n\n. . .\n\nLa forma más sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus elementos entre paréntesis y separados por comas\n\n```{r}\nedades <- c(33, 27, 60, 61)\nedades\n```\n\n \n\n. . .\n\n::: callout-tip\nUn número individual `x <- 1` es en realidad un vector de longitud uno.\n:::\n\n---\n\n## Vectores: concatenar\n\n::: columns\n::: {.column width=\"40%\"}\n![](img/edades_environment.jpg)\n:::\n\n::: {.column width=\"60%\"}\nComo ves ahora en el `environment` tenemos una **colección de elementos** guardada\n\n```{r}\nedades\n```\n:::\n:::\n\n. . .\n\n \n\nLa [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`\n\n```{r}\nlength(edades)\n```\n\n. . .\n\nTambién podemos [**concatenar vectores**]{.hl-yellow}\n\n```{r}\nc(edades, edades, 8)\n```\n\n---\n\n## Secuencias numéricas\n\nEn muchas ocasiones querremos crear [**secuencias numéricas**]{.hl-yellow} (por ejemplo, los días del mes). El comando `seq(inicio, fin)` nos permite crear una **secuencia** desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.\n\n```{r}\nseq(1, 31)\n```\n\n \n\n. . .\n\nEl comando `1:n` nos devuelve lo mismo que `seq(1, n)` (si el elemento inicial es mayor que el final, entenderá que la secuencia es **decreciente**)\n\n```{r}\n1:5\n7:-3\n```\n\n---\n\n## Secuencias numéricas\n\nTambién podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos\n\n```{r}\nseq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5\n```\n\n. . .\n\n \n\nOtras veces nos interesará definir una [**secuencia con una longitud concreta**]{.hl-yellow}\n\n```{r}\nseq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7\n```\n\n. . .\n\n \n\nIncluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}\n\n```{r}\nrep(0, 7) # vector de 7 ceros\n```\n\n---\n\n## Vectores de caracteres\n\nUn vector es una **concatenación** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente números. Vamos a crear una frase de ejemplo.\n\n```{r}\nfrase <- \"Me llamo Diego\"\nfrase\nlength(frase)\n```\n\n \n\n. . .\n\nEn el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas\n\n```{r}\nvector <- c(\"Me\", \"llamo\", \"Diego\")\nvector\nlength(vector)\n```\n\n---\n\n## Vectores de caracteres\n\n¿Qué sucederá si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?\n\n \n\n. . .\n\n```{r}\nc(1, 2, \"Diego\", \"3\", TRUE)\n```\n\nFíjate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}\n\n \n\n. . .\n\n```{r}\nc(3, 4, TRUE, FALSE)\n```\n\nEs importante entender que los valores lógicos en realidad están [**almacenados internamente como 0/1**]{.hl-yellow}\n\n---\n\n## Operaciones con vectores\n\nCon los vectores numéricos podemos hacer las mismas [**operaciones aritméticas**]{.hl-yellow} que con los números [→ un [**número es un vector**]{.hl-purple} (de longitud uno)]{.fragment .fade-in}\n\n\n. . .\n\n¿Qué sucederá si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?\n\n. . .\n\n```{r}\nx <- c(1, 3, 5, 7)\nx + 1\nx * 2\n3 * x - 5\nx/2\n```\n\n::: callout-warning\n## Cuidado\n\nSalvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}\n:::\n\n---\n\n## Operaciones con vectores\n\nLos vectores también pueden interactuar entre ellos, así que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)\n\n```{r}\nx <- c(2, 4, 6)\ny <- c(1, 3, 5)\nx + y\n```\n\n \n\n. . .\n\nDado que la operación (por ejemplo, una suma) se realiza elemento a elemento, ¿qué sucederá si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?\n\n. . .\n\n```{r}\nz <- c(1, 3, 5, 7)\nx + z\n```\n\nLo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que hará será reciclar del vector con menor longitud.\n\n---\n\n## Operaciones con vectores\n\nUna operación muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones lógicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...\n\n[**¿Qué días hizo menos de 22 grados?**]{.hl-yellow}\n\n```{r}\nx <- c(15, 20, 31, 27, 15, 29)\n```\n\n. . .\n\n```{r}\nx < 22\n```\n\nNos devolverá un [**vector lógico**]{.hl-yellow}, en función de si **cada elemento** cumple o no la condición pedida.\n\n. . .\n\nSi tuviéramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese día), la condición evaluada también sería `NA`\n\n```{r}\ny <- c(15, 20, NA, 31, 27, 7, 29, 10)\ny < 22\n```\n\n---\n\n## Operaciones con vectores\n\nLas [**condiciones lógicas pueden ser combinadas**]{.hl-yellow} de dos maneras:\n\n-   [**Intersección**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunción y**]{.hl-purple} con `&`) para devolver un `TRUE`\n\n```{r}\nx < 30 & x > 15\n```\n\n-   [**Unión**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunción o**]{.hl-purple} con `|`)\n\n```{r}\nx < 30 | x > 15\n```\n\n. . .\n\nCon `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen\n\n```{r}\nany(x < 30)\nall(x < 30)\n```\n\n---\n\n## Operaciones con vectores\n\nTambién podemos hacer uso de [**operaciones estadísticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.\n\n```{r}\nx <- c(4, -2, 3, -7)\nsum(x)\n```\n\n \n\n[**¿Qué sucede cuando falta un dato (ausente)?**]{.hl-yellow}\n\n. . .\n\n```{r}\nx <- c(4, -2, 3, NA, -7)\nsum(x)\n```\n\nPor defecto, si tenemos un dato ausente, la [**operación también será ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`\n\n```{r}\nsum(x, na.rm = TRUE)\n```\n\n---\n\n## Operaciones con vectores\n\nComo hemos comentado que los valores lógicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritméticas.\n\n \n\nPor ejemplo, si queremos [**averiguar el número o el promedio de elementos que cumplen una condición**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendrán asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar o promediar dicho vector lógico para obtener el número de elementos que cumplen\n\n```{r}\nx <- c(-5, 7, 2, 4, 6, 9, -1)\n\n# Número de elementos que cumplen la condición\nsum(x < 3)\n\n# Promedio de elementos que cumplen la condición\nmean(x<3)\n```\n\n---\n\n## Operaciones con vectores\n\nOtras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.\n\n \n\n-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La más conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores atípicos o outliers (valores muy grandes o muy pequeños), la media se perturba con mucha facilidad.\n\n```{r}\nx <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)\nmean(x, na.rm = TRUE)\n```\n\n---\n\n## Operaciones con vectores\n\nOtras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.\n\n \n\n-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.\n\n```{r}\nx <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)\nmedian(x)\n```\n\n. . .\n\n-   [**Percentiles**]{.hl-yellow}: medidas de posición (nos dividen en partes iguales los datos).\n\n```{r}\nquantile(x) # por defecto percentiles 0-25-50-75-100\nquantile(x, probs = seq(0.1, 0.9, by = 0.1)) # deciles\n```\n\n---\n\n## Operaciones con vectores\n\nOtra operación muy habitual es la de [**acceder a elementos**]{.hl-yellow} de un vector. La forma más sencilla es usar el operador `[i]` (acceder al elemento i-ésimo)\n\n```{r}\nedades <- c(20, 30, 33, NA, 61) \nedades[3] # accedemos a la edad de la tercera persona \n```\n\n. . .\n\n \n\nDado que un número no es más que un vector de longitud uno, esta operación también la podemos aplicar usando un [**vector de índices a seleccionar**]{.hl-yellow}\n\n```{r}\ny <- c(\"hola\", \"qué\", \"tal\", \"estás\", \"?\")\ny[c(1:2, 4)] # primer, segundo y cuarto elemento\n```\n\n::: callout-tip\nPara acceder al último sin preocuparnos, podemos pasarle como índice la longitud `x[length(x)]`\n:::\n\n---\n\n## Operaciones con vectores\n\nOtras veces queremos [**eliminar algunos elementos**]{.hl-yellow}, para ello, se repite la misma operación pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-ésimo del vector sino que lo «des-selecciona»\n\n```{r}\ny\ny[-2]\n```\n\n \n\n. . .\n\nEn muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones lógicas**]{.hl-yellow}, en función de los valores, así que pasaremos como índice la propia condición (recuerda, `x < 2` nos devuelve un vector lógico)\n\n```{r}\nedades <- c(15, 21, 30, 17, 45)\nnombres <- c(\"Javier\", \"María\", \"Laura\", \"Julia\", \"Luis\")\nnombres[edades < 18] # nombres de los menores de edad\n```\n\n---\n\n## Operaciones con vectores\n\nPor último, una acción habitual es saber [**ordenar valores**]{.hl-yellow}:\n\n-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo\n\n```{r}\nedades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)\nsort(edades)\nsort(edades, decreasing = TRUE)\n```\n\n. . .\n\n-   `order()`: devuelve el [**vector de índices**]{.hl-yellow} que tendríamos que usar para tener el vector ordenado\n\n```{r}\norder(x)\nx[order(x)]\n```\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Define el vector `x` como la concatenación de los 5 primeros números impares, y calcula su suma.\n\n```{r}\n#| code-fold: true\n#| eval: false\n# Dos formas\nx <- c(1, 3, 5, 7, 9)\nx <- seq(1, 9, by = 2)\n\nsum(x)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Obtén los elementos de `x` mayores que 4. Calcula el número de elementos de `x` mayores que 4.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx[x > 4]\nsum(x > 4)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Calcula el vector `1/x` y obtén la versión ordenada (de menor a mayor).\n\n```{r}\n#| code-fold: true\n#| eval: false\nz <- 1/x\nsort(z)\nz[order(z)]\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Encuentra el máximo y el mínimo del vector `x`\n\n```{r}\n#| code-fold: true\n#| eval: false\nmin(x)\nmax(x)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx[x > 1 & x < 7]\nall(x > 0)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\n📝 Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. Elimina del vector el segundo elemento. Tras eliminarlo determina su suma y su media\n\n```{r}\n#| code-fold: true\n#| eval: false\nx <- c(1, -5, 8, NA, 10, -3, 9)\nx[c(1, 2, 5, 6)]\ny <- x[-2]\nsum(y, na.rm = TRUE)\nmean(y, na.rm = TRUE)\n```\n:::\n\n# Primera base de datos\n\n[**¿Cómo construimos una tabla? Matrices, data.frame y tibble**]{style=\"color:#444442;\"}\n\n---\n\n## Primer intento: matrices\n\nCuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una «tabla» que las recopile. La opción más inmediata son las [**matrices**]{.hl-yellow}: concatenación de variables del [**mismo tipo e igual longitud**]{.hl-purple}.\n\n. . .\n\nImagina que tenemos estaturas y pesos de 4 personas. ¿Cómo [**crear un dataset con las dos variables**]{.hl-yellow}? Con `cbind()` concatenamos en forma de columnas\n\n```{r}\nestaturas <- c(150, 160, 170, 180)\npesos <- c(60, 70, 80, 90)\ncbind(estaturas, pesos)\n```\n\n. . .\n\n \n\n[**No profundizaremos**]{.hl-red} más ya que nuestro objetivo es tener variables de misma longitud pero [**tipos diferentes**]{.hl-yellow} (pero que sepas que existen).\n\n---\n\n## Segundo intento: data.frame\n\nLas matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte\n\n```{r}\n#| code-line-numbers: \"4\"\nedades <- c(14, 24, NA)\nsoltero <- c(TRUE, NA, FALSE)\nnombres <- c(\"javi\", \"laura\", \"lucía\")\ncbind(edades, soltero, nombres)\n```\n\n \n\n. . .\n\nPara poder trabajar con [**variables de distinto tipo**]{.hl-yellow} haremos uso de lo que se conoce como [**data.frame**]{.hl-yellow}: unimos variables de igual longitud pero [**tipo distinto**]{.hl-purple}.\n\n```{r}\n#| code-line-numbers: \"1\"\ntabla <- data.frame(edades, soltero, nombres)\ntabla\n```\n\n---\n\n## Segundo intento: data.frame\n\n```{r}\ntabla\nclass(tabla)\n```\n\n \n\n. . .\n\nDado que un `data.frame` es ya una «base de datos» las variables no son meros vectores matemáticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}\n\n```{r}\nlibrary(lubridate)\ntabla <- data.frame(\"edad\" = edades, \"estado\" = soltero, \"nombre\" = nombres,\n             \"f_nacimiento\" = as_date(c(\"1989-09-10\", \"1992-04-01\", \"1980-11-27\")))\ntabla\n```\n\n---\n\n## Segundo intento: data.frame\n\n[**¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} \n\n\nPuedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`\n\n![](img/view_tabla.jpg){width=\"70%\" fig-align=\"center\"}\n\nNo se recomienda abusar del uso de la función `View()` dado que se consume demasiada memoria RAM.\n\n---\n\n## Segundo intento: data.frame\n\nSi queremos acceder a sus elementos, el operador será similar al de los vectores: ahora [**tenemos dos índices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)\n\n```{r}\ntabla[2, ]  # segunda fila (todas sus variables)\ntabla[, 3]  # tercera columna (de todos los individuos)\ntabla[2, 1]  # primera característica de la segunda persona\n```\n\n. . .\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/menu_data_frame.jpg)\n:::\n\n::: {.column width=\"65%\"}\nTambién tiene ventajas de una [**«base» de datos**]{.hl-yellow} : podemos [**acceder a las variables por su nombre**]{.hl-purple} (recomendable ya que las variables pueden cambiar de posición), poniendo el nombre de la tabla seguido del símbolo `$` (con el **tabulador**, nos aparecerá un menú de columnas a elegir)\n:::\n:::\n\n---\n\n## Segundo intento: data.frame\n\n-   `names()`: nos muestra los nombres de las variables\n\n```{r}\nnames(tabla)\n```\n\n \n\n. . .\n\n-   `dim()`: nos muestra las dimensiones (también `nrow()` y `ncol()`)\n\n```{r}\ndim(tabla)\n```\n\n \n\n. . .\n\n-   Podemos acceder a las variables por su nombre\n\n```{r}\ntabla[c(1, 3), \"nombre\"]\n```\n\n---\n\n## Intento final: tibble\n\nLas tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}\n\nLa principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC\n\n```{r}\n#| error: true\ndata.frame(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n           \"IMC\" = peso / (estatura^2))\n```\n\n\nDe ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})\n\n```{r}\nlibrary(tibble)\ntibble(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n       \"IMC\" = peso / (estatura^2))\n```\n\nUn data.frame puede ser tranformado en un tibble por medio del comando `as_tibble()`.\n\n---\n\n## Intento final: tibble\n\n```{r}\ntabla <- tibble(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n                \"IMC\" = peso / (estatura^2))\ntabla\n```\n\nLas tablas en formato `tibble` nos permitirá una [**gestión más ágil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:\n\n. . .\n\n-   [**Metainformación**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automáticamente el número de filas y columnas, y el tipo de cada variable\n\n. . .\n\n-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)\n\n---\n\n## Intento final: tibble\n\n-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning\n\n```{r}\n#| warning: true\ntabla$invent\n```\n\n. . .\n\n-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`\n\n```{r}\ntribble(~colA, ~colB,\n        \"a\",   1,\n        \"b\",   2)\n```\n\n. . .\n\n::: callout-tip\nEl paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de páginas web y documentos sencillos\n:::\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Carga del paquete `{datasets}` el conjunto de datos `airquality` (contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973). ¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviértelo a tibble (busca en la documentación del paquete en <https://tibble.tidyverse.org/index.html>).\n\n```{r}\n#| code-fold: true\n#| eval: false\nlibrary(tibble)\nclass(datasets::airquality)\nairquality_tb <- as_tibble(datasets::airquality)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Una vez convertido a `tibble` obtén el nombre de las variables y las dimensiones del conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?\n\n```{r}\n#| code-fold: true\n#| eval: false\nnames(airquality_tb)\nncol(airquality_tb)\nnrow(airquality_tb)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Filtra solo los datos del mes de agosto.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month == 8, ]\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Selecciona aquellos datos que no sean ni de julio ni de agosto.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month %in% c(7, 8), ]\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Modifica el siguiente código para quedarte solo con las variable de ozono y temperatura.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[, c(\"Ozone\", \"Temp\")]\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\n📝 Selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month == 8, c(\"Temp\", \"Wind\")]\nnames(airquality_tb) <- c(\"ozono\", \"rad_solar\", \"viento\", \"temp\", \"mes\", \"dia\") \n```\n:::\n\n# R base vs Tidyverse\n\n[**Spoiler: un multiverso de datos limpios**]{style=\"color:#444442;\"}\n\n---\n\n## R base vs Tidyverse\n\nSi conoces algún otro lenguaje de programación (o tienes gente cercana que programa) te extrañará que aún no hayamos hablado de conceptos habituales como\n\n-   [**Bucles for**]{.hl-yellow}: repetir un código un número fijo de iteraciones.\n\n-   [**Bucles while**]{.hl-yellow}: repetir un código hasta que se cumpla una condición\n\n-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el código en función del valor de las variables.\n\n \n\n. . .\n\nY aunque conocer dichas estructuras puede ser en algún momento interesante, en la [**mayoría de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles) [→ en lugar de trabajar con lo que se conoce como R Base vamos a vertebrar el curso en torno a [**Tidyverse**]{.hl-yellow}]{.fragment .fade-in}\n\n---\n\n## ¿Qué es tidyverse?\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"50%\"}\n![](img/flow_tidyverse.jpg)\n:::\n:::\n\n`{tidyverse}` es un [**«universo» de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicográficamente sencillo de entender, basado en la idea de que [**nuestros datos están limpios y ordenados (tidy)**]{.hl-purple}\n\n---\n\n## ¿Qué es tidyverse?\n\n::: columns\n::: {.column width=\"45%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"55%\"}\n-   `{tibble}`: optimizando data.frame\n-   `{tidyr}`: limpieza de datos\n-   `{readr}`: carga datos rectangulares (.txt, .csv)\n-   `{dplyr}`: gramática para depurar\n-   `{stringr}`: manejo de textos\n-   `{ggplot2}`: visualización de datos\n-   `{tidymodels}`: modelización/predicción\n:::\n:::\n\nTambién tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para variables cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.\n\n---\n\n\n## ¿Qué es tidyverse?\n\n::: columns\n::: {.column width=\"45%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"55%\"}\n-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}\n-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}\n-   `{readr}`: [**carga datos**]{.hl-yellow} rectangulares (.txt, .csv)\n-   `{dplyr}`: [**gramática para depurar**]{.hl-yellow}\n-   `{stringr}`: [**manejo de textos**]{.hl-purple}\n-   `{ggplot2}`: [**visualización de datos**]{.hl-purple}\n-   `{tidymodels}`: [**modelización/predicción**]{.hl-green}\n:::\n:::\n\nTambién tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para variables cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.\n\n---\n\n## Filosofía base: tidy data\n\n> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)\n\n<div style=\"font-size:120px; text-align: center; color:#F8DF58;\"><b>TIDY</b><span style=\"color:#CAB0EE;\"><b>VERSE</b></span></div>\n\nEl [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato de los datos para:\n\n::: incremental\n\n* [**sistematizar**]{.hl-green} la depuración\n* hacer más [**sencillo**]{.hl-green} su manipulación.\n* código [**legible**]{.hl-green}\n\n:::\n \n---\n\n## Reglas del tidy data\n\nLo primero por tanto será entender qué son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos están estandarizados.\n\n\n:::: columns\n::: {.column width=\"50%\"}\n\n::: {.fragment .fade-in}\n1. Cada [**variable**]{.hl-yellow} en una [**única columna**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n2. Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n3. Cada [**celda**]{.hl-yellow} con un [**único valor**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n4. Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n5. Si queremos cruzar [**múltiples tablas**]{.hl-yellow} debemos tener una [**columna en común**]{.hl-purple} (llave de cruce).\n:::\n:::\n::: {.column width=\"50%\"}\n![](img/tidy_def.jpg){width=\"160%\"}\n:::\n::::\n\n---\n\n## Tubería (pipe)\n\nEn `{tidyverse}` será clave el [**operador pipe (tubería)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): será una [**tubería que recorre los datos**]{.hl-yellow} y los transforma.\n\n. . .\n\n:::: columns\n::: {.column width=\"50%\"}\nEn R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, sería\n\n```{r}\n#| eval: false\nthird(second(first(datos)))\n```\n:::\n\n::: {.column width=\"50%\"}\n\nEn `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones\n\n```{r}\n#| eval: false\ndatos |> first() |> second() |> third()\n```\n\n:::\n::::\n\n&nbsp;\n\n. . .\n\n::: callout-caution\n## Apunte importante\n\nDesde la versión 4.1.0 de `R` disponemos de `|>`, un pipe **nativo**  disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que dependía del paquete `{magrittr}` (bastante problemático).\n:::\n\n---\n\n## Tubería (pipe)\n\nLa principal ventaja es que el [**código sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas código.\n\n&nbsp;\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  limpio(...) |>\n  filtro(...) |>\n  selecciono(...) |>\n  ordeno(...) |>\n  modifico(...) |>\n  renombro(...) |>\n  agrupo(...) |>\n  cuento(...) |>\n  resumo(...) |>\n  pinto(...)\n```\n:::\n\n::: {.column width=\"50%\"}\n\n<center><img src=\"img/logo_pipe.png\" width=\"360px\"/></center>\n:::\n::::\n  \n\n---\n\n## Datos SUCIOS: messy data\n\n¿Pero qué aspecto tienen los [**datos no tidy**]{.hl-yellow}? \n\nVamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).\n\n \n\n. . .\n\n```{r}\nlibrary(tidyr)\ntable4a\n```\n\n \n\n. . .\n\n[**¿Qué puede estar fallando?**]{.hl-red}\n\n---\n\n## Pivotar: pivot_longer()\n\n:::: columns\n::: {.column width=\"40%\"}\n```{r}\ntable4a\n```\n:::\n\n::: {.column width=\"60%\"}\n\n❎  Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) → las columnas `1999` y `2000` en realidad deberían ser en sí [**valores de una variable**]{.hl-yellow} y no nombres de columnas.\n:::\n::::\n\n. . .\n\nIncluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el año y otra que guarde el valor de la variable de interés en cada uno de esos años. Y lo haremos con la función `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:\n\n```{r}\ntable4a |> \n  pivot_longer(cols = c(\"1999\", \"2000\"), names_to = \"year\", values_to = \"cases\")\n```\n\n\n---\n\n## Pivotar: pivot_longer()\n\n:::: columns\n\n::: {.column width=\"50%\"}\n\n```{r}\ntable4a |> \n  pivot_longer(cols = c(\"1999\", \"2000\"),\n               names_to = \"year\",\n               values_to = \"cases\")\n```\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/table4a.jpg)\n\n:::\n::::\n\n&nbsp;\n\n* `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}\n* `names_to`: nombre de la nueva variable a la que mandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).\n* `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos otro ejemplo con la tabla `table2`\n\n&nbsp;\n\n```{r}\ntable2\n```\n\n\n&nbsp;\n\n[**¿Qué puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Pivotar: pivot_wider()\n\n:::: columns\n::: {.column width=\"60%\"}\n```{r}\n#| echo: false\ntable2\n```\n:::\n\n::: {.column width=\"40%\"}\n\n❎ Cada [**observación está dividido en dos filas**]{.hl-red} → los [**registros con el mismo año deberían ser el mismo**]{.hl-yellow}\n\n:::\n::::\n\n. . .\n\nLo que haremos será lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}\n\n```{r}\ntable2 |>  pivot_wider(names_from = type, values_from = count)\n```\n\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos otro ejemplo con la tabla `table3`\n\n&nbsp;\n\n```{r}\ntable3\n```\n\n\n&nbsp;\n\n[**¿Qué puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Separar: separate()\n\n:::: columns\n::: {.column width=\"60%\"}\n```{r}\ntable3\n```\n:::\n\n::: {.column width=\"40%\"}\n\n❎ Cada [**celda contiene varios valores**]{.hl-red} \n\n:::\n::::\n\n. . .\n\nLo que haremos será hacer uso de la función `separate()` para mandar a [**separar cada valor**]{.hl-yellow} a una columna diferente.\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"))\n```\n\n---\n\n## Separar: separate()\n\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"))\n```\n\nFíjate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deberían ser variables numéricas. Para ello podemos añadir el argumento opcional `convert = TRUE`\n\n. . .\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"), convert = TRUE)\n```\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos el último ejemplo con la tabla `table5`\n\n&nbsp;\n\n```{r}\ntable5\n```\n\n\n&nbsp;\n\n[**¿Qué puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Unir unite()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\ntable5\n```\n:::\n\n::: {.column width=\"50%\"}\n\n❎ Tenemos [**mismos valores divididos en dos columnas**]{.hl-red} \n\n:::\n::::\n\n. . .\n\nUsaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y año en una misma columna\n\n```{r}\ntable5 |> unite(col = year_completo, century, year, sep = \"\")\n```\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\ntable4b |>\n  pivot_longer(cols = \"1999\":\"2000\", names_to = \"year\",\n               values_to = \"cases\")\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\nrelig_income |>\n  pivot_longer(cols = \"<$10k\":\"Don't know/refused\",\n               names_to = \"income\",\n               values_to = \"people\")\n```\n\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\nbillboard |>\n  pivot_longer(cols = \"wk1\":\"wk76\",\n               names_to = \"week\",\n               names_prefix = \"wk\",\n               values_to = \"position\",\n               values_drop_na = TRUE)\n```\n\n:::\n\n# Introducción a Tidyverse\n\n[**Con los datos limpios, podemos trabajarlos**]{style=\"color:#444442;\"}\n\n---\n\n## Preprocesamiento: dplyr\n\nDentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuración**]{.hl-yellow} de datos de datos.\n\n:::: columns\n::: {.column width=\"65%\"}\n![](img/dplyr.png)\n:::\n\n::: {.column width=\"35%\"}\n```{r}\n#| eval: false\ndatos |>\n  limpio(...) |>\n  filtro(...) |>\n  selecciono(...) |>\n  ordeno(...) |>\n  modifico(...) |>\n  renombro(...) |>\n  agrupo(...) |>\n  cuento(...) |>\n  resumo(...) |>\n  pinto(...)\n```\n:::\n::::\n\n---\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\nUna de las operaciones más comunes es [**filtrar registros**]{.hl-yellow} en base a alguna condición lógica: con `filter()` se seleccionarán solo individuos que cumplan ciertas condiciones.\n\n::: incremental\n\n* `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-purple} que\n* `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-purple} que\n* `>=`, `<=`: [**mayor o igual**]{.hl-purple} o [**menor o igual**]{.hl-purple} que\n* `%in%`: valores [**pertenencen**]{.hl-purple} a un listado de opciones\n* `between(variable, val1, val2)`: si los valores (normalmente continuos) [**caen dentro de un rango**]{.hl-purple} de valores\n\n:::\n\n---\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| echo: false\n#| include: false\nlibrary(tidyverse)\ndata(\"starwars\")\n```\n\n```{r}\n#| eval: false\nstarwars |>  dplyr::filter(eye_color == \"brown\")\n```\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(eye_color != \"brown\")\n```\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(eye_color %in% c(\"blue\", \"brown\"))\n```\n\n\n::: callout-tip\n\n## Importante\nRecuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores lógicos**]{.hl-green}.\n\n:::\n\n---\n\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(between(height, 120, 160))\n```\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |>\n   filter(eye_color == \"brown\" & species != \"Human\")\n```\n\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan más de 60 años**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |>\n  filter((eye_color == \"brown\" & species != \"Human\") | birth_year > 60)\n```\n\n  \n---\n\n## Eliminar ausentes: drop_na()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  retirar_ausentes(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  drop_na(var1, var2, ...)\n```\n:::\n::::\n\nHay un filtro especial que es el de [**retirar los ausentes**]{.hl-yellow}, para lo cual podemos usar `filter(is.na(variable))` o directamente `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquiera de las variables.\n\n. . .\n\n&nbsp;\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> drop_na(mass, height)\n```\n\n```{r}\n#| echo: false\nstarwars |>\n  drop_na(mass, height, sex) |> \n  select(name, mass, height, hair_color) |> \n  slice(1:7)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> drop_na()\n```\n\n```{r}\n#| echo: false\nstarwars |>\n  drop_na() |> \n  select(name, mass, height, hair_color) |> \n  slice(1:7)\n```\n\n:::\n::::\n\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido\n \n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(species == \"Droid\" | is.na(species))\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Selecciona del conjunto de starwars solo los personajes cuyo peso esté entre 65 y 90 kg.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> filter(between(mass, 65, 90))\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na() |> \n  filter(species == \"Human\" & homeworld == \"Tatooine\")\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter((species != \"Human\" & sex == \"male\" &\n            between(height, 120, 170)) |\n           eye_color %in% c(\"brown\", \"red\"))\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝  Busca información en la ayuda de la función `str_detect()` del paquete `{stringr}` (cargado en `{tidyverse}`). Consejo: prueba antes las funciones que vayas a usar con algún vector de prueba para poder comprobar su funcionamiento. Tras saber lo que hace, filtra solo aquellos personajes con apellido `Skywalker`\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> filter(str_detect(name, \"Skywalker\"))\n```\n\n:::\n\n---\n\n## Rebanadas de datos: slice()\n\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> rebanadas(posiciones)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(posiciones)\n```\n:::\n::::\n\nNormalmente filtraremos condición pero a veces nos puede interesar [**filtrar por posición**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de índices**]{.hl-yellow}\n\n. . .\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(1)\n```\n\n```{r}\n#| echo: false\nstarwars |> slice(1) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(7:9)\n```\n\n```{r}\n#| echo: false\nstarwars |> slice(7:9) |> select(name:hair_color)\n```\n:::\n::::\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> slice(c(2, 7, 10, 31))\n```\n\n\n```{r}\n#| echo: false\nstarwars |> slice(c(2, 7, 10, 31)) |> select(name:sex)\n```\n\n---\n\n## Rebanadas de datos: slice()\n\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> rebanadas(posiciones)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(posiciones)\n```\n:::\n::::\n\nDisponemos de opciones por defecto: con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_head(n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_head(n = 2) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%}\n```{r}\n#| eval: false\nstarwars |> slice_tail(n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_tail(n = 2) |> select(name:hair_color)\n```\n:::\n::::\n\n. . .\n\nCon `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`).\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_min(mass, n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_max(height, n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)\n```\n:::\n::::\n\n\n---\n\n\n## Reordenar filas: arrange()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> ordenar(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> arrange(var1, var2, ...)\n```\n:::\n::::\n\nTambién podemos [**ordenar filas**]{.hl-yellow} en función de alguna variable con `arrange()`\n\n```{r}\n#| eval: false\nstarwars |> arrange(mass)\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) \n```\n\n. . .\n\nPor [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`\n\n:::: columns\n::: {.column width=\"50%\"}\n\n```{r}\n#| eval: false\nstarwars |> arrange(desc(height))\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) \n```\n:::\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> arrange(mass, desc(height))\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) \n```\n:::\n::::\n\n---\n\n## Eliminar duplicados: distinct()\n\nMuchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`. \n\n```{r}\nstarwars |> distinct(sex)\n```\n\n. . .\n\nPara mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.\n\n```{r}\n#| eval: false\nstarwars |> distinct(sex, .keep_all = TRUE)\n```\n\n```{r}\n#| echo: false\nstarwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)\n```\n\n\n---\n\n## Añadir filas: bind_rows()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ntibble1 |> encuadernar_filas(tibble2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ntibble1 |> bind_rows(tibble2)\n```\n:::\n::::\n\nPor último, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)\n\n\n```{r}\ndatos <-\n  tibble(\"nombre\" = c(\"javi\", \"laura\"), \"edad\" = c(33, 50))\ndatos\n```\n\n\n. . .\n\n```{r}\ndatos |> bind_rows(tibble(\"nombre\" = c(\"carlos\", NA), \"cp\" = c(28045, 28019)))\n```\n\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Selecciona solo los personajes que sean humanos y de ojos marrones, para después ordernarlos en altura descendente y peso ascendente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(eye_color == \"brown\" & species == \"Human\") |> \n  arrange(height, desc(mass))\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n\n📝 Extrae 3 registros aleatoriamente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_sample(n = 3)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n\n📝 Extrae el 10% de los registros aleatoriamente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_sample(prop = 0.1)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (más pesados, más probable)\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(mass) |> \n  slice_sample(n = 10, weight_by = mass)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Selecciona los 3 personajes más mayores.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_max(birth_year, n = 3)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\n📝 Para saber que valores únicos hay en el color de pelo, elimina duplicados de la variable `hair_color`, eliminando antes los ausentes de dicha variable.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(hair_color) |> \n  distinct(hair_color)\n```\n\n### [**Ejercicio 7**]{.hl-yellow}\n\n📝 De los personajes que son humanos y miden más de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 más altos, y orden de mayor a menor peso. Devuelve la tabla.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(species == \"Human\" & height > 160) |> \n  distinct(eye_color, .keep_all = TRUE) |> \n  drop_na(mass) |> \n  slice_max(height, n = 3) |> \n  arrange(desc(mass))\n```\n\n\n:::\n\n---\n\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\nLa opción más sencilla para [**seleccionar variables por nombre**]{.hl-yellow} es  `select()`, dando como argumentos los nombres de columnas sin comillas.\n\n```{r}\nstarwars %>% select(name, hair_color)\n```\n\n---\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nLa función `select()` nos permite seleccionar varias variables a la vez [**concatenando sus nombres como si fuesen índices**]{.hl-yellow}\n\n```{r}\n#| eval: false\nstarwars |> select(name:eye_color) \n```\n\n```{r}\n#| echo: false\nstarwars |> select(name:eye_color) |> slice(1:4)\n```\n\n. . .\n\nY podemos [**deseleccionar columnas**]{.hl-yellow} con `-`\n\n```{r}\n#| eval: false\nstarwars |>  select(-mass, -(eye_color:starships))\n```\n\n```{r}\n#| echo: false\nstarwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)\n```\n\n\n---\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\nTenemos además [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...\n\n```{r}\n#| eval: false\nstarwars |> select(mass, homeworld, everything())\n```\n\n```{r}\n#| echo: false\nstarwars |> select(mass, homeworld, everything()) |> slice(1:4)\n```\n\n. . .\n\n...y `last_col()` para referirnos a [**la última columna**]{.hl-purple}.\n\n```{r}\n#| eval: false\nstarwars |> select(name:mass, homeworld, last_col())\n```\n\n```{r}\n#| echo: false\nstarwars |> select(name:mass, homeworld, last_col()) |> slice(1:4)\n```\n\n---\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nPodemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresión regular**]{.hl-purple} (`matches()`).\n\n\n```{r}\n# variables cuyo nombre acaba en \"color\" y contengan sexo o género\nstarwars |> select(ends_with(\"color\"), matches(\"sex|gender\"))\n```\n\n\n---\n\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nIncluso podemos [**seleccionar por rango numérico**]{.hl-yellow} si tenemos variables con un prefijo y números.\n\n```{r}\ndatos <-\n  tibble(\"semana1\" = c(115, 141, 232), \"semana2\" = c(7, NA, 17),\n         \"semana3\" = c(95, 162, NA), \"semana4\" = c(11, 19, 15),\n         \"semana5\" = c(NA, 262, 190), \"semana6\" = c(21, 15, 23))\n```\n\n\n. . .\n\nCon `num_range()` podemos seleccionar con un prefijo y una secuencia numérica.\n\n```{r}\ndatos |> select(num_range(\"semana\", 1:4))\n```\n\n---\n\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nPor último, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una función que devuelva un valor lógico de tipo de dato.\n\n```{r}\n# Solo columnas numéricas o de texto\nstarwars |> select(where(is.numeric) | where(is.character))\n```\n\n---\n\n\n## Mover columnas: relocate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  recolocar(var1, despues_de = var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  relocate(var1, .after = var2)\n```\n:::\n::::\n\nPara facilitar la [**recolocación de variables**]{.hl-yellow} tenemos una función para ello, `relocate()`, indicándole en `.after` o `.before` [**detrás**]{.hl-purple} o [**delante**]{.hl-purple} de qué columnas queremos moverlas.\n\n```{r}\nstarwars |> relocate(species, .before = name)\n```\n\n\n\n---\n\n## Renombrar: rename()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> renombrar(nuevo = antiguo)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> rename(nuevo = antiguo)\n```\n:::\n::::\n\nA veces también podemos querer [**modificar la «metainformación»**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.\n\n```{r}\nstarwars |> rename(nombre = name, altura = height, peso = mass)\n```\n\n---\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\nEn muchas ocasiones queremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.\n\n```{r}\nstarwars |> mutate(height_m = height / 100)\n```\n\n---\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\nAdemás con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}\n\n```{r}\nstarwars |> \n  mutate(height_m = height / 100,\n         IMC = mass / (height_m^2), .before = name)\n```\n\n---\n\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\n::: callout-important\n## Importante...\n\nCuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la función que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolverá una constante**]{.hl-red}\n:::\n\n. . .\n\n```{r}\nstarwars |> \n  mutate(constante = mean(mass, na.rm = TRUE), .before = name)\n```\n\n\n---\n\n## Recategorizar: if_else()\n\nTambién podemos combinar `mutate()` con la expresión de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condición**]{.hl-purple}, hace una cosa, en caso contrario otra.\n\n```{r}\nstarwars |> \n  mutate(human = if_else(species == \"Human\", \"Human\", \"Not Human\"),\n         .after = name) |> \n  select(name:mass)\n```\n\n\n---\n\n## Recategorizar: case_when()\n\nPara [**recategorizaciones más complejas**]{.hl-yellow} tenemos  `case_when()`, por ejemplo, para crear una categoría de los personajes en función de su altura.\n \n```{r}\nstarwars |> \n  drop_na(height) |> \n  mutate(altura = case_when(height < 120 ~ \"enanos\",\n                            height < 160 ~ \"bajito\",\n                            height < 180 ~ \"normal\",\n                            height < 200 ~ \"alto\",\n                            TRUE ~ \"gigante\"), .before = name)\n```\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Selecciona solo las variables nombre, altura y así como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.\n \n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(name, height, contains(\"color\")) |> \n  drop_na(height)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(name, height, contains(\"color\")) |> \n  drop_na(height) |> \n  rename(nombre = name, altura = height,\n         color_pelo = eye_color, color_piel = skin_color,\n         color_pelo = hair_color)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detrás de la variable de nombres.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  select(name, height, contains(\"color\")) |> \n  drop_na(height) |> \n  rename(nombre = name, altura = height,\n         color_pelo = eye_color, color_piel = skin_color,\n         color_pelo = hair_color) |> \n  relocate(color_pelo, .after = nombre)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Con los datos originales, comprueba cuántas modalidades únicas hay en la variable de color de pelo.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  distinct(hair_color) |> \n  nrow()\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Del dataset original, selecciona solo las variables numéricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(where(is.numeric) | where(is.character)) |> \n  mutate(under_18 = birth_year < 18)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\n📝 Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  mutate(auburn = str_detect(hair_color, \"auburn\"))\n```\n\n### [**Ejercicio 7**]{.hl-yellow}\n\n📝 Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  mutate(IMC = mass / ((height/100)^2),\n         IMC_recat = case_when(species != \"Human\" ~ NA,\n                               IMC < 18 ~ \"delgadez\",\n                               IMC < 30 ~ \"normal\",\n                               TRUE ~ \"sobrepeso\"),\n         .after = name)\n```\n\n:::\n\n---\n\n## Contar: count()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> contar(var1, var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> count(var1, var2)\n```\n:::\n::::\n\nHasta ahora solo hemos transformado o consultado los datos pero no hemos generado estadísticas. Empecemos por lo sencillo: [**¿cómo contar (frecuencias)?**]{.hl-yellow}\n\n. . .\n\nCuando lo usamos en solitario `count()` nos devolverá simplemente el número de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**número de elementos de cada modalidad**]{.hl-purple}. \n\n```{r}\nstarwars |> count(sex)\n```\n\n---\n\n## Contar: count()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> contar(var1, var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> count(var1, var2)\n```\n:::\n::::\n\nAdemás si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolverá el [**conteo ordenado**]{.hl-purple} (más frecuentes primero).\n\n```{r}\nstarwars |> count(sex, gender, sort = TRUE)\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\nUna de las [**funciones más potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitirá [**agrupar nuestros registros**]{.hl-yellow} previamente\n\n```{r}\nstarwars |> \n  group_by(sex) |>\n  count() |>\n  ungroup()\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\nCuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificará las acciones futuras: las [**operaciones se aplicarán a cada subtabla por separado**]{.hl-purple}\n\n. . .\n\nPor ejemplo, imaginemos que queremos extraer el personaje más alto con `slice_max()`.\n\n```{r}\nstarwars |> slice_max(height)\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\n¿Y si queremos [**extraer el personaje más alto pero...de cada uno de los sexos**]{.hl-yellow}?\n\n. . .\n\n```{r}\nstarwars |>\n  group_by(sex) |> \n  slice_max(height) |> \n  ungroup()\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\n:::: columns\n::: {.column width=\"50%\"}\n![](img/tidydatatutor_1.jpg)\n:::\n\n::: {.column width=\"50%\"}\n![](img/tidydatatutor_2.jpg)\n:::\n::::\n\nLa web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)\n\n---\n\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |>\n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |>\n  ungroup()\n```\n:::\n::::\n\n::: callout-important\n## Importante\nRecuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada\n:::\n\n. . .\n\nEn la nueva versión de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`\n\n```{r}\n#| eval: false\nstarwars |> slice_max(height, by = sex)\n```\n\n.\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> slice_max(height, by = sex) |> select(name:eye_color)\n```\n\n---\n\n## Fila-a-fila: rowwise()\n\nUna opción muy útil usada antes de una operación también es `rowwise()`: toda [**operación que venga después se aplicará en cada fila por separado**]{.hl-yellow}. Por ejemplo, vamos a definir un conjunto dummy de notas.\n\n```{r}\nnotas <- tibble(\"mates\" = c(7.5, 8, 9.1, 3),\n                \"lengua\" = c(8, 6, 6.5, 9.2))\n```\n\n. . .\n\nSi aplicamos la media directamente el valor será idéntico ya que nos ha hecho la media global, pero nos gustaría sacar una [**media por registro**]{.hl-yellow}. Para eso usaremos `rowwise()`\n\n```{r}\nnotas |> \n  rowwise() |> \n  mutate(media_curso = mean(c(mates, lengua)))\n```\n\n\n---\n\n## Resumir: summarise()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> summarise()\n```\n:::\n::::\n\nPor último tenemos `summarise()`, que nos permitirá sacar resúmenes estadísticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.\n\n```{r}\nstarwars |> \n  drop_na(height) |> \n  summarise(media_altura = mean(height))\n```\n\n. . .\n\n::: callout-warning\n## Cuidado\nFíjate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que esté indicado.\n:::\n\n---\n\n## Resumir: summarise()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> summarise()\n```\n:::\n::::\n\nSi además esto lo [**combinamos con la agrupación**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas líneas de código puedes obtener [**estadísticas desagregadas**]{.hl-purple}\n\n```{r}\nstarwars |> \n  drop_na(sex, height, mass) |> \n  summarise(media_altura = mean(height),\n            media_peso = mean(mass),\n            .by = sex)\n```\n\n---\n\n## Resumir: reframe()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> reframe()\n```\n:::\n::::\n\nEn el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos más de un valor por variable**]{.hl-yellow}.\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: true\nstarwars |>\n  drop_na(mass) |>\n  summarise(quantile(mass))\n```\n:::\n::: {.column width=\"50%\"}\n```{r}\n#| eval: true\nstarwars |>\n  drop_na(mass) |>\n  reframe(quantile(mass))\n```\n:::\n::::\n\n---\n\n## Selectores: across()\n\nUn truco es [**hacer uso de selectores**]{.hl-yellow} `across` y `where`. El primero nos permite [**actuar sobre varias columnas por  nombre**]{.hl-purple} (con `mutate` o `summarise`)\n\n```{r}\nstarwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)\n```\n\n. . .\n\nEl segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.\n\n```{r}\nstarwars |> \n  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))\n```\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Calcula cuántos personajes hay de cada especie, ordenados de más a menor frecuencia.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> count(species, sort = TRUE)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Tras eliminar ausentes en las variables de peso y estatura, añade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(mass, height) |> \n  mutate(IMC = mass / ((height/100)^2)) |> \n  summarise(IMC_medio = mean(IMC), .by = sex)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Obtén el personaje más joven por cada sexo.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  slice_min(birth_year, by = sex)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Obtén la edad del personaje más joven y más viejo de cada sexo.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(birth_year) |>\n  summarise(min(birth_year), max(birth_year), .by = sex)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Determina la cantidad de personajes en cada década (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  count(birth_decade = round(birth_year, -1))\n```\n\n:::\n\n\n# Caso real: datos de encuestas\n\n[**Pongamos en práctica lo aprendido...**]{style=\"color:#444442;\"}\n\n---\n\n## Caso real: datos de encuestas\n\nEl paquete `{readr}` (ya en `{tidyverse}`) nos permite realizar una carga más ágil y más inteligente que el `read.csv()` de base (lo importa a un `tibble` e interpreta bien el tipo de cada variable, incluso fechas)\n\n```{r}\n#| echo: false\n#| eval: false\nencuestas <- read_csv(file = \"./datos/historical_surveys.csv\")\nencuestas <-\n  encuestas |>\n  mutate(cod_elec = \"02\") |> \n  select(type_survey, date_elec, id_pollster, pollster,\n         media, field_date_from, field_date_to, exit_poll,\n         size, turnout, abbrev_candidacies, est_vote) |> \n  pivot_wider(names_from = \"abbrev_candidacies\",\n              values_from = \"est_vote\")\nwrite_csv(encuestas, file = \"./datos/historical_surveys.csv\")\n```\n\n```{r}\nencuestas <- read_csv(file = \"./datos/historical_surveys.csv\")\nencuestas\n```\n\n---\n\n## Caso real: datos de encuestas\n\nLo [**primero que debes hacer**]{.hl-yellow} es visualizar con `View()` la tabla para entenderla\n\n. . .\n\n* [**Primera tarea**]{.hl-purple}: crea una variable llamada `id_survey` que nos permita identificar a cada encuesta. ¿Qué podríamos concatenar?\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |> \n  # Creamos un id con type_survey-date_elec-id_pollster\n  # con .before la ponemos delante de everything(), de todo (1ª col)\n  mutate(id_survey = glue(\"{type_survey}-{date_elec}-{id_pollster}\"),\n         .before = everything())\n```\n\n---\n\n## Caso real: datos de encuestas\n\n* [**Segunda tarea**]{.hl-purple}: usando la variable `id_survey` creada elimina duplicados.\n\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |>\n  # Eliminamos duplicados por id_survey, pero mantenemos todas las\n  # columnas con .keep_all = TRUE\n  distinct(id_survey, .keep_all = TRUE)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n* [**Tercera tarea**]{.hl-purple}: tenemos una variable `media` que representa el medio en el que se publicó o encargo la encuesta. Elimina dicha variable, así como el tipo de encuesta y el id de la encuestadora\n\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |> \n  # Eliminamos las columnas pedidas con un -\n  # las concateno para usar solo un - para todas\n  select(-c(type_survey, id_pollster, media))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Cuarta tarea**]{.hl-purple}: quédate solo con las encuestas cuyo tamaño muestral conozcamos y que no sean encuestas a pie de urna. Elimina esta última variable.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # eliminar ausentes\n  drop_na(size) |> \n  # Filtramos encuestas (registros) a pie de urna (aquellas que exit_poll == FALSE)\n  dplyr::filter(!exit_poll) |> \n  # Quitamos la variable pie de urna\n  select(-exit_poll)\n```\n\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Quinta tarea**]{.hl-purple}: convierte el dataset en tidydata. ¿Qué falla? ¿Cómo arreglarlo? Reminder: no queremos ausentes.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Convertimos a tidydata\n  pivot_longer(cols = -(id_survey:turnout),\n               names_to = \"partido\",\n               values_to = \"est_voto\",\n               values_drop_na = TRUE)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Sexta tarea**]{.hl-purple}: calcula el número de días que la encuesta ha hecho trabajo de campo, y coloca dicha columna tras el nombre de la encuestadora. Tras ello elimina aquellas encuestas que tengan 0 días de trabajo de campo.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Calculamos los días de campo como la diferencia de fechas \n  # con as.numeric() convertimos la dif. de fechas a un número\n  mutate(n_dias_campo = as.numeric(field_date_to - field_date_from),\n         .after = pollster) |> \n  # Solo aquellas cuyo trabajo de campo haya durado 1 día o más\n  dplyr::filter(n_dias_campo > 0)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Séptima tarea**]{.hl-purple}: calcula el número de días que faltan hasta las elecciones desde que la encuesta cerro el trabajo de campo y coloca dicha variable tras `n_dias_campo`. Tras ello elimina las fechas de inicio y fin de trabajo de campo de la manera más eficiente posible\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Calculamos los días que faltan a las elecciones\n  # con as.numeric() convertimos la dif. de fechas a un número\n  mutate(n_dias_elec = as.numeric(date_elec - field_date_to),\n         .after = n_dias_campo) |> \n  # Eliminamos ya las fechas de campo que no necesitamos\n  select(-contains(\"field\"))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Octava tarea**]{.hl-purple}: elimina encuestas que se hayan cerrado dentro de la ventana temporal en la que está prohibido la publicación de encuestas (no se deberían usar para predecir ya que «no se conocen»)\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |>\n  # Solo con encuestas antes del baneo electoral\n  dplyr::filter(n_dias_elec > 15)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Novena tarea**]{.hl-purple}: obtén, por cada elección, la media de las encuestas de cada partido\n\n```{r}\n#| code-fold: true\nencuestas |>\n  # Resumen: media de voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\"))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Décima tarea**]{.hl-purple}: realiza lo mismo que la tarea anterior pero solo para las encuestas de los 60 días previos a las elecciones. Ordena la salida de reciente a antiguo\n\n```{r}\n#| code-fold: true\nencuestas |>\n  # Filtramos ventana de 60 días\n  dplyr::filter(n_dias_elec <= 60) |>\n  # Media de est_voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\")) |>\n  # Ordenar de mayor a menor\n  arrange(desc(date_elec))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Undécima tarea**]{.hl-purple}: del dataset generado en el anterior ejercicio, obtén el primer y el segundo con mayor estimación de voto (en promedio)\n\n```{r}\n#| code-fold: true\nencuestas |> \n  # Filtramos ventana de 60 días\n  dplyr::filter(n_dias_elec <= 60) |> \n  # Media de est_voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\")) |>\n  # Ordenar de mayor a menor por fecha\n  arrange(desc(date_elec)) |>\n  # extraemos los dos con más est de voto (por cada fecha)\n  slice_max(media_voto, n = 2, by = date_elec)\n```\n\n# El mundo Github\n\n[**Trabajar ordenados, publicar resultados, replicabilidad de lo realizado**]{style=\"color:#444442;\"}\n\n---\n\n## ¿Qué es Github?\n\n[**GitHub**]{.hl-yellow} es la plataforma colaborativa más conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}\n\n. . .\n\n* [**¿Qué es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programación colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.\n\n. . .\n\n* [**¿Qué es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servirá no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcción de nuestros proyectos de código.\n\n. . .\n\n::: callout-important\n## Importante\n\nDesde el 4 de junio de 2018 Github es de Microsoft (ergo el código que subas también)\n\n:::\n\n---\n\n## Visión general\n\nTras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un círculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto\n\n:::: columns\n::: {.column width=\"55%\"}\n\n![](img/github_1.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"45%\"}\n* [**Edit profile**]{.hl-purple}: nos permite añadir una [**descripción y foto de perfil**]{.hl-yellow}.\n\n* [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizará nuestra actividad**]{.hl-yellow} a lo largo del tiempo.\n\n\n* [**Repositories**]{.hl-purple}: el códugo será subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.\n\n:::\n::::\n\n---\n\n## Primer uso: consumidor\n\nAntes de aprender como crear repositorios, Github también nos servirá para\n\n* [**Acceder a código**]{.hl-purple} ajeno\n* [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos\n\n. . .\n\n* [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente «amplio» para poder ser subido como paquete.\n\nEl código de paquetes que no tengamos subido en CRAN podremos [**instalarlo como código desde Github**]{.hl-yellow}\n\n---\n\n## Instalar desde Github\n\n\nPor ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya única función es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**álbumes de música urbana**]{.hl-yellow}\n\n:::: columns\n::: {.column width=\"50%\"}\n\n![](img/perrreo.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/rosalia.png){width=\"360\" fig-align=\"center\"}\n:::\n::::\n\n. . .\n\nPara ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitirá la instalación desde Github\n\n```{r}\n#| eval: false\ninstall.packages(\"devtools\")\n```\n\n---\n\n## Instalar desde Github\n\nLas [**instrucciones de instalación**]{.hl-yellow} suelen venir detalladas en la portada del repositorio\n\n:::: columns\n::: {.column width=\"50%\"}\n\n![](img/install_perreo.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/rosalia.png){width=\"310\" fig-align=\"center\"}\n:::\n::::\n\n. . .\n\nEn la mayoría de casos bastará con la función `install_github()` (del paquete que acabamos de instalar), pasándole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin \"github.com/\"). \n\n```{r}\n#| eval: false\ndevtools::install_github(\"jbgb13/peRReo\")\n```\n\n\nYa puedes perrear con ggplot ;)\n\n\n---\n\n## Descargar desde Github\n\nLa mayoría de veces lo que subamos no será un paquete de R como tal sino que [**subiremos un código más o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.\n\nPor ejemplo, vamos a descargarnos los scripts de `tidytable` que ha subido Hadley Wickham [TIDY:TABLE](https://github.com/hadley/tidytable)\n\n![](img/ceo_github.png){fig-align=\"center\"}\n\n---\n\n## Nuestro primer repositorio\n\nPara [**crear nuestro primero repositorio**]{.hl-yellow} que servirá además como [**carta de presentación**]{.hl-yellow} de nuestro perfil en Github, deberás tener una cuenta ya creada en [Github](https://github.com) y tener [Git](https://git-scm.com) instalado.\n\n\n1. Teniendo lo anterior ya realizado, podemos usar la librería [**usethis**]{.hl-purple} para simplificar el proceso.\n\n```{r}\n#| eval: false\ninstall.packages(\"usethis\")\n```\n\n2. Luego configuramos nuestras credenciales (los datos que usamos para la cuenta de GitHub):\n```{r}\nusethis::use_git_config(\n   user.name = \"Mi nombre\",\n   user.email = \"micorreo@gmail.com\"\n )\n```\n\n\n---\n\n## Nuestro primer repositorio\n\n3. Creamos nuestro GitHub PAT Token (es como una contraseña, pero más segura). \n\n```{r}\n#| eval: false\nusethis::create_github_token()\n```\n\nCuando ejecutas este comando, se te abrirá una pestaña de tu navegador. Tendrás que verificar algunos permisos a GitHub. Luego, en la configuración del token, cambia el nombre, ajusta el tiempo de expiración y el resto déjalo como está. Crea el token.\n\n4. Para guardar tu nuevo token, usa:\n\n```{r}\n#| eval: false\ngitcreds::gitcreds_set()\n```\n\nEn la consola se te mostrará un menú. Selecciona la opción 2: **Replace these credentials**. Luego copia el token de GitHub, actualiza y guarda tus credenciales.\n\n\n---\n\n\n## Nuestro primer repositorio\n\n5. Reinicia la sesión de RStudio para que [**se hagan efectivos los cambios**]{.hl-yellow}. Usualmente puedes usar **CTRL + SHIFT + F10** o del menú de arriba selecciona la pestaña de **Session** y luego **Restart R**.\n\n6. Usa `usethis::git_sitrep()` para verificar si tus credenciales como nombre, email y PAT están correctamente configuradas.\n\nFíjate que salga este texto: \n\n**Personal access token for https://github.com ... **\n\nCon eso ya deberíamos estar listos con la configuración de GIT y GitHub.\n\n\n---\n\n## Nuestro primer repositorio\n\n7. Usaremos `use_git()` para iniciar el control de versiones de GIT en nuestro proyecto.\n\n![](img/use_git.png){width=\"380\" fig-align=\"center\"}\n\n8. Ahora, usaremos `usethis::use_github()` para crear un repositorio en GitHub y subir el proyecto.\n\nSi todo ha salido bien, se debería abrir tu navegador con el nuevo repositorio de GitHub.\n\n---\n\n## Github pages\n\n¿Cómo [**convertir nuestro repositorio en una web**]{.hl-yellow}?\n\n![](./img/github-pages.png){fig-align=\"center\"}\n\n1. Haz click en `Settings`\n2. Ve al apartado `Pages`\n3. En el subapartado `branch` selecciona la única rama que tenemos ahora (`main`)\n4. Selecciona la carpeta donde tengas el `.html` (en web complejas estará como en cualquier web en `docs`, en algo simple estará en la ruta raiz del repositorio)\n5. Haz click en `Save`\n\n---\n\n## Github pages\n\nSi te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web está en proceso de ser desplegada (deploy)**]{.hl-orange}\n\n![](./img/github-naranja.png){fig-align=\"center\"}\n\n---\n\n## Github pages\n\nPasados unos segundos (dependiendo del tamaño de la web y tu conexión a internet) ese [**icono pasará a ser un check verde**]{.hl-green}: habemus web\n\n![](./img/github-verde.png){fig-align=\"center\"}\n\n\nEl [**link de la web por defecto**]{.hl-yellow} será `{nombre_usuario}.github.io/{nombre_repo}`\n\n---\n\n## Github pages\n\n\n![](./img/github-pages-deploy.png){fig-align=\"center\"}\n\n¡Un momento! Ahora mismo nuestra web [**no nos está mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.\n\n. . .\n\nPara que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este último llamándolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}\n\n---\n\n## Github pages\n\nVamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro\n\n\n![](./img/repo-index-html.png){fig-align=\"center\"}\n\n---\n\n## Github pages\n\nSi [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...\n\n:::: columns\n::: {.column width=\"50%\"}\n![](./img/index-html-qmd.png){fig-align=\"center\"}\n:::\n::: {.column width=\"50%\"}\n\nSi a tu `.qmd` ya le llamas de inicio `index.qmd`, automáticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar añadiendo un archivo `css` de estilos)\n\n[**Habemus web**]{.hl-green} simplemente clickando en Pages :)\n\n:::\n::::\n\n\n---\n\n## Repo con diapositivas\n\nVamos a crear el último repositorio que se llamará `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.\n\n\n:::: columns\n::: {.column width=\"45%\"}\n![](img/quarto-slides.png)\n:::\n::: {.column width=\"55%\"}\nLa forma de escribir será igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)\n\nLlama al archivo directamente `index.qmd`, súbelo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}\n:::\n::::\n\n\n# El mundo ggplot2\n\n[**Visualización de datos**]{style=\"color:#444442;\"}\n\n\n## ¿Qué es ggplot2?\n\n[**ggplot2**]{.hl-purple} es un paquete para graficar, que facilita crear gráficas complejas a partir de datos en un [**data frame, data table o tibble**]{.hl-yellow}\n\n:::: columns\n::: {.column width=\"70%\"}\n\n- Incluye varias funciones para especificar que variables graficar, como éstas son [**expuestas**]{.hl-yellow}, y varias otras características [**visuales**]{.hl-yellow}. \n\n- Funciona mejor con datos extensos, es decir, con aquellas estructuras donde se tiene una [**columna por cada dimensión o atributo**]{.hl-yellow}, y una [**fila por cada observación**]{.hl-yellow}.\n\n::: callout-important\n## Importante\n\nggplot2 está incluido en el paquete tidyverse.\n\n:::\n\n:::\n::: {.column width=\"30%\"}\n![](img/ggplot2.png)\n:::\n::::\n\n\n---\n\n## Primera capa: el área del gráfico\n\n::: incremental\n- La función principal de ggplot2 es justamente `ggplot()` que permite iniciar el gráfico y además definir las [**características globales**]{.hl-yellow}. El primer argumento de esta función serán los datos que vas a visualizar.\n\n- El segundo argumento se llama `mapping` (mapeo en inglés). Este argumento [**define la relación**]{.hl-yellow} entre cada columna del data frame y los distintos parámetros gráficos.\n\n- Por ejemplo, qué columna va a representar el eje x, cuál va a ser el eje y, etc. Este mapeo se hace siempre con la función `aes()` (que viene de aesthetics, estética en inglés).\n\n:::\n\n```{r}\n#| eval: true\n#| echo: true\ndatos <- tibble(Edad = seq(4,24, by = 2), \n                Estaturas = c(102, 109, 115, 121, 133, 141, 156, 167, 181, 187, 188),\n                Marca = sample(c(\"A\", \"B\"), size = 11, replace = TRUE))\n```\n\n```{r}\n#| eval: false\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas))\n```\n\n---\n\n## Segunda capa: geometrías\n\nEl código anterior sólo genera el área del gráfico y los ejes. Lo que falta es indicar con qué geometrías representar los datos.\n\nPara agregar geometrías lo que hay que hacer es sumar el resultado de una función que devuelva una nueva capa. Estas suelen ser funciones que empiezan con `geom_` y luego el nombre de la geometría (en inglés).\n\n::: incremental\n- [**geom_point()**]{.hl-purple}: para gráficos de dispersión.\n\n- [**geom_boxplot()**]{.hl-purple}: para gráficos de caja y bigotes.\n\n- [**geom_line()**]{.hl-purple}: para líneas de tendencias, series de tiempo, etc.\n\n- [**geom_histogram()**]{.hl-purple}: para gráficos de barras.\n\n:::\n\n::: callout-important\n## Importante\n\nUsa + para agregar un geom a una línea de comandos de ggplot.\n\n:::\n\n---\n\n## Gráfico de dispersión\n\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas)) + geom_point(size = 3, shape = 5, colour = \"blue\")\n```\n\n---\n\n## Gráfico de cajas y bigotes\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(y = Estaturas, fill = Marca)) + geom_boxplot()\n```\n\n---\n\n## Gráfico de líneas\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas, colour = Marca)) + geom_line(size = 1.2, linetype = \"dashed\")\n```\n\n\n---\n\n## Gráfico de áreas\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas)) + geom_area(colour = \"red\", fill = \"blue\", alpha = 0.3)\n```\n---\n\n## Nuestra Biblia\n\n![](img/cover.jpg){fig-align=\"center\"}\n\nSe puede acceder libremente al recurso a través del siguiente enlace: [**https://r-graphics.org**](https://r-graphics.org){.uri}\n\n\n\n\n# ENLACES\n\n[**Algunos paquetes o recursos curiosos**]{style=\"color:#444442;\"}\n\n\n---\n\n### Paletas de colores\n\n* [**{ggthemes}**]{.hl-purple}: [**temas y paletas extras**]{.hl-yellow} para ggplot (por ejemplo para **daltónicos**) <https://jrnold.github.io/ggthemes/> y <https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/>\n\n* [**{peRReo}**]{.hl-purple}: paletas inspiradas en [**portadas de música urbana y latina**]{.hl-yellow} <https://github.com/jbgb13/peRReo>\n\n* [**Paletas inspiradas en el Metropolitan Museum**]{.hl-purple}: de Blake Robert Mills <https://github.com/BlakeRMills/MetBrewer/tree/main>\n\n* [**Paletas inspiradas en Harry Potter**]{.hl-purple}: de Alejandro Jiménez <https://github.com/aljrico/harrypotter>\n\n* [**{colorblindcheck}**]{.hl-purple}: detectar paletas de colores aptas [**daltónicos/as**]{.hl-yellow}. De Jakub Nowosad <https://github.com/Nowosad/colorblindcheck>\n\n---\n\n### Dataviz\n\n* [**R Graph Gallery**]{.hl-purple}: colección de dataviz en R <https://www.r-graph-gallery.com/>\n\n* [**{patchwork}**]{.hl-purple}: agregar y [**componer gráficas**]{.hl-yellow}. De Thomas Lin Pedersen. <https://patchwork.data-imaginist.com>\n\n* [**ggplotly**]{.hl-purple}: función de `{plotly}`, para convertir ggplot a plotly ([**interactiva**]{.hl-yellow}) <https://www.rdocumentation.org/packages/plotly/versions/4.10.0/topics/ggplotly>.\n\n\nTras convertirlo a plotly se puede [**guardar automáticamente en html**]{.hl-yellow} con <https://plotly-r.com/saving.html> y generar el [**código del iframe responsive**]{.hl-yellow} con <https://bhaskarvk.github.io/widgetframe/articles/Using_widgetframe.html>\n\n\n\n---\n\n### Dataviz\n\n* [**{ggiraph}**]{.hl-purple}: gráficas interactivas al [**estilo D3**]{.hl-yellow}. <https://davidgohel.github.io/ggiraph/>\n\n* [**Aprender a usar {ggiraph}**]{.hl-purple}: para gráficas interactivas al [**estilo D3**]{.hl-yellow} <https://albert-rapp.de/posts/ggplot2-tips/17_ggiraph/17_ggiraph.html> \n\n* [**Gráficas interactivas**]{.hl-purple}: <https://www.tanyashapiro.com/interactive-visuals>\n\n* [**{geomtextpath}**]{.hl-purple}: paquete para [**curvar el texto**]{.hl-yellow} ajustándose a una gráfica. De Allan Cameron y Teun van den Brand. <https://allancameron.github.io/geomtextpath/>\n\n* [**{ggstream}**]{.hl-purple}: visualización de [**datos en flujo**]{.hl-yellow}. De Z. Gu. <https://github.com/davidsjoberg/ggstream>\n\n* [**{ggpattern}**]{.hl-purple}: rellenos con [**patrones geométricos**]{.hl-yellow} en ggplot2. De coolbutuseless y Trevor L. Davis. <https://github.com/coolbutuseless/ggpattern>\n\n---\n\n### Mapas\n\n* [**{mapSpain}**]{.hl-purple}: visualización de [**datos en mapas de España**]{.hl-yellow} en R. De Diego Hernangómez <https://dieghernan.github.io/rpubs/mapSpain_RMadrid/#1>\n\n* [**{rasterpic}**]{.hl-purple}: visualización de [**mapas con imágenes rasterizados de fondo**]{.hl-yellow}. De Diego Hernangómez. <https://dieghernan.github.io/rasterpic/>\n\n\n---\n\n\n### Text mining\n\n* [**Manual de text mining**]{.hl-purple}: de Julia Silge y David Robinson. Recurso: <https://tidytextmining.com>\n\n* [**Descarga de textos libres**]{.hl-purple}: de David Robinson. Recurso: <https://github.com/ropensci/gutenbergr>\n\n* [**Análisis de sentimientos de tweets**]{.hl-purple}: de Harshvardhan. Recurso: <https://www.harsh17.in/twitter-sentiments/>\n\n### Grafos y redes\n\n* [**{tidygraph}**]{.hl-purple}: paquete al estilo `{tidyverse}` para [**visualizar y manipular grafos**]{.hl-yellow} <https://tidygraph.data-imaginist.com/index.html>\n\n\n---\n\n\n### Datos curiosos\n\n* [**{fitbitr}**]{.hl-purple}: API para acceder a [**datos de pulseras fitbit**]{.hl-yellow}. De Matt Kaye <https://mrkaye97.github.io/fitbitr/index.html>\n\n* [**{rtweet}**]{.hl-purple}: API para acceder (al menos antes) a [**Twitter**]{.hl-yellow}. De Michael W. Kearney <https://docs.ropensci.org/rtweet/>\n\n* [**{owiDR}**]{.hl-purple}: API para acceder a datos de [**Our World in Data**]{.hl-yellow} <https://github.com/piersyork/owidR>\n\n* [**{wordle}**]{.hl-purple}: API para acceder a [**datos de WORDLE**]{.hl-yellow}. De coolbutuseless <https://coolbutuseless.github.io/2022/01/04/wordle-v0.1.5-a-package-for-playing-and-helping-solve-wordle-puzzles/>\n\n* [**{chessR}**]{.hl-purple}: API para acceder a datos de [**partidas de ajedrez**]{.hl-yellow}. De Jason Zivkovic <https://github.com/JaseZiv/chessR>\n\n\n---\n\n\n### Informes, libros, diapositivas y webs\n\n* [**Manual de Quarto**]{.hl-purple}: el nuevo rmarkdown, más completo y sencillo para elaborar manuales, diapositivas, informes e incluso webs <https://quarto.org/docs/guide/>\n\n* [**Shiny**]{.hl-purple}: webs interactivas con R <https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/>\n\n### Tablas\n\n* [**{gt}**]{.hl-purple}: tablas en R. De RStudio <https://gt.rstudio.com/>\n\n* [**{gtExtras}**]{.hl-purple}: visualización de datos en tablas. De Thomas Mock. <https://jthomasmock.github.io/gtExtras/index.html>\n\n* [**Tutorial de tablas**]{.hl-purple}: de Benjamin Nowak <https://bjnnowak.netlify.app/2021/10/04/r-beautiful-tables-with-gt-and-gtextras/>\n\n\n# ¡GRACIAS!\n\n\n","srcMarkdownNoYaml":"\n\n# ¡Bienvenidos al curso de Simulación!\n\n[**Dejad Excel a un lado**]{style=\"color:#444442;\"}  \n![](img/hateExcel.png){width=10%}\n\n---\n\n## ¡Hola a todos!\n\n::: columns\n::: {.column width=\"30%\"}\n![](img/me.jpeg)\n:::\n\n::: {.column width=\"70%\"}\n::: incremental\n-   [**Diego Paúl Huaraca Shagñay**]{.hl-purple}\n\n-   Ingeniero Matemático. [**Escuela Politécnica Nacional**]{.hl-yellow} (2013).\n\n-   Máster en Ciencias Actuariales y Financieras. [**Universidad de Alcalá**]{.hl-yellow} (2018).\n\n-   Consultor Analítico de Riesgo Financiero. [**BI-SCIENCES**]{.hl-green} (desde 2018).\n\n-   Docente del Departamento de Matemática. [**Escuela Politécnica Nacional**]{.hl-green} (desde 2018).\n\n-   Consultor Actuarial. [**Superintendencia de Bancos**]{.hl-green} (desde 2022).\n\n-   Socio Fundador de [**Tactary Consultoría Actuarial**]{.hl-green} (desde 2022).\n:::\n:::\n:::\n\n---\n\n## Contenido del curso \n<!-- Primera parte -->\n::: columns\n::: {.column width=\"20%\"}\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTPKIAIbhuhpU6GMjL2jBdHycULZOCEVt-XWs9Z_b0elEikNTefOLW3yk2ajknsTLsMDo4&usqp=CAU)\n:::\n\n::: {.column width=\"80%\"}\n::: incremental\n-   [**Introducción al Lenguaje R**]{.hl-red} → `{a programar se aprende programando}`.\n\n-   [**Análisis de datos**]{.hl-red} → `{tibble, dplyr}`.\n\n-   [**Visualización de datos**]{.hl-red} → `{gráficos estáticos y dinámicos}`.\n\n-   [**Desarrollo de aplicativos web**]{.hl-red} → `{shiny, shinydashboard}`.\n\n-   [**Reportería dinámica**]{.hl-red} → `{LaTeX, rmarkdown, Quarto}`.\n\n-   [**Simuladores de números aleatorios**]{.hl-yellow}  → `{base}`.\n\n:::\n:::\n:::\n\n\n## Contenido del curso\n<!-- Segunda Parte -->\n::: columns\n::: {.column width=\"20%\"}\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTPKIAIbhuhpU6GMjL2jBdHycULZOCEVt-XWs9Z_b0elEikNTefOLW3yk2ajknsTLsMDo4&usqp=CAU)\n:::\n\n::: {.column width=\"80%\"}\n::: incremental\n-   [**Simulación de variables aleatorias**]{.hl-yellow} → `{discretas y continuas}`.\n\n-   [**Simulación de vectores aleatorias**]{.hl-yellow}.\n\n-   [**Simulación de procesos estocásticos**]{.hl-yellow} → `{Markov, Weiner, etc.}`.\n\n-   [**Métodos de MonteCarlo**]{.hl-red} → `{secuenciales, inferencia estadística}`.\n\n-   [**Técnicas de Remuestreo**]{.hl-red}.\n\n-   [**Métodos de MoteCarlo en Cadenas de Markov**]{.hl-red}\n\n-   [**Aplicaciones avanzadas**]{.hl-red} → `{simulación por eventos}`.\n:::\n:::\n:::\n\n\n# Instalación del Lenguaje R\n\n[**Instalando R y RStudio**]{style=\"color:#444442;\"}\n\n---\n\n## Requisitos\n\nPara el desarrollo del curso se requiere:\n\n1.  [**Conexión a internet**]{.hl-yellow} (para la descarga de paquetes y bases de datos).\n\n2.  [**Descargar R**]{.hl-yellow}: La descarga se realiza (gratuitamente) desde el enlace: <https://cran.r-project.org/>\n\n3.  [**Descargar RStudio**]{.hl-yellow}: La descarga se realiza (gratuitamente) desde el enlace: <https://posit.co/download/rstudio-desktop/>\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/cranR.jpg){width=\"440\" fig-align=\"center\"}\n:::\n\n::: {.column width=\"50%\"}\n![](img/rstudio.jpg){width=\"440\" fig-align=\"center\"}\n:::\n:::\n\n---\n\n## Instalación de R\n\n-   [**Paso 1**]{.hl-yellow}: Ingrese al repositorio CRAN en [**https://cran.r-project.org/**](https://cran.r-project.org/){.uri} y seleccione su sistema operativo.\n\n-   [**Paso 2**]{.hl-yellow}: Para el sistema MacOs basta con hacer click en **R-4.X.Y.pkg**, y abrirlo una vez descargado. Para el sistema Windows, basta con hacer click en **install R for the first time** y después en **Download R-X.Y.Z for Windows**, una vez descargado, abrirlo como cualquier archivo de instalación.\n\n-   [**Paso 3**]{.hl-yellow}: Abrir el ejecutable e instalar el programa con todas las opciones por defecto.\n\n. . .\n\n::: callout-important\nSiempre que tengas que descargar algo del repositorio CRAN (ya sea el propio R o un paquete), [**asegúrate de tener conexión a internet**]{.hl-red}.\n:::\n\n---\n\n## CRAN\n\n- El lenguaje R se distribuye gratuitamente a través del repositorio [**Comprehensive R Archive Network (CRAN)**]{.hl-purple}  propiedad de la R Foundation for Statistical Computing.\n\n- El mantenimiento se encuentra a cargo del [**grupo R Core Team**]{.hl-purple} asistido por una gran cantidad de colaboradores internacionales.\n\n- Con la finalidad de evitar el colapso del mundo estadístico, el repositorio CRAN se refleja en [**diferentes lugares**]{.hl-purple} de todo el mundo\n\n\n![](img/CRAN.png){width=\"380\" fig-align=\"center\"}\n\n---\n\n## Funcionamiento\n\n- R es un lenguaje [**orientado a objetos**]{.hl-purple} diseñado en un entorno auténtico bajo el cual esconde su simplicidad y flexibilidad, lo cual permite a sus usuarios añadir funcionalidad mediante la definición de nuevas funciones y operadores.\n\n- R almacena sus variables, datos, funciones y resultados en la [**memoria activa (RAM)**]{.hl-purple} del computador en forma de objetos con un nombre específico y pueden ser [**modificados o manipulados**]{.hl-purple} por el usuario.\n\n::: {.column width=\"100%\"}\n![](img/FunR.png){width=\"630\" fig-align=\"center\"}\n:::\n\n\n---\n\n## Primera operación\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta.\n\nEsa «pantalla blanca» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una simple **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\" fig-align=\"center\"}\n:::\n:::\n\n. . .\n\n[**Idea**]{.hl-yellow}: a una variable llamada `a` le asignaremos el valor de `3` (escribiremos el código de abajo en la consola y daremos «enter»)\n\n```{r}\n#| code-line-numbers: \"1\"\na <- 3\n```\n\n---\n\n## Primera operación\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta.\n\nEsa «pantalla blanca» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\" fig-align=\"center\"}\n:::\n:::\n\n[**Idea**]{.hl-yellow}: definiremos otra variable llamada `b` y le asignaremos el valor `5`\n\n```{r}\n#| code-line-numbers: \"2\"\na <- 3\nb <- 5\n```\n\n. . .\n\n::: callout-note\n## Fíjate que...\n\nEn `R` usaremos `<-` como una **flecha**: la variable a la izquierda de dicha flecha recibe el valor que hay a la derecha (por ejemplo, `a <- 3`)\n:::\n\n---\n\n## Primera operación\n\n::: columns\n::: {.column width=\"65%\"}\nPara comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta.\n\nEsa «pantalla blanca» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.\n:::\n\n::: {.column width=\"35%\"}\n![](img/consola.jpg){width=\"240\"}\n:::\n:::\n\n[**Idea**]{.hl-yellow}: haremos la suma `a + b` y nos devolverá su resultado\n\n```{r}\n#| code-line-numbers: \"3\"\na <- 3\nb <- 5\na + b\n```\n\n---\n\n## Instalación de RStudio\n\n`RStudio` será el [**Bloc de Notas**]{.hl-purple} que usaremos para escribir los códigos (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).\n\n-   [**Paso 1**]{.hl-yellow}: Ingrese a la página de Posit en [**https://posit.co/download/rstudio-desktop/**](https://posit.co/download/rstudio-desktop/){.uri} y seleccione la descarga gratuita.\n\n-   [**Paso 2**]{.hl-yellow}: Selecciona el ejecutable en función al sistema operativo que use.\n\n-   [**Paso 3**]{.hl-yellow}: Luego de la descarga, se apertura el ejecutable como cualquier otro programa y se instala todo por defecto.\n\n---\n\n## Organización de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo código que antes (la suma de las variables) en ella. La consola será donde [**ejecutaremos órdenes y mostraremos resultados**]{.hl-purple}.\n\n![](img/consola_rstudio.jpg){width=\"420\" fig-align=\"center\"}\n\n---\n\n## Organización de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Environment**]{.hl-yellow}: la pantalla pequeña (puedes ajustar los márgenes con el ratón a tu gusto) que tenemos en la parte superior derecha. Nos mostrará las [**variables que tenemos definidas**]{.hl-purple}.\n\n![](img/environment.jpg){width=\"380\" fig-align=\"center\"}\n\n---\n\n## Organización de RStudio\n\nAl abrir `RStudio` seguramente tengas tres ventanas:\n\n-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha servirá para buscar [**ayuda de funciones**]{.hl-purple}, para [**visualizar gráficos**]{.hl-purple}, así como para la [**carga de librerías**]{.hl-purple} y [**navegación**]{.hl-purple} por las carpetas del CPU.\n\n![](img/multiusos.jpg){width=\"420\" fig-align=\"center\"}\n\n# ¿Qué es R? Primeros usos\n\n[**¿Cuáles son las ventajas? Primer uso**]{style=\"color:#444442;\"}\n\n---\n\n## ¿Qué es R? ¿Por qué R?\n\n![](img/meme_barco.jpg){fig-align=\"center\"}\n\n---\n\n## ¿Qué es R? ¿Por qué R?\n\n`R` es el [**lenguaje estadístico por excelencia**]{.hl-yellow}, creado por y para estadísticos/as, con 5 ventajas fundamentales [**frente a Excel**]{.hl-red}:\n\n\n::: incremental\n-   [**Lenguaje de programación**]{.hl-yellow}: la obviedad [→ análisis [**replicables**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Gratuito**]{.hl-yellow}: la filosofía de la comunidad de `R` es el compartir código bajo **copyleft** [→ [**uso ético de dinero público**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a código ajeno, incluso al **propio código fuente** [→ [**flexibilidad y transparencia**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo mínimo, pero existen códigos de otras personas que podemos reusar (19430 [**paquetes**]{.hl-yellow} al 28/04/2023) [→ [**ahorro de tiempo**]{.hl-purple}]{.fragment .fade-in}\n\n-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programación (como Python) [→ [**menor curva de aprendizaje**]{.hl-purple}]{.fragment .fade-in}\n:::\n\n\n## ¿Por qué programar?\n\n-   [**Automatizar**]{.hl-yellow} → te permitirá automatizar tareas recurrentes (ejemplo: actualizar pronósticos del tiempo, actualizar informes estadísticos) de forma que solo tendrás que programarlo uno vez.\n\n-   [**Replicabilidad**]{.hl-yellow} → podrás replicar tu análisis siempre de la misma manera.\n\n-   [**Flexibilidad**]{.hl-yellow} → podrás adaptar el software a tus necesidades.\n\n-   [**Transparencia**]{.hl-yellow} → ser auditado por la comunidad.\n\n![](img/the_general_problem.png){fig-align=\"center\"}\n\n---\n\n## Idea fundamental: paquetes\n\nUna de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: códigos que otras personas han implementado para **resolver un problema**\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/paquetes.png)\n:::\n\n::: {.column width=\"65%\"}\n::: {.fragment fragment-index=\"1\"}\n-   [**Instalación**]{.hl-yellow}: descargamos los códigos de la web (necesitamos internet) → [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)\n\n```{r}\n#| eval: false\ninstall.packages(\"dplyr\")\n```\n:::\n\n::: {.fragment fragment-index=\"2\"}\n-   [**Carga**]{.hl-yellow}: indicamos qué paquetes queremos usar cada vez que iniciamos `RStudio` → [**traer el libro de la estantería**]{.hl-purple}\n\n```{r}\n#| eval: false\nlibrary(dplyr)\n```\n:::\n:::\n:::\n\n---\n\n## Idea fundamental: paquetes\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/paquetes.png)\n:::\n\n::: {.column width=\"65%\"}\nUna vez instalado, hay dos manera de usar un paquete (traerlo de la estantería)\n\n::: {.fragment fragment-index=\"1\"}\n-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesión [**todo el libro**]{.hl-purple}\n\n```{r}\n#| eval: false\nlibrary(dplyr)\n```\n:::\n\n::: {.fragment fragment-index=\"2\"}\n-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le índicamos que solo queremos una [**página concreta de ese libro**]{.hl-purple}\n\n```{r}\n#| eval: false\ndplyr::rename_if()\n```\n:::\n:::\n:::\n\n---\n\n## Paquetes: Acceso a funciones\n\n::: columns\n::: {.column width=\"22%\"}\n![](img/stringr.png)\n:::\n\n::: {.column width=\"78%\"}\nUna vez instalado y cargado el paquete, es posible indagar sobre las funciones que contiene a partir del comando `ls(\"package:_____\")`.\n\n```{r}\nlibrary(stringr)\nls(\"package:stringr\")\n```\n:::\n\n:::\n\n---\n\n## Carga de múltiples paquetes\n\nEn el caso que se requieran cargar varias librerías se puede evitar la ejecución de varias líneas de código a partir de la siguiente opción:\n```{r}\n#| eval: false\n# Listado de paquetes a cargar\npaquetes <- c(\"pckg_1\",\"pckg_2\", ... , \"pckg_n\")\n\n# Sentencia de carga\nlapply(paquetes, FUN=library, character.only=TRUE)\n```\n\n \n\n. . .\n\nCon el fin de evitar cargar las librerías más utilizadas al arranque de cada sesión, se puede automatizar esta tarea a partir del archivo `.RProfile`\n```{r}\n#| eval: false\n# Crea el archivo .RProfile en el caso que no exista\nif(!file.exists(\"~/.Rprofile\")){\n  file.create(\"~/.Rprofile\")\n} \n\n# edita el archivo .RProfile y coloca las instrucciones a ejecutar automáticamente\nfile.edit(\"~/.Rprofile\") \n```\n\n---\n\n## Respaldando información\n\nUna tarea importante dentro del análisis de datos es el respaldo de información que se pueda dar sobre ciertos resultados obtenidos, en este punto R consta de dos comandos muy útiles: `save` y `load`.\n\n \n\n. . .\n\nEl primero de ellos permite almacenar en disco los objetos que desee el usuario (almacenamiento parcial), dicho comando también puede ser configurado de tal manera que almacenen todos los objetos que se encuentra válidos en el área de trabajo.\n\n```{r}\n#| eval: false\nvector <- c(1,2,3,4,5)\nmatriz <- matrix(c(1,2,3,4,5,6), ncol = 2)\n\n# Si deseas guardar el objeto \"vector\" con el nombre \"Respaldos\"\nsave(vector, file = \"Respaldos.RData\")\n\n# para el caso que se desee almacenar todos los objetos con el nombre \"TotalRespaldos\" \nsave(list = ls(all = TRUE), file = \"TotalRespaldos.RData\")\n```\n\n---\n\n\n## Mensajes de error o advertencia\n\nDurante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera → [**te vas equivocar**]{.hl-yellow}. No solo será importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.\n\n. . .\n\n-   [**Mensajes de error**]{.hl-red}: precedidos de **«Error in...»** y serán aquellos fallos que [**impidan la ejecución**]{.hl-yellow}\n\n```{r}\n#| error: true\n\"a\" + 1 \n```\n\n. . .\n\n-   [**Mensajes de warning**]{.hl-orange}: precedidos de **«Warning in...»** son los (posibles) fallos más delicados ya que son incoherencias que [**no impiden la ejecución**]{.hl-yellow}\n\n```{r}\n#| warning: true\n# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe\nsqrt(-1)\n```\n\n---\n\n## Antes de arrancar: scripts\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/abrir_script.jpg){width=\"350\"}\n:::\n\n::: {.column width=\"65%\"}\nUn [**script**]{.hl-yellow} será el documento en el que programamos, nuestro `blog de notas` (aquí con extensión `.R`) donde escribiremos las órdenes. Para **abrir nuestro primero script**, haz click en el menú en `File < New File < R Script`.\n:::\n:::\n\n::: callout-warning\n## Cuidado\n\nEs importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habrás perdido**]{.hl-red}.\n:::\n\n---\n\n## Ejecutando el primer script\n\nAhora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros códigos**]{.hl-yellow}. ¿Cómo ejecutarlo?\n\n. . .\n\n1.  **Escribimos** el código a ejecutar.\n\n. . .\n\n2.  **Guardamos** el archivo .R haciendo click en `Save current document`.\n\n. . .\n\n3.  El código no se ejecuta salvo que se lo indiquemos. Tenemos tres opciones:\n\n-   [**Copiar y pegar**]{.hl-yellow} en consola.\n-   [**Seleccionar líneas**]{.hl-yellow} y `Ctrl+Enter`\n-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el código **completo**.\n\n---\n\n## 💻 Tu turno\n\n[**Ejecuta tu primer script**: crea un script de cero, programa lo indicado debajo y ejecútalo (de las 3 maneras posibles)]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Define una variable de nombre `a` y cuyo valor sea -1\n\n```{r}\n#| code-fold: true\na <- -1\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Añade debajo otra línea para definir una variable `b` con el valor 5. Tras ello múltiplica ambas variables\n\n```{r}\n#| code-fold: true\n#| eval: false\nb <- 5\na * b # sin guardar\nmultiplicacion <- a * b # guardado\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Modifica el código inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables.\n\n```{r}\n#| eval: false\nc <- # deberías asignarle el valor 3\nd <- # deberías asignarle el valor -1\n```\n\n```{r}\n#| code-fold: true\n#| eval: false\nc <- 3\nd <- -1\nc / d # sin guardar\ndivision <- c / d # guardado\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Asigna un valor positivo a `x` y calcula su raíz cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la función `abs()`.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx <- 5\nsqrt(x)\n\ny <- -2\nabs(y)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Usando la variable `x` ya definida, completa/modifica el código inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.\n\n```{r}\n#| eval: false\nz <- ? - ? # completa el código\nz\n```\n\n```{r}\n#| code-fold: true\n#| eval: false\nz <- x - 5\nz\n```\n:::\n\n::: callout-note\n## Toma nota\n\nComandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: líneas de código que hemos «encapsulado» bajo un nombre, y dado unos argumentos de entrada, ejecuta las órdenes (una especie de atajo).\n:::\n\n\n# Primeros datos: variables\n\n[**¿Qué tipos de datos existen?**]{style=\"color:#444442;\"}\n\n---\n\n## De la CELDA a la TABLA\n\n¿Qué [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?\n\n![](img/celdas.jpg){fig-align=\"center\"}\n\n::: incremental\n-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.\n-   [**Variable**]{.hl-yellow}: **concatenación** de valores del mismo tipo ([**vectores**]{.hl-purple}).\n-   [**Matriz**]{.hl-yellow}: concatenación de variables del **mismo tipo y longitud**.\n-   [**Tabla**]{.hl-yellow}: concatenación de variables de [**distinto tipo pero igual longitud**]{.hl-purple}\n-   [**Lista**]{.hl-yellow}: concatenación de variables de [**distinto tipo y distinta longitud**]{.hl-purple}\n:::\n\n---\n\n## Celdas: tipos de datos\n\n¿Existen [**variables más allá de los números**]{.hl-yellow}?\n\n. . .\n\nPiensa por ejemplo en los datos guardados de una persona:\n\n::: {.fragment .fade-up}\n-   La edad o el peso será un [**número**]{.hl-yellow}.\n\n```{r}\nedad <- 33\n```\n:::\n\n::: {.fragment .fade-up}\n-   Su nombre será una cadena de [**texto (string o char)**]{.hl-yellow}.\n\n```{r}\nnombre <- \"Diego\"\n```\n:::\n\n::: {.fragment .fade-up}\n-   A la pregunta «¿está usted soltero/a?» la respuesta será lo que llamamos una [**variable lógica**]{.hl-yellow} (`TRUE` si está soltero/a o `FALSE` en otro caso).\n\n```{r}\nsoltero <- FALSE\n```\n:::\n\n::: {.fragment .fade-up}\n-   Su fecha de nacimiento será precisamente eso, una [**fecha**]{.hl-yellow}.\n:::\n\n---\n\n## Variables numéricas\n\nEl dato más sencillo (ya lo hemos usado) serán las [**variables numéricas**]{.hl-yellow}\n\n```{r}\n#| eval: false\na <- 5\nb <- 2\na + b\n```\n\n```{r}\n#| echo: false\n#| include: false\na <- 5\nb <- 2\na + b\n```\n\n \n\n. . .\n\nPara saber el tipo de una variable tenemos la función `class()`\n\n```{r}\nclass(a)\n```\n\n \n\n. . .\n\nCon las variables numéricas podemos realizar las [**operaciones aritméticas**]{.hl-yellow} de una calculadora: sumar (`+`), raíz cuadrada (`sqrt()`), cuadrado (`^2`), etc.\n\n```{r}\na^2\n```\n\n---\n\n## Variables de texto\n\nImagina que además de la edad de una persona queremos guardar su nombre\n\n```{r}\nnombre <- \"Diego\"\nclass(nombre)\n```\n\n \n\n. . .\n\nLas [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones**]{.hl-red} aritméticas (sí otras operaciones como pegar o localizar patrones).\n\n```{r}\n#| error: true\nnombre + 1 # error al sumar número a texto\n```\n\n \n\n. . .\n\n::: callout-warning\n## Recuerda que...\n\nLas variables de tipo texto (character o stringr) van siempre [**entre comillas**]{.hl-orange}.\n:::\n\n---\n\n## Primera función: paste\n\nComo hemos comentado, una [**función**]{.hl-yellow} es un trozo de **código encapsulado** bajo un nombre que depende de unos argumentos de entrada. Nuestra primera función será `paste()`: dadas dos cadenas de texto nos permite pegarlas.\n\n```{r}\npaste(\"Diego\", \"Huaraca\")\n```\n\n \n\n. . .\n\nFíjate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos añadir un [**argumento opcional**]{.hl-yellow} para indicarle el separador\n\n```{r}\npaste(\"Diego\", \"Huaraca\", sep = \"*\")\n```\n\n \n\n. . .\n\n```{r}\npaste(\"Diego\", \"Huaraca\", sep = \" - \")\n```\n\n---\n\n## Primera función: paste\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/paste_help.jpg)\n:::\n\n::: {.column width=\"50%\"}\n¿Cómo saber que argumentos tiene una función? Escribiendo en consola `? paste` o alternativamente `help(\"paste\")` te aparecerá una [**ayuda**]{.hl-yellow} en el panel multiusos.\n\nEn dicha ayuda podrás ver en su cabecera que argumentos ya tiene asignados por defecto la función\n:::\n:::\n\n. . .\n\nExiste una función similar llamada `paste0()` que pega por defecto con `sep = \"\"` (sin nada).\n\n```{r}\npaste0(\"Diego\", \"Huaraca\")\n```\n\n---\n\n## Primer paquete: glue\n\nUna forma más intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos será «comprar el libro» (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}\n\n```{r}\n#| eval: false\ninstall.packages(\"glue\") # solo la primera vez\nlibrary(glue)\n```\n\n```{r}\n#| echo: false\nlibrary(glue)\n```\n\n. . .\n\nCon dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, «la edad es de ... años», donde la edad está guardada en una variable.\n\n```{r}\nedad <- 33\nglue(\"La edad es de {edad} años\")\n```\n\n. . .\n\nDentro de las llaves también podemos ejecutar operaciones\n\n```{r}\nunidades <- \"días\"\nglue(\"La edad es de {edad * 365} {unidades}\")\n```\n\n---\n\n## Variables lógicas\n\nUna [**variable lógica o binaria**]{.hl-yellow} es aquella que toma **dos valores**:\n\n-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.\n-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.\n-   `NA`: [**dato ausente**]{.hl-yellow} son las siglas de *not available*.\n\n```{r}\nsoltero <- TRUE # ¿Es soltero? --> SÍ\nclass(soltero)\n```\n\n. . .\n\n::: callout-important\n## Importante\n\nLas variables lógicas [**NO son variables de texto**]{.hl-red}: `\"TRUE\"` es un texto, `TRUE` es un valor lógico.\n\n```{r}\n#| error: true\nTRUE + 1\n\"TRUE\" + 1\n```\n:::\n\n---\n\n## Condiciones lógicas\n\nLos valores lógicos suelen ser resultado de [**evaluar condiciones lógicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos comprobar si una persona se llama Julia.\n\n```{r}\nnombre <- \"María\"\n```\n\n \n\n. . .\n\nCon el [**operador lógico**]{.hl-yellow} `==` preguntamos sí a la izquierda es igual a la derecha\n\n```{r}\nnombre == \"Julia\"\n```\n\n. . .\n\nCon su opuesto `!=` preguntamos si es distinto.\n\n```{r}\nnombre != \"Julia\"\n```\n\n. . .\n\n::: callout-note\n## Fíjate que...\n\nNo es lo mismo `<-` (asignación) que una [**comparación lógica**]{.hl-yellow} con `==` (estamos preguntando).\n:::\n\n---\n\n## Condiciones lógicas\n\nAdemás de las comparaciones «igual a» frente «distinto», también comparaciones de orden como `<, <=, > o >=`.\n\n \n\n**¿Tiene la persona menos de 32 años?**\n\n```{r}\nedad <- 38\nedad < 32 # ¿Es la edad menor de 32 años?\n```\n\n \n\n**¿La edad es mayor o igual que 38 años?**\n\n```{r}\nedad >= 38\n```\n\n---\n\n## Variables de fecha\n\nUn tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.\n\n```{r}\nfecha_char <- \"2021-04-21\"\n```\n\n. . .\n\nParece una simple cadena de texto pero [**representa un instante en el tiempo**]{.hl-yellow}. ¿Qué debería suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?\n\n```{r}\n#| error: true\nfecha_char + 1\n```\n\n. . .\n\nLas fechas [**no pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha con `as_date()` del paquete `{lubridate}`\n\n```{r}\nlibrary(lubridate) # instala si no lo has hecho\nfecha <- as_date(\"2023-03-28\")\nfecha + 1\nclass(fecha)\n```\n\n---\n\n## Variables de fecha\n\nEn dicho paquete tenemos funciones muy útiles para [**manejar fechas**]{.hl-yellow}:\n\n-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.\n\n```{r}\ntoday()\n```\n\n. . .\n\n-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}\n\n```{r}\nnow()\n```\n\n. . .\n\n-   Con `year()`, `month()` o `day()` podemos [**extraer el año, mes y día**]{.hl-purple}\n\n```{r}\nfecha <- today()\nyear(fecha)\nmonth(fecha)\n```\n\n---\n\n## Resúmenes de paquetes\n\n![](img/lubridate.png)\n\n::: callout-note\n## Amplia contenido\n\nTienes un resumen en pdf de los paquetes más importantes en la [**carpeta «fichas paquetes»**]{.hl-green}\n:::\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Define una variable que guarde tu edad y otra con tu nombre\n\n```{r}\n#| code-fold: true\nedad <- 33\nnombre <- \"Javi\"\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Define otra variable que responda la pregunta «¿tengo hermanos?» y otra con la fecha de tu nacimiento.\n\n```{r}\n#| code-fold: true\nhermanos <- TRUE\n\nlibrary(lubridate)\nfecha_nacimiento <- as_date(\"1989-09-10\")\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Define otra variable con tus apellidos y junta con `glue()` las variables `nombre` y `apellidos` (una coma entre ellos) en una sola variable `nombre_completo`.\n\n```{r}\n#| code-fold: true\n#| eval: false\napellidos <- \"Álvarez Liébana\"\nglue(\"{nombre}, {apellidos}\")\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Calcula los días que han pasado desde la fecha de tu nacimiento, haciendo la resta entre la fecha de hoy y la fecha de nacimiento definida en el ejercicio 2.\n\n```{r}\n#| code-fold: true\n#| eval: false\ntoday() - fecha_nacimiento\n```\n:::\n\n\n# Primeros datos: vectores\n\n[**¿Cómo concatenamos valores? ¿Cómo creamos una columna?**]{style=\"color:#444442;\"}\n\n---\n\n## Vectores: concatenar\n\nCuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenación**]{.hl-purple} de variables del [**mismo tipo**]{.hl-purple}\n\n \n\n. . .\n\nLa forma más sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus elementos entre paréntesis y separados por comas\n\n```{r}\nedades <- c(33, 27, 60, 61)\nedades\n```\n\n \n\n. . .\n\n::: callout-tip\nUn número individual `x <- 1` es en realidad un vector de longitud uno.\n:::\n\n---\n\n## Vectores: concatenar\n\n::: columns\n::: {.column width=\"40%\"}\n![](img/edades_environment.jpg)\n:::\n\n::: {.column width=\"60%\"}\nComo ves ahora en el `environment` tenemos una **colección de elementos** guardada\n\n```{r}\nedades\n```\n:::\n:::\n\n. . .\n\n \n\nLa [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`\n\n```{r}\nlength(edades)\n```\n\n. . .\n\nTambién podemos [**concatenar vectores**]{.hl-yellow}\n\n```{r}\nc(edades, edades, 8)\n```\n\n---\n\n## Secuencias numéricas\n\nEn muchas ocasiones querremos crear [**secuencias numéricas**]{.hl-yellow} (por ejemplo, los días del mes). El comando `seq(inicio, fin)` nos permite crear una **secuencia** desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.\n\n```{r}\nseq(1, 31)\n```\n\n \n\n. . .\n\nEl comando `1:n` nos devuelve lo mismo que `seq(1, n)` (si el elemento inicial es mayor que el final, entenderá que la secuencia es **decreciente**)\n\n```{r}\n1:5\n7:-3\n```\n\n---\n\n## Secuencias numéricas\n\nTambién podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos\n\n```{r}\nseq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5\n```\n\n. . .\n\n \n\nOtras veces nos interesará definir una [**secuencia con una longitud concreta**]{.hl-yellow}\n\n```{r}\nseq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7\n```\n\n. . .\n\n \n\nIncluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}\n\n```{r}\nrep(0, 7) # vector de 7 ceros\n```\n\n---\n\n## Vectores de caracteres\n\nUn vector es una **concatenación** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente números. Vamos a crear una frase de ejemplo.\n\n```{r}\nfrase <- \"Me llamo Diego\"\nfrase\nlength(frase)\n```\n\n \n\n. . .\n\nEn el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas\n\n```{r}\nvector <- c(\"Me\", \"llamo\", \"Diego\")\nvector\nlength(vector)\n```\n\n---\n\n## Vectores de caracteres\n\n¿Qué sucederá si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?\n\n \n\n. . .\n\n```{r}\nc(1, 2, \"Diego\", \"3\", TRUE)\n```\n\nFíjate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}\n\n \n\n. . .\n\n```{r}\nc(3, 4, TRUE, FALSE)\n```\n\nEs importante entender que los valores lógicos en realidad están [**almacenados internamente como 0/1**]{.hl-yellow}\n\n---\n\n## Operaciones con vectores\n\nCon los vectores numéricos podemos hacer las mismas [**operaciones aritméticas**]{.hl-yellow} que con los números [→ un [**número es un vector**]{.hl-purple} (de longitud uno)]{.fragment .fade-in}\n\n\n. . .\n\n¿Qué sucederá si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?\n\n. . .\n\n```{r}\nx <- c(1, 3, 5, 7)\nx + 1\nx * 2\n3 * x - 5\nx/2\n```\n\n::: callout-warning\n## Cuidado\n\nSalvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}\n:::\n\n---\n\n## Operaciones con vectores\n\nLos vectores también pueden interactuar entre ellos, así que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)\n\n```{r}\nx <- c(2, 4, 6)\ny <- c(1, 3, 5)\nx + y\n```\n\n \n\n. . .\n\nDado que la operación (por ejemplo, una suma) se realiza elemento a elemento, ¿qué sucederá si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?\n\n. . .\n\n```{r}\nz <- c(1, 3, 5, 7)\nx + z\n```\n\nLo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que hará será reciclar del vector con menor longitud.\n\n---\n\n## Operaciones con vectores\n\nUna operación muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones lógicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...\n\n[**¿Qué días hizo menos de 22 grados?**]{.hl-yellow}\n\n```{r}\nx <- c(15, 20, 31, 27, 15, 29)\n```\n\n. . .\n\n```{r}\nx < 22\n```\n\nNos devolverá un [**vector lógico**]{.hl-yellow}, en función de si **cada elemento** cumple o no la condición pedida.\n\n. . .\n\nSi tuviéramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese día), la condición evaluada también sería `NA`\n\n```{r}\ny <- c(15, 20, NA, 31, 27, 7, 29, 10)\ny < 22\n```\n\n---\n\n## Operaciones con vectores\n\nLas [**condiciones lógicas pueden ser combinadas**]{.hl-yellow} de dos maneras:\n\n-   [**Intersección**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunción y**]{.hl-purple} con `&`) para devolver un `TRUE`\n\n```{r}\nx < 30 & x > 15\n```\n\n-   [**Unión**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunción o**]{.hl-purple} con `|`)\n\n```{r}\nx < 30 | x > 15\n```\n\n. . .\n\nCon `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen\n\n```{r}\nany(x < 30)\nall(x < 30)\n```\n\n---\n\n## Operaciones con vectores\n\nTambién podemos hacer uso de [**operaciones estadísticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.\n\n```{r}\nx <- c(4, -2, 3, -7)\nsum(x)\n```\n\n \n\n[**¿Qué sucede cuando falta un dato (ausente)?**]{.hl-yellow}\n\n. . .\n\n```{r}\nx <- c(4, -2, 3, NA, -7)\nsum(x)\n```\n\nPor defecto, si tenemos un dato ausente, la [**operación también será ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`\n\n```{r}\nsum(x, na.rm = TRUE)\n```\n\n---\n\n## Operaciones con vectores\n\nComo hemos comentado que los valores lógicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritméticas.\n\n \n\nPor ejemplo, si queremos [**averiguar el número o el promedio de elementos que cumplen una condición**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendrán asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar o promediar dicho vector lógico para obtener el número de elementos que cumplen\n\n```{r}\nx <- c(-5, 7, 2, 4, 6, 9, -1)\n\n# Número de elementos que cumplen la condición\nsum(x < 3)\n\n# Promedio de elementos que cumplen la condición\nmean(x<3)\n```\n\n---\n\n## Operaciones con vectores\n\nOtras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.\n\n \n\n-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La más conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores atípicos o outliers (valores muy grandes o muy pequeños), la media se perturba con mucha facilidad.\n\n```{r}\nx <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)\nmean(x, na.rm = TRUE)\n```\n\n---\n\n## Operaciones con vectores\n\nOtras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.\n\n \n\n-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.\n\n```{r}\nx <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)\nmedian(x)\n```\n\n. . .\n\n-   [**Percentiles**]{.hl-yellow}: medidas de posición (nos dividen en partes iguales los datos).\n\n```{r}\nquantile(x) # por defecto percentiles 0-25-50-75-100\nquantile(x, probs = seq(0.1, 0.9, by = 0.1)) # deciles\n```\n\n---\n\n## Operaciones con vectores\n\nOtra operación muy habitual es la de [**acceder a elementos**]{.hl-yellow} de un vector. La forma más sencilla es usar el operador `[i]` (acceder al elemento i-ésimo)\n\n```{r}\nedades <- c(20, 30, 33, NA, 61) \nedades[3] # accedemos a la edad de la tercera persona \n```\n\n. . .\n\n \n\nDado que un número no es más que un vector de longitud uno, esta operación también la podemos aplicar usando un [**vector de índices a seleccionar**]{.hl-yellow}\n\n```{r}\ny <- c(\"hola\", \"qué\", \"tal\", \"estás\", \"?\")\ny[c(1:2, 4)] # primer, segundo y cuarto elemento\n```\n\n::: callout-tip\nPara acceder al último sin preocuparnos, podemos pasarle como índice la longitud `x[length(x)]`\n:::\n\n---\n\n## Operaciones con vectores\n\nOtras veces queremos [**eliminar algunos elementos**]{.hl-yellow}, para ello, se repite la misma operación pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-ésimo del vector sino que lo «des-selecciona»\n\n```{r}\ny\ny[-2]\n```\n\n \n\n. . .\n\nEn muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones lógicas**]{.hl-yellow}, en función de los valores, así que pasaremos como índice la propia condición (recuerda, `x < 2` nos devuelve un vector lógico)\n\n```{r}\nedades <- c(15, 21, 30, 17, 45)\nnombres <- c(\"Javier\", \"María\", \"Laura\", \"Julia\", \"Luis\")\nnombres[edades < 18] # nombres de los menores de edad\n```\n\n---\n\n## Operaciones con vectores\n\nPor último, una acción habitual es saber [**ordenar valores**]{.hl-yellow}:\n\n-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo\n\n```{r}\nedades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)\nsort(edades)\nsort(edades, decreasing = TRUE)\n```\n\n. . .\n\n-   `order()`: devuelve el [**vector de índices**]{.hl-yellow} que tendríamos que usar para tener el vector ordenado\n\n```{r}\norder(x)\nx[order(x)]\n```\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Define el vector `x` como la concatenación de los 5 primeros números impares, y calcula su suma.\n\n```{r}\n#| code-fold: true\n#| eval: false\n# Dos formas\nx <- c(1, 3, 5, 7, 9)\nx <- seq(1, 9, by = 2)\n\nsum(x)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Obtén los elementos de `x` mayores que 4. Calcula el número de elementos de `x` mayores que 4.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx[x > 4]\nsum(x > 4)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Calcula el vector `1/x` y obtén la versión ordenada (de menor a mayor).\n\n```{r}\n#| code-fold: true\n#| eval: false\nz <- 1/x\nsort(z)\nz[order(z)]\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Encuentra el máximo y el mínimo del vector `x`\n\n```{r}\n#| code-fold: true\n#| eval: false\nmin(x)\nmax(x)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.\n\n```{r}\n#| code-fold: true\n#| eval: false\nx[x > 1 & x < 7]\nall(x > 0)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\n📝 Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. Elimina del vector el segundo elemento. Tras eliminarlo determina su suma y su media\n\n```{r}\n#| code-fold: true\n#| eval: false\nx <- c(1, -5, 8, NA, 10, -3, 9)\nx[c(1, 2, 5, 6)]\ny <- x[-2]\nsum(y, na.rm = TRUE)\nmean(y, na.rm = TRUE)\n```\n:::\n\n# Primera base de datos\n\n[**¿Cómo construimos una tabla? Matrices, data.frame y tibble**]{style=\"color:#444442;\"}\n\n---\n\n## Primer intento: matrices\n\nCuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una «tabla» que las recopile. La opción más inmediata son las [**matrices**]{.hl-yellow}: concatenación de variables del [**mismo tipo e igual longitud**]{.hl-purple}.\n\n. . .\n\nImagina que tenemos estaturas y pesos de 4 personas. ¿Cómo [**crear un dataset con las dos variables**]{.hl-yellow}? Con `cbind()` concatenamos en forma de columnas\n\n```{r}\nestaturas <- c(150, 160, 170, 180)\npesos <- c(60, 70, 80, 90)\ncbind(estaturas, pesos)\n```\n\n. . .\n\n \n\n[**No profundizaremos**]{.hl-red} más ya que nuestro objetivo es tener variables de misma longitud pero [**tipos diferentes**]{.hl-yellow} (pero que sepas que existen).\n\n---\n\n## Segundo intento: data.frame\n\nLas matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte\n\n```{r}\n#| code-line-numbers: \"4\"\nedades <- c(14, 24, NA)\nsoltero <- c(TRUE, NA, FALSE)\nnombres <- c(\"javi\", \"laura\", \"lucía\")\ncbind(edades, soltero, nombres)\n```\n\n \n\n. . .\n\nPara poder trabajar con [**variables de distinto tipo**]{.hl-yellow} haremos uso de lo que se conoce como [**data.frame**]{.hl-yellow}: unimos variables de igual longitud pero [**tipo distinto**]{.hl-purple}.\n\n```{r}\n#| code-line-numbers: \"1\"\ntabla <- data.frame(edades, soltero, nombres)\ntabla\n```\n\n---\n\n## Segundo intento: data.frame\n\n```{r}\ntabla\nclass(tabla)\n```\n\n \n\n. . .\n\nDado que un `data.frame` es ya una «base de datos» las variables no son meros vectores matemáticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}\n\n```{r}\nlibrary(lubridate)\ntabla <- data.frame(\"edad\" = edades, \"estado\" = soltero, \"nombre\" = nombres,\n             \"f_nacimiento\" = as_date(c(\"1989-09-10\", \"1992-04-01\", \"1980-11-27\")))\ntabla\n```\n\n---\n\n## Segundo intento: data.frame\n\n[**¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} \n\n\nPuedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`\n\n![](img/view_tabla.jpg){width=\"70%\" fig-align=\"center\"}\n\nNo se recomienda abusar del uso de la función `View()` dado que se consume demasiada memoria RAM.\n\n---\n\n## Segundo intento: data.frame\n\nSi queremos acceder a sus elementos, el operador será similar al de los vectores: ahora [**tenemos dos índices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)\n\n```{r}\ntabla[2, ]  # segunda fila (todas sus variables)\ntabla[, 3]  # tercera columna (de todos los individuos)\ntabla[2, 1]  # primera característica de la segunda persona\n```\n\n. . .\n\n::: columns\n::: {.column width=\"35%\"}\n![](img/menu_data_frame.jpg)\n:::\n\n::: {.column width=\"65%\"}\nTambién tiene ventajas de una [**«base» de datos**]{.hl-yellow} : podemos [**acceder a las variables por su nombre**]{.hl-purple} (recomendable ya que las variables pueden cambiar de posición), poniendo el nombre de la tabla seguido del símbolo `$` (con el **tabulador**, nos aparecerá un menú de columnas a elegir)\n:::\n:::\n\n---\n\n## Segundo intento: data.frame\n\n-   `names()`: nos muestra los nombres de las variables\n\n```{r}\nnames(tabla)\n```\n\n \n\n. . .\n\n-   `dim()`: nos muestra las dimensiones (también `nrow()` y `ncol()`)\n\n```{r}\ndim(tabla)\n```\n\n \n\n. . .\n\n-   Podemos acceder a las variables por su nombre\n\n```{r}\ntabla[c(1, 3), \"nombre\"]\n```\n\n---\n\n## Intento final: tibble\n\nLas tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}\n\nLa principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC\n\n```{r}\n#| error: true\ndata.frame(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n           \"IMC\" = peso / (estatura^2))\n```\n\n\nDe ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})\n\n```{r}\nlibrary(tibble)\ntibble(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n       \"IMC\" = peso / (estatura^2))\n```\n\nUn data.frame puede ser tranformado en un tibble por medio del comando `as_tibble()`.\n\n---\n\n## Intento final: tibble\n\n```{r}\ntabla <- tibble(\"estatura\" = c(1.7, 1.8, 1.6), \"peso\" = c(80, 75, 70),\n                \"IMC\" = peso / (estatura^2))\ntabla\n```\n\nLas tablas en formato `tibble` nos permitirá una [**gestión más ágil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:\n\n. . .\n\n-   [**Metainformación**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automáticamente el número de filas y columnas, y el tipo de cada variable\n\n. . .\n\n-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)\n\n---\n\n## Intento final: tibble\n\n-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning\n\n```{r}\n#| warning: true\ntabla$invent\n```\n\n. . .\n\n-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`\n\n```{r}\ntribble(~colA, ~colB,\n        \"a\",   1,\n        \"b\",   2)\n```\n\n. . .\n\n::: callout-tip\nEl paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de páginas web y documentos sencillos\n:::\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Carga del paquete `{datasets}` el conjunto de datos `airquality` (contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973). ¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviértelo a tibble (busca en la documentación del paquete en <https://tibble.tidyverse.org/index.html>).\n\n```{r}\n#| code-fold: true\n#| eval: false\nlibrary(tibble)\nclass(datasets::airquality)\nairquality_tb <- as_tibble(datasets::airquality)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Una vez convertido a `tibble` obtén el nombre de las variables y las dimensiones del conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?\n\n```{r}\n#| code-fold: true\n#| eval: false\nnames(airquality_tb)\nncol(airquality_tb)\nnrow(airquality_tb)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Filtra solo los datos del mes de agosto.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month == 8, ]\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Selecciona aquellos datos que no sean ni de julio ni de agosto.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month %in% c(7, 8), ]\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Modifica el siguiente código para quedarte solo con las variable de ozono y temperatura.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[, c(\"Ozone\", \"Temp\")]\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\n📝 Selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.\n\n```{r}\n#| code-fold: true\n#| eval: false\nairquality_tb[Month == 8, c(\"Temp\", \"Wind\")]\nnames(airquality_tb) <- c(\"ozono\", \"rad_solar\", \"viento\", \"temp\", \"mes\", \"dia\") \n```\n:::\n\n# R base vs Tidyverse\n\n[**Spoiler: un multiverso de datos limpios**]{style=\"color:#444442;\"}\n\n---\n\n## R base vs Tidyverse\n\nSi conoces algún otro lenguaje de programación (o tienes gente cercana que programa) te extrañará que aún no hayamos hablado de conceptos habituales como\n\n-   [**Bucles for**]{.hl-yellow}: repetir un código un número fijo de iteraciones.\n\n-   [**Bucles while**]{.hl-yellow}: repetir un código hasta que se cumpla una condición\n\n-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el código en función del valor de las variables.\n\n \n\n. . .\n\nY aunque conocer dichas estructuras puede ser en algún momento interesante, en la [**mayoría de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles) [→ en lugar de trabajar con lo que se conoce como R Base vamos a vertebrar el curso en torno a [**Tidyverse**]{.hl-yellow}]{.fragment .fade-in}\n\n---\n\n## ¿Qué es tidyverse?\n\n::: columns\n::: {.column width=\"50%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"50%\"}\n![](img/flow_tidyverse.jpg)\n:::\n:::\n\n`{tidyverse}` es un [**«universo» de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicográficamente sencillo de entender, basado en la idea de que [**nuestros datos están limpios y ordenados (tidy)**]{.hl-purple}\n\n---\n\n## ¿Qué es tidyverse?\n\n::: columns\n::: {.column width=\"45%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"55%\"}\n-   `{tibble}`: optimizando data.frame\n-   `{tidyr}`: limpieza de datos\n-   `{readr}`: carga datos rectangulares (.txt, .csv)\n-   `{dplyr}`: gramática para depurar\n-   `{stringr}`: manejo de textos\n-   `{ggplot2}`: visualización de datos\n-   `{tidymodels}`: modelización/predicción\n:::\n:::\n\nTambién tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para variables cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.\n\n---\n\n\n## ¿Qué es tidyverse?\n\n::: columns\n::: {.column width=\"45%\"}\n![](img/tidyverrse_universe.jpg)\n:::\n\n::: {.column width=\"55%\"}\n-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}\n-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}\n-   `{readr}`: [**carga datos**]{.hl-yellow} rectangulares (.txt, .csv)\n-   `{dplyr}`: [**gramática para depurar**]{.hl-yellow}\n-   `{stringr}`: [**manejo de textos**]{.hl-purple}\n-   `{ggplot2}`: [**visualización de datos**]{.hl-purple}\n-   `{tidymodels}`: [**modelización/predicción**]{.hl-green}\n:::\n:::\n\nTambién tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para variables cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.\n\n---\n\n## Filosofía base: tidy data\n\n> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)\n\n<div style=\"font-size:120px; text-align: center; color:#F8DF58;\"><b>TIDY</b><span style=\"color:#CAB0EE;\"><b>VERSE</b></span></div>\n\nEl [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato de los datos para:\n\n::: incremental\n\n* [**sistematizar**]{.hl-green} la depuración\n* hacer más [**sencillo**]{.hl-green} su manipulación.\n* código [**legible**]{.hl-green}\n\n:::\n \n---\n\n## Reglas del tidy data\n\nLo primero por tanto será entender qué son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos están estandarizados.\n\n\n:::: columns\n::: {.column width=\"50%\"}\n\n::: {.fragment .fade-in}\n1. Cada [**variable**]{.hl-yellow} en una [**única columna**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n2. Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n3. Cada [**celda**]{.hl-yellow} con un [**único valor**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n4. Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}\n:::\n\n::: {.fragment .fade-in}\n5. Si queremos cruzar [**múltiples tablas**]{.hl-yellow} debemos tener una [**columna en común**]{.hl-purple} (llave de cruce).\n:::\n:::\n::: {.column width=\"50%\"}\n![](img/tidy_def.jpg){width=\"160%\"}\n:::\n::::\n\n---\n\n## Tubería (pipe)\n\nEn `{tidyverse}` será clave el [**operador pipe (tubería)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): será una [**tubería que recorre los datos**]{.hl-yellow} y los transforma.\n\n. . .\n\n:::: columns\n::: {.column width=\"50%\"}\nEn R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, sería\n\n```{r}\n#| eval: false\nthird(second(first(datos)))\n```\n:::\n\n::: {.column width=\"50%\"}\n\nEn `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones\n\n```{r}\n#| eval: false\ndatos |> first() |> second() |> third()\n```\n\n:::\n::::\n\n&nbsp;\n\n. . .\n\n::: callout-caution\n## Apunte importante\n\nDesde la versión 4.1.0 de `R` disponemos de `|>`, un pipe **nativo**  disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que dependía del paquete `{magrittr}` (bastante problemático).\n:::\n\n---\n\n## Tubería (pipe)\n\nLa principal ventaja es que el [**código sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas código.\n\n&nbsp;\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  limpio(...) |>\n  filtro(...) |>\n  selecciono(...) |>\n  ordeno(...) |>\n  modifico(...) |>\n  renombro(...) |>\n  agrupo(...) |>\n  cuento(...) |>\n  resumo(...) |>\n  pinto(...)\n```\n:::\n\n::: {.column width=\"50%\"}\n\n<center><img src=\"img/logo_pipe.png\" width=\"360px\"/></center>\n:::\n::::\n  \n\n---\n\n## Datos SUCIOS: messy data\n\n¿Pero qué aspecto tienen los [**datos no tidy**]{.hl-yellow}? \n\nVamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).\n\n \n\n. . .\n\n```{r}\nlibrary(tidyr)\ntable4a\n```\n\n \n\n. . .\n\n[**¿Qué puede estar fallando?**]{.hl-red}\n\n---\n\n## Pivotar: pivot_longer()\n\n:::: columns\n::: {.column width=\"40%\"}\n```{r}\ntable4a\n```\n:::\n\n::: {.column width=\"60%\"}\n\n❎  Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) → las columnas `1999` y `2000` en realidad deberían ser en sí [**valores de una variable**]{.hl-yellow} y no nombres de columnas.\n:::\n::::\n\n. . .\n\nIncluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el año y otra que guarde el valor de la variable de interés en cada uno de esos años. Y lo haremos con la función `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:\n\n```{r}\ntable4a |> \n  pivot_longer(cols = c(\"1999\", \"2000\"), names_to = \"year\", values_to = \"cases\")\n```\n\n\n---\n\n## Pivotar: pivot_longer()\n\n:::: columns\n\n::: {.column width=\"50%\"}\n\n```{r}\ntable4a |> \n  pivot_longer(cols = c(\"1999\", \"2000\"),\n               names_to = \"year\",\n               values_to = \"cases\")\n```\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/table4a.jpg)\n\n:::\n::::\n\n&nbsp;\n\n* `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}\n* `names_to`: nombre de la nueva variable a la que mandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).\n* `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos otro ejemplo con la tabla `table2`\n\n&nbsp;\n\n```{r}\ntable2\n```\n\n\n&nbsp;\n\n[**¿Qué puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Pivotar: pivot_wider()\n\n:::: columns\n::: {.column width=\"60%\"}\n```{r}\n#| echo: false\ntable2\n```\n:::\n\n::: {.column width=\"40%\"}\n\n❎ Cada [**observación está dividido en dos filas**]{.hl-red} → los [**registros con el mismo año deberían ser el mismo**]{.hl-yellow}\n\n:::\n::::\n\n. . .\n\nLo que haremos será lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}\n\n```{r}\ntable2 |>  pivot_wider(names_from = type, values_from = count)\n```\n\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos otro ejemplo con la tabla `table3`\n\n&nbsp;\n\n```{r}\ntable3\n```\n\n\n&nbsp;\n\n[**¿Qué puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Separar: separate()\n\n:::: columns\n::: {.column width=\"60%\"}\n```{r}\ntable3\n```\n:::\n\n::: {.column width=\"40%\"}\n\n❎ Cada [**celda contiene varios valores**]{.hl-red} \n\n:::\n::::\n\n. . .\n\nLo que haremos será hacer uso de la función `separate()` para mandar a [**separar cada valor**]{.hl-yellow} a una columna diferente.\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"))\n```\n\n---\n\n## Separar: separate()\n\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"))\n```\n\nFíjate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deberían ser variables numéricas. Para ello podemos añadir el argumento opcional `convert = TRUE`\n\n. . .\n\n```{r}\ntable3 |> separate(rate, into = c(\"cases\", \"pop\"), convert = TRUE)\n```\n\n---\n\n## Datos SUCIOS: messy data\n\nVeamos el último ejemplo con la tabla `table5`\n\n&nbsp;\n\n```{r}\ntable5\n```\n\n\n&nbsp;\n\n[**¿Qué puede estar fallando?**]{.hl-red}\n\n---\n\n\n## Unir unite()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\ntable5\n```\n:::\n\n::: {.column width=\"50%\"}\n\n❎ Tenemos [**mismos valores divididos en dos columnas**]{.hl-red} \n\n:::\n::::\n\n. . .\n\nUsaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y año en una misma columna\n\n```{r}\ntable5 |> unite(col = year_completo, century, year, sep = \"\")\n```\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\ntable4b |>\n  pivot_longer(cols = \"1999\":\"2000\", names_to = \"year\",\n               values_to = \"cases\")\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\nrelig_income |>\n  pivot_longer(cols = \"<$10k\":\"Don't know/refused\",\n               names_to = \"income\",\n               values_to = \"people\")\n```\n\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?\n\n```{r}\n#| code-fold: true\n#| eval: false\nbillboard |>\n  pivot_longer(cols = \"wk1\":\"wk76\",\n               names_to = \"week\",\n               names_prefix = \"wk\",\n               values_to = \"position\",\n               values_drop_na = TRUE)\n```\n\n:::\n\n# Introducción a Tidyverse\n\n[**Con los datos limpios, podemos trabajarlos**]{style=\"color:#444442;\"}\n\n---\n\n## Preprocesamiento: dplyr\n\nDentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuración**]{.hl-yellow} de datos de datos.\n\n:::: columns\n::: {.column width=\"65%\"}\n![](img/dplyr.png)\n:::\n\n::: {.column width=\"35%\"}\n```{r}\n#| eval: false\ndatos |>\n  limpio(...) |>\n  filtro(...) |>\n  selecciono(...) |>\n  ordeno(...) |>\n  modifico(...) |>\n  renombro(...) |>\n  agrupo(...) |>\n  cuento(...) |>\n  resumo(...) |>\n  pinto(...)\n```\n:::\n::::\n\n---\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\nUna de las operaciones más comunes es [**filtrar registros**]{.hl-yellow} en base a alguna condición lógica: con `filter()` se seleccionarán solo individuos que cumplan ciertas condiciones.\n\n::: incremental\n\n* `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-purple} que\n* `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-purple} que\n* `>=`, `<=`: [**mayor o igual**]{.hl-purple} o [**menor o igual**]{.hl-purple} que\n* `%in%`: valores [**pertenencen**]{.hl-purple} a un listado de opciones\n* `between(variable, val1, val2)`: si los valores (normalmente continuos) [**caen dentro de un rango**]{.hl-purple} de valores\n\n:::\n\n---\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| echo: false\n#| include: false\nlibrary(tidyverse)\ndata(\"starwars\")\n```\n\n```{r}\n#| eval: false\nstarwars |>  dplyr::filter(eye_color == \"brown\")\n```\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(eye_color != \"brown\")\n```\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(eye_color %in% c(\"blue\", \"brown\"))\n```\n\n\n::: callout-tip\n\n## Importante\nRecuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores lógicos**]{.hl-green}.\n\n:::\n\n---\n\n\n## Filtrar filas: filter()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  filtro(condicion)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  filter(condicion)\n```\n:::\n::::\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> filter(between(height, 120, 160))\n```\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |>\n   filter(eye_color == \"brown\" & species != \"Human\")\n```\n\n\n¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan más de 60 años**]{.hl-purple}?\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |>\n  filter((eye_color == \"brown\" & species != \"Human\") | birth_year > 60)\n```\n\n  \n---\n\n## Eliminar ausentes: drop_na()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  retirar_ausentes(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  drop_na(var1, var2, ...)\n```\n:::\n::::\n\nHay un filtro especial que es el de [**retirar los ausentes**]{.hl-yellow}, para lo cual podemos usar `filter(is.na(variable))` o directamente `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquiera de las variables.\n\n. . .\n\n&nbsp;\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> drop_na(mass, height)\n```\n\n```{r}\n#| echo: false\nstarwars |>\n  drop_na(mass, height, sex) |> \n  select(name, mass, height, hair_color) |> \n  slice(1:7)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> drop_na()\n```\n\n```{r}\n#| echo: false\nstarwars |>\n  drop_na() |> \n  select(name, mass, height, hair_color) |> \n  slice(1:7)\n```\n\n:::\n::::\n\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido\n \n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(species == \"Droid\" | is.na(species))\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Selecciona del conjunto de starwars solo los personajes cuyo peso esté entre 65 y 90 kg.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> filter(between(mass, 65, 90))\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na() |> \n  filter(species == \"Human\" & homeworld == \"Tatooine\")\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter((species != \"Human\" & sex == \"male\" &\n            between(height, 120, 170)) |\n           eye_color %in% c(\"brown\", \"red\"))\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝  Busca información en la ayuda de la función `str_detect()` del paquete `{stringr}` (cargado en `{tidyverse}`). Consejo: prueba antes las funciones que vayas a usar con algún vector de prueba para poder comprobar su funcionamiento. Tras saber lo que hace, filtra solo aquellos personajes con apellido `Skywalker`\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> filter(str_detect(name, \"Skywalker\"))\n```\n\n:::\n\n---\n\n## Rebanadas de datos: slice()\n\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> rebanadas(posiciones)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(posiciones)\n```\n:::\n::::\n\nNormalmente filtraremos condición pero a veces nos puede interesar [**filtrar por posición**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de índices**]{.hl-yellow}\n\n. . .\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(1)\n```\n\n```{r}\n#| echo: false\nstarwars |> slice(1) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(7:9)\n```\n\n```{r}\n#| echo: false\nstarwars |> slice(7:9) |> select(name:hair_color)\n```\n:::\n::::\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> slice(c(2, 7, 10, 31))\n```\n\n\n```{r}\n#| echo: false\nstarwars |> slice(c(2, 7, 10, 31)) |> select(name:sex)\n```\n\n---\n\n## Rebanadas de datos: slice()\n\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> rebanadas(posiciones)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice(posiciones)\n```\n:::\n::::\n\nDisponemos de opciones por defecto: con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_head(n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_head(n = 2) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%}\n```{r}\n#| eval: false\nstarwars |> slice_tail(n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_tail(n = 2) |> select(name:hair_color)\n```\n:::\n::::\n\n. . .\n\nCon `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`).\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_min(mass, n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> slice_max(height, n = 2)\n```\n```{r}\n#| echo: false\nstarwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)\n```\n:::\n::::\n\n\n---\n\n\n## Reordenar filas: arrange()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> ordenar(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> arrange(var1, var2, ...)\n```\n:::\n::::\n\nTambién podemos [**ordenar filas**]{.hl-yellow} en función de alguna variable con `arrange()`\n\n```{r}\n#| eval: false\nstarwars |> arrange(mass)\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) \n```\n\n. . .\n\nPor [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`\n\n:::: columns\n::: {.column width=\"50%\"}\n\n```{r}\n#| eval: false\nstarwars |> arrange(desc(height))\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) \n```\n:::\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> arrange(mass, desc(height))\n```\n\n```{r}\n#| echo: false\nstarwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) \n```\n:::\n::::\n\n---\n\n## Eliminar duplicados: distinct()\n\nMuchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`. \n\n```{r}\nstarwars |> distinct(sex)\n```\n\n. . .\n\nPara mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.\n\n```{r}\n#| eval: false\nstarwars |> distinct(sex, .keep_all = TRUE)\n```\n\n```{r}\n#| echo: false\nstarwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)\n```\n\n\n---\n\n## Añadir filas: bind_rows()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ntibble1 |> encuadernar_filas(tibble2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ntibble1 |> bind_rows(tibble2)\n```\n:::\n::::\n\nPor último, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)\n\n\n```{r}\ndatos <-\n  tibble(\"nombre\" = c(\"javi\", \"laura\"), \"edad\" = c(33, 50))\ndatos\n```\n\n\n. . .\n\n```{r}\ndatos |> bind_rows(tibble(\"nombre\" = c(\"carlos\", NA), \"cp\" = c(28045, 28019)))\n```\n\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Selecciona solo los personajes que sean humanos y de ojos marrones, para después ordernarlos en altura descendente y peso ascendente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(eye_color == \"brown\" & species == \"Human\") |> \n  arrange(height, desc(mass))\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n\n📝 Extrae 3 registros aleatoriamente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_sample(n = 3)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n\n📝 Extrae el 10% de los registros aleatoriamente.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_sample(prop = 0.1)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (más pesados, más probable)\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(mass) |> \n  slice_sample(n = 10, weight_by = mass)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Selecciona los 3 personajes más mayores.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> slice_max(birth_year, n = 3)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\n📝 Para saber que valores únicos hay en el color de pelo, elimina duplicados de la variable `hair_color`, eliminando antes los ausentes de dicha variable.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(hair_color) |> \n  distinct(hair_color)\n```\n\n### [**Ejercicio 7**]{.hl-yellow}\n\n📝 De los personajes que son humanos y miden más de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 más altos, y orden de mayor a menor peso. Devuelve la tabla.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  filter(species == \"Human\" & height > 160) |> \n  distinct(eye_color, .keep_all = TRUE) |> \n  drop_na(mass) |> \n  slice_max(height, n = 3) |> \n  arrange(desc(mass))\n```\n\n\n:::\n\n---\n\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\nLa opción más sencilla para [**seleccionar variables por nombre**]{.hl-yellow} es  `select()`, dando como argumentos los nombres de columnas sin comillas.\n\n```{r}\nstarwars %>% select(name, hair_color)\n```\n\n---\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nLa función `select()` nos permite seleccionar varias variables a la vez [**concatenando sus nombres como si fuesen índices**]{.hl-yellow}\n\n```{r}\n#| eval: false\nstarwars |> select(name:eye_color) \n```\n\n```{r}\n#| echo: false\nstarwars |> select(name:eye_color) |> slice(1:4)\n```\n\n. . .\n\nY podemos [**deseleccionar columnas**]{.hl-yellow} con `-`\n\n```{r}\n#| eval: false\nstarwars |>  select(-mass, -(eye_color:starships))\n```\n\n```{r}\n#| echo: false\nstarwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)\n```\n\n\n---\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\nTenemos además [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...\n\n```{r}\n#| eval: false\nstarwars |> select(mass, homeworld, everything())\n```\n\n```{r}\n#| echo: false\nstarwars |> select(mass, homeworld, everything()) |> slice(1:4)\n```\n\n. . .\n\n...y `last_col()` para referirnos a [**la última columna**]{.hl-purple}.\n\n```{r}\n#| eval: false\nstarwars |> select(name:mass, homeworld, last_col())\n```\n\n```{r}\n#| echo: false\nstarwars |> select(name:mass, homeworld, last_col()) |> slice(1:4)\n```\n\n---\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nPodemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresión regular**]{.hl-purple} (`matches()`).\n\n\n```{r}\n# variables cuyo nombre acaba en \"color\" y contengan sexo o género\nstarwars |> select(ends_with(\"color\"), matches(\"sex|gender\"))\n```\n\n\n---\n\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nIncluso podemos [**seleccionar por rango numérico**]{.hl-yellow} si tenemos variables con un prefijo y números.\n\n```{r}\ndatos <-\n  tibble(\"semana1\" = c(115, 141, 232), \"semana2\" = c(7, NA, 17),\n         \"semana3\" = c(95, 162, NA), \"semana4\" = c(11, 19, 15),\n         \"semana5\" = c(NA, 262, 190), \"semana6\" = c(21, 15, 23))\n```\n\n\n. . .\n\nCon `num_range()` podemos seleccionar con un prefijo y una secuencia numérica.\n\n```{r}\ndatos |> select(num_range(\"semana\", 1:4))\n```\n\n---\n\n\n## Selección columnas: select()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> selecciono(var1, var2, ...)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> select(var1, var2, ...)\n```\n:::\n::::\n\n\nPor último, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una función que devuelva un valor lógico de tipo de dato.\n\n```{r}\n# Solo columnas numéricas o de texto\nstarwars |> select(where(is.numeric) | where(is.character))\n```\n\n---\n\n\n## Mover columnas: relocate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  recolocar(var1, despues_de = var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  relocate(var1, .after = var2)\n```\n:::\n::::\n\nPara facilitar la [**recolocación de variables**]{.hl-yellow} tenemos una función para ello, `relocate()`, indicándole en `.after` o `.before` [**detrás**]{.hl-purple} o [**delante**]{.hl-purple} de qué columnas queremos moverlas.\n\n```{r}\nstarwars |> relocate(species, .before = name)\n```\n\n\n\n---\n\n## Renombrar: rename()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> renombrar(nuevo = antiguo)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> rename(nuevo = antiguo)\n```\n:::\n::::\n\nA veces también podemos querer [**modificar la «metainformación»**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.\n\n```{r}\nstarwars |> rename(nombre = name, altura = height, peso = mass)\n```\n\n---\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\nEn muchas ocasiones queremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.\n\n```{r}\nstarwars |> mutate(height_m = height / 100)\n```\n\n---\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\nAdemás con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}\n\n```{r}\nstarwars |> \n  mutate(height_m = height / 100,\n         IMC = mass / (height_m^2), .before = name)\n```\n\n---\n\n\n## Modificar columnas: mutate()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> modificar(nueva = funcion())\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> mutate(nueva = funcion())\n```\n:::\n::::\n\n::: callout-important\n## Importante...\n\nCuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la función que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolverá una constante**]{.hl-red}\n:::\n\n. . .\n\n```{r}\nstarwars |> \n  mutate(constante = mean(mass, na.rm = TRUE), .before = name)\n```\n\n\n---\n\n## Recategorizar: if_else()\n\nTambién podemos combinar `mutate()` con la expresión de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condición**]{.hl-purple}, hace una cosa, en caso contrario otra.\n\n```{r}\nstarwars |> \n  mutate(human = if_else(species == \"Human\", \"Human\", \"Not Human\"),\n         .after = name) |> \n  select(name:mass)\n```\n\n\n---\n\n## Recategorizar: case_when()\n\nPara [**recategorizaciones más complejas**]{.hl-yellow} tenemos  `case_when()`, por ejemplo, para crear una categoría de los personajes en función de su altura.\n \n```{r}\nstarwars |> \n  drop_na(height) |> \n  mutate(altura = case_when(height < 120 ~ \"enanos\",\n                            height < 160 ~ \"bajito\",\n                            height < 180 ~ \"normal\",\n                            height < 200 ~ \"alto\",\n                            TRUE ~ \"gigante\"), .before = name)\n```\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Selecciona solo las variables nombre, altura y así como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.\n \n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(name, height, contains(\"color\")) |> \n  drop_na(height)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(name, height, contains(\"color\")) |> \n  drop_na(height) |> \n  rename(nombre = name, altura = height,\n         color_pelo = eye_color, color_piel = skin_color,\n         color_pelo = hair_color)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detrás de la variable de nombres.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  select(name, height, contains(\"color\")) |> \n  drop_na(height) |> \n  rename(nombre = name, altura = height,\n         color_pelo = eye_color, color_piel = skin_color,\n         color_pelo = hair_color) |> \n  relocate(color_pelo, .after = nombre)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Con los datos originales, comprueba cuántas modalidades únicas hay en la variable de color de pelo.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  distinct(hair_color) |> \n  nrow()\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Del dataset original, selecciona solo las variables numéricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  select(where(is.numeric) | where(is.character)) |> \n  mutate(under_18 = birth_year < 18)\n```\n\n### [**Ejercicio 6**]{.hl-yellow}\n\n📝 Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  mutate(auburn = str_detect(hair_color, \"auburn\"))\n```\n\n### [**Ejercicio 7**]{.hl-yellow}\n\n📝 Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> \n  mutate(IMC = mass / ((height/100)^2),\n         IMC_recat = case_when(species != \"Human\" ~ NA,\n                               IMC < 18 ~ \"delgadez\",\n                               IMC < 30 ~ \"normal\",\n                               TRUE ~ \"sobrepeso\"),\n         .after = name)\n```\n\n:::\n\n---\n\n## Contar: count()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> contar(var1, var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> count(var1, var2)\n```\n:::\n::::\n\nHasta ahora solo hemos transformado o consultado los datos pero no hemos generado estadísticas. Empecemos por lo sencillo: [**¿cómo contar (frecuencias)?**]{.hl-yellow}\n\n. . .\n\nCuando lo usamos en solitario `count()` nos devolverá simplemente el número de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**número de elementos de cada modalidad**]{.hl-purple}. \n\n```{r}\nstarwars |> count(sex)\n```\n\n---\n\n## Contar: count()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> contar(var1, var2)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> count(var1, var2)\n```\n:::\n::::\n\nAdemás si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolverá el [**conteo ordenado**]{.hl-purple} (más frecuentes primero).\n\n```{r}\nstarwars |> count(sex, gender, sort = TRUE)\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\nUna de las [**funciones más potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitirá [**agrupar nuestros registros**]{.hl-yellow} previamente\n\n```{r}\nstarwars |> \n  group_by(sex) |>\n  count() |>\n  ungroup()\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\nCuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificará las acciones futuras: las [**operaciones se aplicarán a cada subtabla por separado**]{.hl-purple}\n\n. . .\n\nPor ejemplo, imaginemos que queremos extraer el personaje más alto con `slice_max()`.\n\n```{r}\nstarwars |> slice_max(height)\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\n¿Y si queremos [**extraer el personaje más alto pero...de cada uno de los sexos**]{.hl-yellow}?\n\n. . .\n\n```{r}\nstarwars |>\n  group_by(sex) |> \n  slice_max(height) |> \n  ungroup()\n```\n\n---\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |> \n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |> \n  ungroup()\n```\n:::\n::::\n\n:::: columns\n::: {.column width=\"50%\"}\n![](img/tidydatatutor_1.jpg)\n:::\n\n::: {.column width=\"50%\"}\n![](img/tidydatatutor_2.jpg)\n:::\n::::\n\nLa web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)\n\n---\n\n\n## Agrupar: group_by()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |>\n  agrupar(var1, var2) |> \n  accion() |>\n  desagrupar()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |>\n  group_by(var1, var2) |> \n  accion() |>\n  ungroup()\n```\n:::\n::::\n\n::: callout-important\n## Importante\nRecuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada\n:::\n\n. . .\n\nEn la nueva versión de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`\n\n```{r}\n#| eval: false\nstarwars |> slice_max(height, by = sex)\n```\n\n.\n\n. . .\n\n```{r}\n#| eval: false\nstarwars |> slice_max(height, by = sex) |> select(name:eye_color)\n```\n\n---\n\n## Fila-a-fila: rowwise()\n\nUna opción muy útil usada antes de una operación también es `rowwise()`: toda [**operación que venga después se aplicará en cada fila por separado**]{.hl-yellow}. Por ejemplo, vamos a definir un conjunto dummy de notas.\n\n```{r}\nnotas <- tibble(\"mates\" = c(7.5, 8, 9.1, 3),\n                \"lengua\" = c(8, 6, 6.5, 9.2))\n```\n\n. . .\n\nSi aplicamos la media directamente el valor será idéntico ya que nos ha hecho la media global, pero nos gustaría sacar una [**media por registro**]{.hl-yellow}. Para eso usaremos `rowwise()`\n\n```{r}\nnotas |> \n  rowwise() |> \n  mutate(media_curso = mean(c(mates, lengua)))\n```\n\n\n---\n\n## Resumir: summarise()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> summarise()\n```\n:::\n::::\n\nPor último tenemos `summarise()`, que nos permitirá sacar resúmenes estadísticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.\n\n```{r}\nstarwars |> \n  drop_na(height) |> \n  summarise(media_altura = mean(height))\n```\n\n. . .\n\n::: callout-warning\n## Cuidado\nFíjate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que esté indicado.\n:::\n\n---\n\n## Resumir: summarise()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> summarise()\n```\n:::\n::::\n\nSi además esto lo [**combinamos con la agrupación**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas líneas de código puedes obtener [**estadísticas desagregadas**]{.hl-purple}\n\n```{r}\nstarwars |> \n  drop_na(sex, height, mass) |> \n  summarise(media_altura = mean(height),\n            media_peso = mean(mass),\n            .by = sex)\n```\n\n---\n\n## Resumir: reframe()\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\ndatos |> resumir()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| eval: false\nstarwars |> reframe()\n```\n:::\n::::\n\nEn el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos más de un valor por variable**]{.hl-yellow}.\n\n:::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| eval: true\nstarwars |>\n  drop_na(mass) |>\n  summarise(quantile(mass))\n```\n:::\n::: {.column width=\"50%\"}\n```{r}\n#| eval: true\nstarwars |>\n  drop_na(mass) |>\n  reframe(quantile(mass))\n```\n:::\n::::\n\n---\n\n## Selectores: across()\n\nUn truco es [**hacer uso de selectores**]{.hl-yellow} `across` y `where`. El primero nos permite [**actuar sobre varias columnas por  nombre**]{.hl-purple} (con `mutate` o `summarise`)\n\n```{r}\nstarwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)\n```\n\n. . .\n\nEl segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.\n\n```{r}\nstarwars |> \n  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))\n```\n\n---\n\n## 💻 Tu turno\n\n[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style=\"color:#444442;\"}\n\n::: panel-tabset\n\n### [**Ejercicio 1**]{.hl-yellow}\n\n📝 Calcula cuántos personajes hay de cada especie, ordenados de más a menor frecuencia.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |> count(species, sort = TRUE)\n```\n\n### [**Ejercicio 2**]{.hl-yellow}\n\n📝 Tras eliminar ausentes en las variables de peso y estatura, añade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(mass, height) |> \n  mutate(IMC = mass / ((height/100)^2)) |> \n  summarise(IMC_medio = mean(IMC), .by = sex)\n```\n\n### [**Ejercicio 3**]{.hl-yellow}\n\n📝 Obtén el personaje más joven por cada sexo.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  slice_min(birth_year, by = sex)\n```\n\n### [**Ejercicio 4**]{.hl-yellow}\n\n📝 Obtén la edad del personaje más joven y más viejo de cada sexo.\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  drop_na(birth_year) |>\n  summarise(min(birth_year), max(birth_year), .by = sex)\n```\n\n### [**Ejercicio 5**]{.hl-yellow}\n\n📝 Determina la cantidad de personajes en cada década (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.\n\n\n```{r}\n#| code-fold: true\n#| eval: false\nstarwars |>\n  count(birth_decade = round(birth_year, -1))\n```\n\n:::\n\n\n# Caso real: datos de encuestas\n\n[**Pongamos en práctica lo aprendido...**]{style=\"color:#444442;\"}\n\n---\n\n## Caso real: datos de encuestas\n\nEl paquete `{readr}` (ya en `{tidyverse}`) nos permite realizar una carga más ágil y más inteligente que el `read.csv()` de base (lo importa a un `tibble` e interpreta bien el tipo de cada variable, incluso fechas)\n\n```{r}\n#| echo: false\n#| eval: false\nencuestas <- read_csv(file = \"./datos/historical_surveys.csv\")\nencuestas <-\n  encuestas |>\n  mutate(cod_elec = \"02\") |> \n  select(type_survey, date_elec, id_pollster, pollster,\n         media, field_date_from, field_date_to, exit_poll,\n         size, turnout, abbrev_candidacies, est_vote) |> \n  pivot_wider(names_from = \"abbrev_candidacies\",\n              values_from = \"est_vote\")\nwrite_csv(encuestas, file = \"./datos/historical_surveys.csv\")\n```\n\n```{r}\nencuestas <- read_csv(file = \"./datos/historical_surveys.csv\")\nencuestas\n```\n\n---\n\n## Caso real: datos de encuestas\n\nLo [**primero que debes hacer**]{.hl-yellow} es visualizar con `View()` la tabla para entenderla\n\n. . .\n\n* [**Primera tarea**]{.hl-purple}: crea una variable llamada `id_survey` que nos permita identificar a cada encuesta. ¿Qué podríamos concatenar?\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |> \n  # Creamos un id con type_survey-date_elec-id_pollster\n  # con .before la ponemos delante de everything(), de todo (1ª col)\n  mutate(id_survey = glue(\"{type_survey}-{date_elec}-{id_pollster}\"),\n         .before = everything())\n```\n\n---\n\n## Caso real: datos de encuestas\n\n* [**Segunda tarea**]{.hl-purple}: usando la variable `id_survey` creada elimina duplicados.\n\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |>\n  # Eliminamos duplicados por id_survey, pero mantenemos todas las\n  # columnas con .keep_all = TRUE\n  distinct(id_survey, .keep_all = TRUE)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n* [**Tercera tarea**]{.hl-purple}: tenemos una variable `media` que representa el medio en el que se publicó o encargo la encuesta. Elimina dicha variable, así como el tipo de encuesta y el id de la encuestadora\n\n\n```{r}\n#| code-fold: true\nencuestas <-\n  encuestas |> \n  # Eliminamos las columnas pedidas con un -\n  # las concateno para usar solo un - para todas\n  select(-c(type_survey, id_pollster, media))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Cuarta tarea**]{.hl-purple}: quédate solo con las encuestas cuyo tamaño muestral conozcamos y que no sean encuestas a pie de urna. Elimina esta última variable.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # eliminar ausentes\n  drop_na(size) |> \n  # Filtramos encuestas (registros) a pie de urna (aquellas que exit_poll == FALSE)\n  dplyr::filter(!exit_poll) |> \n  # Quitamos la variable pie de urna\n  select(-exit_poll)\n```\n\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Quinta tarea**]{.hl-purple}: convierte el dataset en tidydata. ¿Qué falla? ¿Cómo arreglarlo? Reminder: no queremos ausentes.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Convertimos a tidydata\n  pivot_longer(cols = -(id_survey:turnout),\n               names_to = \"partido\",\n               values_to = \"est_voto\",\n               values_drop_na = TRUE)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Sexta tarea**]{.hl-purple}: calcula el número de días que la encuesta ha hecho trabajo de campo, y coloca dicha columna tras el nombre de la encuestadora. Tras ello elimina aquellas encuestas que tengan 0 días de trabajo de campo.\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Calculamos los días de campo como la diferencia de fechas \n  # con as.numeric() convertimos la dif. de fechas a un número\n  mutate(n_dias_campo = as.numeric(field_date_to - field_date_from),\n         .after = pollster) |> \n  # Solo aquellas cuyo trabajo de campo haya durado 1 día o más\n  dplyr::filter(n_dias_campo > 0)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Séptima tarea**]{.hl-purple}: calcula el número de días que faltan hasta las elecciones desde que la encuesta cerro el trabajo de campo y coloca dicha variable tras `n_dias_campo`. Tras ello elimina las fechas de inicio y fin de trabajo de campo de la manera más eficiente posible\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |> \n  # Calculamos los días que faltan a las elecciones\n  # con as.numeric() convertimos la dif. de fechas a un número\n  mutate(n_dias_elec = as.numeric(date_elec - field_date_to),\n         .after = n_dias_campo) |> \n  # Eliminamos ya las fechas de campo que no necesitamos\n  select(-contains(\"field\"))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Octava tarea**]{.hl-purple}: elimina encuestas que se hayan cerrado dentro de la ventana temporal en la que está prohibido la publicación de encuestas (no se deberían usar para predecir ya que «no se conocen»)\n\n```{r}\n#| code-fold: true\nencuestas <- encuestas |>\n  # Solo con encuestas antes del baneo electoral\n  dplyr::filter(n_dias_elec > 15)\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Novena tarea**]{.hl-purple}: obtén, por cada elección, la media de las encuestas de cada partido\n\n```{r}\n#| code-fold: true\nencuestas |>\n  # Resumen: media de voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\"))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Décima tarea**]{.hl-purple}: realiza lo mismo que la tarea anterior pero solo para las encuestas de los 60 días previos a las elecciones. Ordena la salida de reciente a antiguo\n\n```{r}\n#| code-fold: true\nencuestas |>\n  # Filtramos ventana de 60 días\n  dplyr::filter(n_dias_elec <= 60) |>\n  # Media de est_voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\")) |>\n  # Ordenar de mayor a menor\n  arrange(desc(date_elec))\n```\n\n---\n\n## Caso real: datos de encuestas\n\n\n* [**Undécima tarea**]{.hl-purple}: del dataset generado en el anterior ejercicio, obtén el primer y el segundo con mayor estimación de voto (en promedio)\n\n```{r}\n#| code-fold: true\nencuestas |> \n  # Filtramos ventana de 60 días\n  dplyr::filter(n_dias_elec <= 60) |> \n  # Media de est_voto por fecha y partido\n  summarise(media_voto = mean(est_voto),\n            .by = c(\"date_elec\", \"partido\")) |>\n  # Ordenar de mayor a menor por fecha\n  arrange(desc(date_elec)) |>\n  # extraemos los dos con más est de voto (por cada fecha)\n  slice_max(media_voto, n = 2, by = date_elec)\n```\n\n# El mundo Github\n\n[**Trabajar ordenados, publicar resultados, replicabilidad de lo realizado**]{style=\"color:#444442;\"}\n\n---\n\n## ¿Qué es Github?\n\n[**GitHub**]{.hl-yellow} es la plataforma colaborativa más conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}\n\n. . .\n\n* [**¿Qué es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programación colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.\n\n. . .\n\n* [**¿Qué es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servirá no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcción de nuestros proyectos de código.\n\n. . .\n\n::: callout-important\n## Importante\n\nDesde el 4 de junio de 2018 Github es de Microsoft (ergo el código que subas también)\n\n:::\n\n---\n\n## Visión general\n\nTras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un círculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto\n\n:::: columns\n::: {.column width=\"55%\"}\n\n![](img/github_1.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"45%\"}\n* [**Edit profile**]{.hl-purple}: nos permite añadir una [**descripción y foto de perfil**]{.hl-yellow}.\n\n* [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizará nuestra actividad**]{.hl-yellow} a lo largo del tiempo.\n\n\n* [**Repositories**]{.hl-purple}: el códugo será subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.\n\n:::\n::::\n\n---\n\n## Primer uso: consumidor\n\nAntes de aprender como crear repositorios, Github también nos servirá para\n\n* [**Acceder a código**]{.hl-purple} ajeno\n* [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos\n\n. . .\n\n* [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente «amplio» para poder ser subido como paquete.\n\nEl código de paquetes que no tengamos subido en CRAN podremos [**instalarlo como código desde Github**]{.hl-yellow}\n\n---\n\n## Instalar desde Github\n\n\nPor ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya única función es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**álbumes de música urbana**]{.hl-yellow}\n\n:::: columns\n::: {.column width=\"50%\"}\n\n![](img/perrreo.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/rosalia.png){width=\"360\" fig-align=\"center\"}\n:::\n::::\n\n. . .\n\nPara ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitirá la instalación desde Github\n\n```{r}\n#| eval: false\ninstall.packages(\"devtools\")\n```\n\n---\n\n## Instalar desde Github\n\nLas [**instrucciones de instalación**]{.hl-yellow} suelen venir detalladas en la portada del repositorio\n\n:::: columns\n::: {.column width=\"50%\"}\n\n![](img/install_perreo.png){fig-align=\"center\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/rosalia.png){width=\"310\" fig-align=\"center\"}\n:::\n::::\n\n. . .\n\nEn la mayoría de casos bastará con la función `install_github()` (del paquete que acabamos de instalar), pasándole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin \"github.com/\"). \n\n```{r}\n#| eval: false\ndevtools::install_github(\"jbgb13/peRReo\")\n```\n\n\nYa puedes perrear con ggplot ;)\n\n\n---\n\n## Descargar desde Github\n\nLa mayoría de veces lo que subamos no será un paquete de R como tal sino que [**subiremos un código más o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.\n\nPor ejemplo, vamos a descargarnos los scripts de `tidytable` que ha subido Hadley Wickham [TIDY:TABLE](https://github.com/hadley/tidytable)\n\n![](img/ceo_github.png){fig-align=\"center\"}\n\n---\n\n## Nuestro primer repositorio\n\nPara [**crear nuestro primero repositorio**]{.hl-yellow} que servirá además como [**carta de presentación**]{.hl-yellow} de nuestro perfil en Github, deberás tener una cuenta ya creada en [Github](https://github.com) y tener [Git](https://git-scm.com) instalado.\n\n\n1. Teniendo lo anterior ya realizado, podemos usar la librería [**usethis**]{.hl-purple} para simplificar el proceso.\n\n```{r}\n#| eval: false\ninstall.packages(\"usethis\")\n```\n\n2. Luego configuramos nuestras credenciales (los datos que usamos para la cuenta de GitHub):\n```{r}\nusethis::use_git_config(\n   user.name = \"Mi nombre\",\n   user.email = \"micorreo@gmail.com\"\n )\n```\n\n\n---\n\n## Nuestro primer repositorio\n\n3. Creamos nuestro GitHub PAT Token (es como una contraseña, pero más segura). \n\n```{r}\n#| eval: false\nusethis::create_github_token()\n```\n\nCuando ejecutas este comando, se te abrirá una pestaña de tu navegador. Tendrás que verificar algunos permisos a GitHub. Luego, en la configuración del token, cambia el nombre, ajusta el tiempo de expiración y el resto déjalo como está. Crea el token.\n\n4. Para guardar tu nuevo token, usa:\n\n```{r}\n#| eval: false\ngitcreds::gitcreds_set()\n```\n\nEn la consola se te mostrará un menú. Selecciona la opción 2: **Replace these credentials**. Luego copia el token de GitHub, actualiza y guarda tus credenciales.\n\n\n---\n\n\n## Nuestro primer repositorio\n\n5. Reinicia la sesión de RStudio para que [**se hagan efectivos los cambios**]{.hl-yellow}. Usualmente puedes usar **CTRL + SHIFT + F10** o del menú de arriba selecciona la pestaña de **Session** y luego **Restart R**.\n\n6. Usa `usethis::git_sitrep()` para verificar si tus credenciales como nombre, email y PAT están correctamente configuradas.\n\nFíjate que salga este texto: \n\n**Personal access token for https://github.com ... **\n\nCon eso ya deberíamos estar listos con la configuración de GIT y GitHub.\n\n\n---\n\n## Nuestro primer repositorio\n\n7. Usaremos `use_git()` para iniciar el control de versiones de GIT en nuestro proyecto.\n\n![](img/use_git.png){width=\"380\" fig-align=\"center\"}\n\n8. Ahora, usaremos `usethis::use_github()` para crear un repositorio en GitHub y subir el proyecto.\n\nSi todo ha salido bien, se debería abrir tu navegador con el nuevo repositorio de GitHub.\n\n---\n\n## Github pages\n\n¿Cómo [**convertir nuestro repositorio en una web**]{.hl-yellow}?\n\n![](./img/github-pages.png){fig-align=\"center\"}\n\n1. Haz click en `Settings`\n2. Ve al apartado `Pages`\n3. En el subapartado `branch` selecciona la única rama que tenemos ahora (`main`)\n4. Selecciona la carpeta donde tengas el `.html` (en web complejas estará como en cualquier web en `docs`, en algo simple estará en la ruta raiz del repositorio)\n5. Haz click en `Save`\n\n---\n\n## Github pages\n\nSi te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web está en proceso de ser desplegada (deploy)**]{.hl-orange}\n\n![](./img/github-naranja.png){fig-align=\"center\"}\n\n---\n\n## Github pages\n\nPasados unos segundos (dependiendo del tamaño de la web y tu conexión a internet) ese [**icono pasará a ser un check verde**]{.hl-green}: habemus web\n\n![](./img/github-verde.png){fig-align=\"center\"}\n\n\nEl [**link de la web por defecto**]{.hl-yellow} será `{nombre_usuario}.github.io/{nombre_repo}`\n\n---\n\n## Github pages\n\n\n![](./img/github-pages-deploy.png){fig-align=\"center\"}\n\n¡Un momento! Ahora mismo nuestra web [**no nos está mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.\n\n. . .\n\nPara que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este último llamándolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}\n\n---\n\n## Github pages\n\nVamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro\n\n\n![](./img/repo-index-html.png){fig-align=\"center\"}\n\n---\n\n## Github pages\n\nSi [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...\n\n:::: columns\n::: {.column width=\"50%\"}\n![](./img/index-html-qmd.png){fig-align=\"center\"}\n:::\n::: {.column width=\"50%\"}\n\nSi a tu `.qmd` ya le llamas de inicio `index.qmd`, automáticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar añadiendo un archivo `css` de estilos)\n\n[**Habemus web**]{.hl-green} simplemente clickando en Pages :)\n\n:::\n::::\n\n\n---\n\n## Repo con diapositivas\n\nVamos a crear el último repositorio que se llamará `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.\n\n\n:::: columns\n::: {.column width=\"45%\"}\n![](img/quarto-slides.png)\n:::\n::: {.column width=\"55%\"}\nLa forma de escribir será igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)\n\nLlama al archivo directamente `index.qmd`, súbelo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}\n:::\n::::\n\n\n# El mundo ggplot2\n\n[**Visualización de datos**]{style=\"color:#444442;\"}\n\n\n## ¿Qué es ggplot2?\n\n[**ggplot2**]{.hl-purple} es un paquete para graficar, que facilita crear gráficas complejas a partir de datos en un [**data frame, data table o tibble**]{.hl-yellow}\n\n:::: columns\n::: {.column width=\"70%\"}\n\n- Incluye varias funciones para especificar que variables graficar, como éstas son [**expuestas**]{.hl-yellow}, y varias otras características [**visuales**]{.hl-yellow}. \n\n- Funciona mejor con datos extensos, es decir, con aquellas estructuras donde se tiene una [**columna por cada dimensión o atributo**]{.hl-yellow}, y una [**fila por cada observación**]{.hl-yellow}.\n\n::: callout-important\n## Importante\n\nggplot2 está incluido en el paquete tidyverse.\n\n:::\n\n:::\n::: {.column width=\"30%\"}\n![](img/ggplot2.png)\n:::\n::::\n\n\n---\n\n## Primera capa: el área del gráfico\n\n::: incremental\n- La función principal de ggplot2 es justamente `ggplot()` que permite iniciar el gráfico y además definir las [**características globales**]{.hl-yellow}. El primer argumento de esta función serán los datos que vas a visualizar.\n\n- El segundo argumento se llama `mapping` (mapeo en inglés). Este argumento [**define la relación**]{.hl-yellow} entre cada columna del data frame y los distintos parámetros gráficos.\n\n- Por ejemplo, qué columna va a representar el eje x, cuál va a ser el eje y, etc. Este mapeo se hace siempre con la función `aes()` (que viene de aesthetics, estética en inglés).\n\n:::\n\n```{r}\n#| eval: true\n#| echo: true\ndatos <- tibble(Edad = seq(4,24, by = 2), \n                Estaturas = c(102, 109, 115, 121, 133, 141, 156, 167, 181, 187, 188),\n                Marca = sample(c(\"A\", \"B\"), size = 11, replace = TRUE))\n```\n\n```{r}\n#| eval: false\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas))\n```\n\n---\n\n## Segunda capa: geometrías\n\nEl código anterior sólo genera el área del gráfico y los ejes. Lo que falta es indicar con qué geometrías representar los datos.\n\nPara agregar geometrías lo que hay que hacer es sumar el resultado de una función que devuelva una nueva capa. Estas suelen ser funciones que empiezan con `geom_` y luego el nombre de la geometría (en inglés).\n\n::: incremental\n- [**geom_point()**]{.hl-purple}: para gráficos de dispersión.\n\n- [**geom_boxplot()**]{.hl-purple}: para gráficos de caja y bigotes.\n\n- [**geom_line()**]{.hl-purple}: para líneas de tendencias, series de tiempo, etc.\n\n- [**geom_histogram()**]{.hl-purple}: para gráficos de barras.\n\n:::\n\n::: callout-important\n## Importante\n\nUsa + para agregar un geom a una línea de comandos de ggplot.\n\n:::\n\n---\n\n## Gráfico de dispersión\n\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas)) + geom_point(size = 3, shape = 5, colour = \"blue\")\n```\n\n---\n\n## Gráfico de cajas y bigotes\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(y = Estaturas, fill = Marca)) + geom_boxplot()\n```\n\n---\n\n## Gráfico de líneas\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas, colour = Marca)) + geom_line(size = 1.2, linetype = \"dashed\")\n```\n\n\n---\n\n## Gráfico de áreas\n\n```{r}\n#| eval: true\nggplot(data = datos, mapping = aes(x = Edad, y = Estaturas)) + geom_area(colour = \"red\", fill = \"blue\", alpha = 0.3)\n```\n---\n\n## Nuestra Biblia\n\n![](img/cover.jpg){fig-align=\"center\"}\n\nSe puede acceder libremente al recurso a través del siguiente enlace: [**https://r-graphics.org**](https://r-graphics.org){.uri}\n\n\n\n\n# ENLACES\n\n[**Algunos paquetes o recursos curiosos**]{style=\"color:#444442;\"}\n\n\n---\n\n### Paletas de colores\n\n* [**{ggthemes}**]{.hl-purple}: [**temas y paletas extras**]{.hl-yellow} para ggplot (por ejemplo para **daltónicos**) <https://jrnold.github.io/ggthemes/> y <https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/>\n\n* [**{peRReo}**]{.hl-purple}: paletas inspiradas en [**portadas de música urbana y latina**]{.hl-yellow} <https://github.com/jbgb13/peRReo>\n\n* [**Paletas inspiradas en el Metropolitan Museum**]{.hl-purple}: de Blake Robert Mills <https://github.com/BlakeRMills/MetBrewer/tree/main>\n\n* [**Paletas inspiradas en Harry Potter**]{.hl-purple}: de Alejandro Jiménez <https://github.com/aljrico/harrypotter>\n\n* [**{colorblindcheck}**]{.hl-purple}: detectar paletas de colores aptas [**daltónicos/as**]{.hl-yellow}. De Jakub Nowosad <https://github.com/Nowosad/colorblindcheck>\n\n---\n\n### Dataviz\n\n* [**R Graph Gallery**]{.hl-purple}: colección de dataviz en R <https://www.r-graph-gallery.com/>\n\n* [**{patchwork}**]{.hl-purple}: agregar y [**componer gráficas**]{.hl-yellow}. De Thomas Lin Pedersen. <https://patchwork.data-imaginist.com>\n\n* [**ggplotly**]{.hl-purple}: función de `{plotly}`, para convertir ggplot a plotly ([**interactiva**]{.hl-yellow}) <https://www.rdocumentation.org/packages/plotly/versions/4.10.0/topics/ggplotly>.\n\n\nTras convertirlo a plotly se puede [**guardar automáticamente en html**]{.hl-yellow} con <https://plotly-r.com/saving.html> y generar el [**código del iframe responsive**]{.hl-yellow} con <https://bhaskarvk.github.io/widgetframe/articles/Using_widgetframe.html>\n\n\n\n---\n\n### Dataviz\n\n* [**{ggiraph}**]{.hl-purple}: gráficas interactivas al [**estilo D3**]{.hl-yellow}. <https://davidgohel.github.io/ggiraph/>\n\n* [**Aprender a usar {ggiraph}**]{.hl-purple}: para gráficas interactivas al [**estilo D3**]{.hl-yellow} <https://albert-rapp.de/posts/ggplot2-tips/17_ggiraph/17_ggiraph.html> \n\n* [**Gráficas interactivas**]{.hl-purple}: <https://www.tanyashapiro.com/interactive-visuals>\n\n* [**{geomtextpath}**]{.hl-purple}: paquete para [**curvar el texto**]{.hl-yellow} ajustándose a una gráfica. De Allan Cameron y Teun van den Brand. <https://allancameron.github.io/geomtextpath/>\n\n* [**{ggstream}**]{.hl-purple}: visualización de [**datos en flujo**]{.hl-yellow}. De Z. Gu. <https://github.com/davidsjoberg/ggstream>\n\n* [**{ggpattern}**]{.hl-purple}: rellenos con [**patrones geométricos**]{.hl-yellow} en ggplot2. De coolbutuseless y Trevor L. Davis. <https://github.com/coolbutuseless/ggpattern>\n\n---\n\n### Mapas\n\n* [**{mapSpain}**]{.hl-purple}: visualización de [**datos en mapas de España**]{.hl-yellow} en R. De Diego Hernangómez <https://dieghernan.github.io/rpubs/mapSpain_RMadrid/#1>\n\n* [**{rasterpic}**]{.hl-purple}: visualización de [**mapas con imágenes rasterizados de fondo**]{.hl-yellow}. De Diego Hernangómez. <https://dieghernan.github.io/rasterpic/>\n\n\n---\n\n\n### Text mining\n\n* [**Manual de text mining**]{.hl-purple}: de Julia Silge y David Robinson. Recurso: <https://tidytextmining.com>\n\n* [**Descarga de textos libres**]{.hl-purple}: de David Robinson. Recurso: <https://github.com/ropensci/gutenbergr>\n\n* [**Análisis de sentimientos de tweets**]{.hl-purple}: de Harshvardhan. Recurso: <https://www.harsh17.in/twitter-sentiments/>\n\n### Grafos y redes\n\n* [**{tidygraph}**]{.hl-purple}: paquete al estilo `{tidyverse}` para [**visualizar y manipular grafos**]{.hl-yellow} <https://tidygraph.data-imaginist.com/index.html>\n\n\n---\n\n\n### Datos curiosos\n\n* [**{fitbitr}**]{.hl-purple}: API para acceder a [**datos de pulseras fitbit**]{.hl-yellow}. De Matt Kaye <https://mrkaye97.github.io/fitbitr/index.html>\n\n* [**{rtweet}**]{.hl-purple}: API para acceder (al menos antes) a [**Twitter**]{.hl-yellow}. De Michael W. Kearney <https://docs.ropensci.org/rtweet/>\n\n* [**{owiDR}**]{.hl-purple}: API para acceder a datos de [**Our World in Data**]{.hl-yellow} <https://github.com/piersyork/owidR>\n\n* [**{wordle}**]{.hl-purple}: API para acceder a [**datos de WORDLE**]{.hl-yellow}. De coolbutuseless <https://coolbutuseless.github.io/2022/01/04/wordle-v0.1.5-a-package-for-playing-and-helping-solve-wordle-puzzles/>\n\n* [**{chessR}**]{.hl-purple}: API para acceder a datos de [**partidas de ajedrez**]{.hl-yellow}. De Jason Zivkovic <https://github.com/JaseZiv/chessR>\n\n\n---\n\n\n### Informes, libros, diapositivas y webs\n\n* [**Manual de Quarto**]{.hl-purple}: el nuevo rmarkdown, más completo y sencillo para elaborar manuales, diapositivas, informes e incluso webs <https://quarto.org/docs/guide/>\n\n* [**Shiny**]{.hl-purple}: webs interactivas con R <https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/>\n\n### Tablas\n\n* [**{gt}**]{.hl-purple}: tablas en R. De RStudio <https://gt.rstudio.com/>\n\n* [**{gtExtras}**]{.hl-purple}: visualización de datos en tablas. De Thomas Mock. <https://jthomasmock.github.io/gtExtras/index.html>\n\n* [**Tutorial de tablas**]{.hl-purple}: de Benjamin Nowak <https://bjnnowak.netlify.app/2021/10/04/r-beautiful-tables-with-gt-and-gtextras/>\n\n\n# ¡GRACIAS!\n\n\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","output-file":"index.html"},"language":{"toc-title-document":"Tabla de contenidos","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Consejo","callout-note-title":"Fíjate que...","callout-warning-title":"Cuidado","callout-important-title":"Importante","callout-caution-title":"Peligro","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar código","code-tools-hide-all-code":"Ocultar código","code-tools-view-source":"Ver código","code-tools-source-code":"Código fuente","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Buscar","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"es","fig-responsive":false,"quarto-version":"1.3.450","auto-stretch":true,"title":"Análisis y visualización de datos con R","subtitle":"Simulación (IMAD743)","title-slide-attributes":{"data-background-image":"img/highcharts.jpg","data-background-size":"contain","data-background-opacity":"0.40"},"author":"Escuela Politécnica Nacional","affiliation":"Escuela Politécnica Nacional","theme":["default","style.scss"],"chalkboard":true,"multiplex":false,"menu":{"side":"left","width":"normal"},"footer":"[<strong>Diego Paúl Huaraca S.</strong>](...) • Semestre 2025-B","slideNumber":"c/t"}}},"projectFormats":["html"]}